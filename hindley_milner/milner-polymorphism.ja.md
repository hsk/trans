# プログラミングにおける多相型の理論

    ROBIN MILNER

    Computer Science Department, University of Edinburgh, Edinburgh, Scotland

    Received October 10, 1977; revised April 19, 1978

  この作業の目的は、主に実用的なものです。
  型の規律を課さない構造処理言語におけるプログラミングの広く採用されたスタイルは、多種多様なオブジェクトでうまく動作するプロシージャを定義することを必要とします。
  そのような多相的手続きのための形式的な型の規律を、単純なプログラミング言語の文脈で提示し、規律を強制するコンパイル時型検査アルゴリズム W を提示します。
  意味的健全性定理(言語の正式な意味論に基づく)は、井戸型プログラムは`間違っていない`ことができないと述べており、構文健全性定理は、 W がプログラムを受け入れるならば型付けされていると述べています。
  これらの結果をより豊かな言語に拡張することについても議論します。 エジンバラ LCF システムのメタ言語 ML については、 W に基づく型検査アルゴリズムが実際には既に実装されて動作しています。

## 1. はじめに

  この作業の目的は、主に実用的なものです。
  広く使われているプログラミングのスタイルは、特に型の規律を課さない構造処理言語 (LISP は完全な例です)では、多種多様なオブジェクト(例えば、 atom のリスト、整数、またはリストなど)でうまく動作するプロシージャを定義します)。
  このような柔軟性は、このスタイルのプログラミングではほとんど不可欠です。残念ながら、誤って CDR を LISP のアトムに適用し、不自然にプロパティリストを整数に追加する人は、その症状を知ることになります。
  一方、上記の柔軟性を排除する ALGOL 68 [22] のような型の規律は、我々が話しているプログラミングスタイルを排除します。
  ALGOL 60 は柔軟性がありました。つまり、手続きパラメータは "手続き" として指定する必要がありました。しかし、柔軟性は一様ではなく、十分ではありませんでした。

  このような柔軟性についての初期の議論は、おそらく多相性と呼ばれる最初の者であった Strachey [19] に見出すことができます。
  実際、彼はそれを "パラメトリック" 多相型と呼んでいました。これは、"アドホック" 多相型とは対照的でした。
  後者の例は、整数加算と実加算の両方を表すために "-|" を使用することです(実際には、複素加算、ベクトル加算などを表すためにさらに拡張することができます)。いくつかの異なる型でこの識別子を使用することは、現在は "オーバーロード" と呼ばれていることが多く、このホワイトペーパーではそれに言及していません。


<!-- 348 1/28 -->

  0022 - 0000/78/0173 - 0348 $ 02. 00/0
  Copyright 8 1978 by Academic Press, Inc.
  All rights of reproduction in any form reserved.

<!-- 349 2/28 -->

  この論文では、型の柔軟性を獲得する方法を提示し、正当化する一方で、堅牢なプログラムを保証する規律を保持しています。
  この仕事は単なる理論的な運動ではないという証拠があります。ここで議論する多相型規律は、 LCF メタ言語 ML に組み込まれており、 2 年近く使用されています。
  この言語用のコンパイル時型チェッカーは、かなりの割合のプログラミングエラーをトラップする貴重なフィルタであることが証明されています。

  本論文の主要な部分は、シンプルな説明的言語の文脈における、型の規律に関する技術的な説明(意味論的および構文的な両方)に関係しているが、この時点では、非形式的にアプローチを特徴付けることが有用です。
  その主な特徴を概説します。

  まず、型に関するすべてがコンパイル時に行われます。型・チェッカー(コンパイラの一部)がプログラムまたはプログラム・フレーズを受け入れると、実行時にオブジェクトがその型を持たないことを前提としたコードが生成されます。
  これは、効率的なオブジェクトコードを生むものとして広く受け入れられていますが、 EL1 のアプローチと比較して型の使用に制約を課します [21]。

  第二に、多くの重要でないプログラムは、文脈から推論されるので、型の言及を完全に避けることができます。
  (ただし、 ML では、他の言語と同様に、ユーザーは実際には、これらの型の操作と一緒に自分の型を定義する必要があります。
  このようにユーザが自分の型を定義できるようにする最近の言語は、 CLU [8]、 ALPHARD [23]、 Euclid [6] です。
  プロシージャの正式なパラメータを含む宣言された変数の型指定を要求することは、より分かりやすい問題につながることを納得して論じることができますが、これらの仕様を省略できるようにすることは、特にオンラインプログラミングにおいても便利です。
  いずれにせよ、我々が提示する型チェッカーは非常に単純であり、たとえ変数の型が宣言で常に指定されていても、はるかに簡単にすることはできません。

  第三に、多相型が主要な役割を果たします。
  たとえば、プロシージャーには多相型 (polytype) (一般に polytype と略します)が割り当てられます。その引数の型および結果が文脈から一意的に決定される場合のみ、それは単相性(すなわち、単相型が割り当てられる)です。
  Gries と Gehani [4] は、 (LISP や SNOBOL の型レスプログラミングとは対照的に)制御された多相型プログラミングの説得力のあるケースを作りました。しかし、また Tennent [20] では、多相型を指定するために型変数や識別子の存在が必要です。
  我々のために、プログラムに存在する多相型は、すべてのプログラミング言語に存在すると思われるプリミティブ多相型演算子の自然な成果です。そのような演算子は、代入、関数適用、ペアリングとタプル、およびリスト処理演算子です。
  これは、主に、これらの演算子の型制約と、変数の宣言と使用で、プログラムのフレーズの型とそのサブフレーズの種類を決定します。

  本書では、最終的に強制的にまたは識別子の`オーバーロード`のどちらかを除いて、このホワイトペーパーでは説明しません。
  我々の見解では、これらの概念やランタイム型の操作は、コンパイル時の多相型の規律とは幾分直交しており、ある程度は無効化せずに組み込むことができます。

  第 2 節では、 ML の断片の例による型の規律を説明します。
  この断片は自明であるべきであるが、 ML の概要は [3] で与えられ、完全な記述は [2] に示されます。
  これらのイラストは、我々が有用な言語を扱うことができるようにするために役立つはずです。
  論文の残りの部分は、非常に簡単な適用言語 Exp を使って規律を正当化します。
  正当化は 2 つの部分に分かれます。

<!-- 350 3/28 -->

  第 3 節では、型定義(正しい型の割り当て)の概念を定義し、型付きプログラムが意味的に型違反がないことを示す意味健全性定理を証明します。
  言語の操作上の定義を与える場合、これは、たとえば、整数が真理値に加算されることも、引数に適用されることもないことを意味し、その結果、実行時検査のためにその型を持ち運ぶ必要はありません。
  第 4 節では、よく型されたアルゴリズム W を提示し、文法健全性定理を証明します。文法健全性定理は、 W が成功すればプログラムの型付けを生成すると述べています。
    W をシミュレートする、より効率的なアルゴリズム I も提供します。

  Exp の型は基本的な型の集合に対する単なる関数型の階層です。
  つまり、 Exp の多相性は、単一のプリミティブ多相型演算子、関数適用、変数バインディングの自然な伸びです。
  ペアリングやリスト処理演算子 (ML のように)のような他の基本多項式演算子を、基本的な `☓` (Cartesian Product)、リスト(リスト生成)、 `+` (分離した合計)は、(関数型)に加えて、 2 つの健全性定理に特別な困難を与えません。
  実際、代入演算子を追加することは、構文健全性定理に関する限り簡単ですが、セマンティック健全性定理は、このケースでは、アサイナブルの現在の値を保持するメモリまたはストアの余分なセマンティックの複雑さのために、拡張するのが難しい変数。
  これについては第 5 章でさらに議論します。

  我々の研究は、彼の論文で Morris [10] が表現した問題を次のように解決するための一歩です:
  プログラマが関数の呼び出しごとに異なる型を持つ関数を定義する言語と型システムを設計することができます。
  この論文の第 4 章では、問題の明確な紹介として推奨しています。
  Morris は形式の意味論について公式には議論していないが、多相型の系を与えているが、一連の連立 1 次方程式を解くことによって、λ-計算の項でどのように有効な型の割り当てが見つかるか説明しています。次のセクションでこの考え方をさらに進めていきます。

  この作業を行った後、我々は、結合論理の項のための "主要型スキーム" (これを多相型と呼ぶ)を導出する Hindley の方法 [5] を知るようになりました。
  Hindley は、 Robinson の単一化アルゴリズム [14] がこの問題に適切であることに気づく最初の者であるように思われます。
  我々の仕事は、 Hindley の方法をローカル宣言を使ってプログラミング言語に拡張し、そのメソッドの意味論的正当性とみなすことができます。

  要約すると、命令型の機能を持つ現在使用されているプログラミング言語に対して構文的によく理解され、正当化されている多相型の規律を提示します。また、重要ではないが非必須のサブ言語についても意味論的に説明されます。

## 2. 型の規律の図

  多相性の概念を簡単な例を使って説明します。
  それらは ML の断片で書かれていますが、これはわかりやすいものです。この断片は実際には Landins ISWIM [7] にすぎず、読者は Burge の本 [1] に言及して、このプログラミングのスタイルをほぼ正確に使用しています。

<!-- 351 4/28 -->

  ここでは必須の構成要素を使用しません(割り当てやジャンプ)。
  コンストラクト

    let x = e in e’,
    let f (x1, ..., xn) = e in e ’

    `e` の値に  `x` を与え、   `e` には抽象度 `λ(x1, ..., xn) .e` の値を与えるために使用されます。
  再帰関数では let の代わりに letrec が使われ、 `e` の部分が省略されたときには宣言があります。

    ML の完全に決定された型(すなわち単項式)は、バイナリの中置演算子 `☓`(デカルト積)、`+` (分離された sum) と `➙` (関数型)と単項の後置演算子リストです。
  多相型(ポリ型)は、型変数を受け入れることによって得られます。
    `α` 、 `β` 、 `γ` ···。
  任意の型を `ρ`、 `σ`、 `τ` で表す。
  このセクションでは、型の意味を読者の直感に任せます。それは次のセクションで正確にされています。

  例 1. リスト上の関数のマッピング。

    letrec map (f, m) = if null (m) then nil
                       else cons (f (hd (m) ), map (f, tl (m) )).

  直感的には、このように宣言された関数マップは、あるソートのものから別のソートのものへの関数と、第 1 ソートのもののリストを取り、第 2 ソートのリストを生成します。そこで、マップには型があります

    ((α ➙ β) ☓ α list) + β list,

  ここで、 `α`、 `β` は型変数です。

  この型はマップの裸宣言からどのように決定されますか？
  まず、宣言で自由に出現する識別子のジェネリック型(後で "ジェネリック" と呼ぶ)は、

    null : α list ➙ bool,
     nil : α list,
      hd : α list ➙ α,
      tl : α list ➙ a list,
    cons : (α ☓ α list) ➙ α list,

  つまり、それらの型には 1 つ以上の型変数が含まれており、その規則は次のとおりです。このような識別子が出現するたびに、その型の代入インスタンス(型変数の型を代入する)である型が割り当てられます。

  これらの識別子はそれぞれ宣言の中で一度だけ出現するので、識別子 `id` に割り当てられた型を `σid` で表す場合、いくつかの型 `τ1,..., τ5` に対して、

    σnull = τ1 list ➙ bool,
    σnil = τ2 list,
      σhd = τ3 list ➙ τ3
      σtl = τ4 list ➙ τ4 list,
    σcons = (τ5 ☓ τ5 list) ➙ τ5 list.

<!-- 352 5/28 -->

  他の識別子 (`map`、 `f`、 `m`) はそれぞれ 2 回以上現れます。我々の規則では、それぞれのオカレンスに同じ型が割り当てられることを要求しています。規則はまた、いくつかの型 `ρ 1、 ρ 2、...`に対して以下の式が満たされることを要求します。

    σmap = σf ☓ σm ➙ ρ1,
    σnull = σm ➙ bool,
      σhd = σm ➙ ρ2,
      σtl = σm ➙ ρ3,
      σf = ρ2 ➙ ρ4,
    σmap = σf ☓ ρ3 ➙ ρ5,
    σcons = ρ4 ☓ ρ5 ➙ ρ6
      ρ1 = ρnil = ρ6.

  これらの条件の 1 つ目は、関数の型をその仮パラメータの型に関連付けることです。
  条件付き式がその 2 つの腕と同じ型を持ち、宣言の確定数と定義数が同じ型であるため、最後のものを除いて、関数適用であるいくつかの下位句から発生します。

  これらの方程式は、変数 `ρ i`、 `τ i`、および `σ id` に対して解くことができます。
    Morris [10] は、このような方程式の解を論じています。
  事実、 Robinson [14] の単一化アルゴリズムの使用には完全に適切です。我々の型タイピングアルゴリズムはこのアルゴリズムに基づいており(この場合、単一化以上のものは必要ないので)、最も一般的な型のマップが得られたと Robinson の研究から結論づけることができます。すなわち、方程式取得した型の置換インスタンスでなければなりません。
  実際、上記の方程式の解は

    σmap = (γ ➙ δ) ☓ γ list ➙ δ list,

  ここで、 `γ`、 `δ` は任意の異なる型変数です。
  だから、これは `map` のジェネリック型です。つまり、この宣言のスコープ内のマップの出現には、この型のいくつかの置換インスタンスを割り当てる必要があります。

  これらのインスタンスは同じである必要はありません。
    `tok` は基本型(トークンが文字列である)であり、識別子(型を持つ)が利用可能であると仮定します。

  そして

      tokl : tok list (a variable) ,
    length : tok ➙ int,
    sqroot : int + real, two obvious functions.

  次に、式の

    map (sqroot, map (length, tokl) )

  で、 `map` の 2 つのオカレンスには型があります

    ((tok ➙ int) ☓ tok list) ➙ int list,
    ((id ➙ real) ☓ int list) ➙ real list.

<!-- 353 6/28 -->

同様に、 `null` の場合、たとえば `map` の定義で 2 回発生した場合、その型は

    α list ➙ bool

  我々の規則では、仮パラメータ(たとえば f) や識別子(マップ)の再帰的定義の異なる出現が同じ型を持つことを要求しています。

  上に述べたマップの出現は、別々に宣言された 2 つのマップ関数の使用と見なすことができることに注意してください。
    Gries と Gehani が述べているように、コンパイラは、これらの明確な宣言を生成するタスクを与えることができます(プログラマが複製を見る必要はなく、意識する必要もないため)。異なる型で使用するマップ関数。
  効率のために、トークンリストが整数リストとは異なって実装されている(そして原始的な多相関数 `hd`、 `tl` 等が相応に異なっている)場合は、上記の例では本当に必要になります。
  我々は、これらのマップ関数がすべて意味論的に同じオブジェクトであるとみなされる概念的なフレームワークに関心を持っています。実装者は望むように少数または多くの変種として実装する自由が残されます。

  この例から明らかなように、タイピングのルールは慎重に設定する必要があります。
    let または letrec をローカルで使用するときに何が起こるかを説明するもう 1 つの例を見てみましょう。

  例 2 タグ付け。 tagpair` (a) ` が関数であるような関数 tagpair が必要であるとします。

    (b, c) |➙ ((a, b) , (a, c) ).

  もちろん、我々は簡単に書くことができます

    let tagpair = λ(b, c) . ((a, b) , (a, c) ).

  ここで、方程式を設定することなく、型定義アルゴリズムがこの宣言にどのように取り組んでいるかを説明することができます。
  まず、 `a`、 `b`、および `c` に " 未知" の型(すなわち、型変数) `α`、 `β`、および `γ` を割り当てます。
  次に、 `((a, b), (a, c))` は ` (α ☓ β) ☓ (α ☓ γ) `、λ式は `β ☓ γ ➙ (α ☓ γ) ☓ (α ☓ γ) ` と型付けされます;ついにタグペアアイア

    α ➙ (β ☓ γ ➙ (α ☓ β) ☓ (α ☓ γ) )     (*)

  (型方程式は `a`、 `b`、 `c` の型に制約を課していません)。

  しかし、(埋め込まれた)関数を使用して、タグペアを定義する別の方法を検討してください

    #: (α ➙ β) ☓ (γ ➙ δ) ➙ ((α ☓ γ) ➙ (β ☓ δ) )

  ` (f # g) (a, c) = (f (a), g (c))` とペアリング関数

    pair : α ➙ (β ➙ (α ☓ β) )

<!-- 354 7/28 -->

    `pair (a) (b) = (a, b) ` となるようにします。
  我々は書くことができる

    let tagpair write = λa. (let tag = pair (a) in tag # tag)

  次に、 well - typing アルゴリズムが次のように進むことが期待されるかもしれません。
  まず、 `α` に `a` を代入します。
  次に、ジェネリック型の `pair` を使用して、 `pair (a) ` は `δ ➙ α ☓ δ` を取得します。
  これをローカルのジェネリック型のタグとして使用し、 `tag # tag` の `tag` の 2 つの出現にはそれぞれ `β ➙ α1 ☓ β`、 `γ ➙ α2 ☓ γ` を割り当てます。
  `#` の出現にはジェネリック型のインスタンスが割り当てられます(新しい型変数を使います)。そして、関数適用の型方程式は型

    β ☓ γ ➙ (α1 ☓ β) ☓ (α2 ☓ γ)

  タグ `#` タグとλ式の本体に代入され、タグペアがその型を取得する

    α ➙ (β ☓ γ ➙ (α1 ☓ β) ☓ (α2 ☓ γ) ).  (**)

  `(*)` と `(**)` を比較すると、何かが間違っていました。 2 番目の型はあまりにも一般的です。
  問題は、タグおよびその一般的な型がλバウンド変数 a およびその型 `α` に依存し、λバウンド変数の異なるバウンド出現が異なる型を持つことを許さないことです。
  実際、型に関する限り、 tagpair が 3 番目の方法で定義されているのと同じようになるはずです。

    let tagpair = λa. (pair (a) # pair (a) )

  読者は、(実施例 1 のようないくつかの方程式を設定することによって)
  この場合、期待される型は `(*)` です。

  解決策は幸運にも簡単です。
    let または letrec によってバインドされた変数の型をインスタンス化する際に、それを宣言します。
  包括的なλ結合(または仮パラメータ束縛)の型には存在しない型変数だけがインスタンス化されるかもしれません。
  このようなインスタンス化可能な変数(ジェネリック型)はジェネリック型変数と呼ばれます。

  今度は tagpair の 2 番目の定義では、ローカルに定義されたタグがジェネリック型 `δ ➙ α ☓ δ` を取得しました。ここで `δ` は一般的ですが `α` は一般的ではありません。
  したがって、タグは、タグの出現に型を割り当てる際にインスタンス化されていてはならず、 `(**)` は `(*)` と同一であったはずです。
  この例は少し工夫されているように見えるかもしれません。確かに、我々の経験は、ほとんどの場合、ジェネリック型の型変数のすべてが一般的なものか、まったく共通なものではありませんでした。
  しかし、例外を排除する簡単な構文上の制約はなく、そうすることも望ましいとは思われません。

これらの例から、それぞれ let (または letrec) とλによってバインドされた変数を入力するためのルールが異なることが明らかになります。
  したがって、 2 つの式に対する我々の意味論

    let x = e in e ’; (λx. e ’) e

  (そして等価であるかもしれませんが)前者に正しく型を割り当てることは可能かもしれませんが、後者には正しく型を割り当てることはできません。
  例はペアです

    let I = λx. x in I (I) ;    (λI. I (l) )(λx. x) .

<!-- 355 8/28 -->

  これに対する部分的な直観は、λ抽象化が引数なしでしばしば起こることがあることです。上記の 2 番目の式は明示的な引数-` (λx. x) `-が存在するという点で、抽象化の特別な(むしろ不要な)使用を含んでいます。
    let 構文は(変換されると)抽象化のこの制限された使用を伴うので、型割り当ての規則がそれほど制約されないことは不自然ではません。
  コンパイラはもちろん、 ` (λx. e’) e` のすべての明示的な出現をあまり制約のない方法で扱うことができます。

  λ-バインディング(すなわち、仮パラメータバインディング)とバインディングとの間の相互作用における型の処理は、実際に我々のアプローチの中核です。
  これは、無関係の変数として囲む手続きの仮パラメータを含むかもしれない手続きの非グローバル宣言の一貫した扱いを提供します。
  これは多相性の重大な困難の 1 つと思われるため、難易度に無関係な可能な限り除外する簡単な言語 (Exp) の観点から分析を提示することが正当だと考えています。

  読者は、我々のルールが任意に選択され、直感によって部分的にしかサポートされていないと感じるかもしれません。
  ルールが唯一のものであるとは確かには言いませんが、後で与えられる結果は意味的に正当化されていることを示しています。
  実際には、正しい型の割り当てを認めるプログラムは、型エラーのために実行時に失敗しないか、より正確には、そのセマンティクスでコード化された型制約が常に満たされることを示します。
  このことから、コンパイル時の型検査(すなわち、正しい型割当てを発見しようと試みる)は実行時に型を持たせる必要がなくなり、実装の効率が明らかに向上します。

  これはもちろん、コンパイル時型検査の主な目的です。もう 1 つは、プログラミングエラーの早期検出です(その多くが不正プログラムの原因となります)。
  我々の業績は、多相型を含むように型検査を拡張することです。
  さらに、最終的な形式(第 3 節のアルゴリズム 1) の型検査アルゴリズムは、構文型健全性定理の証明が正しいとしても正しい型割り当てを生成することはかなり面倒であると述べているが、非常に単純です。

  我々は、システムでうまく入力できるプログラムのクラスの独立した特徴付けをしたいと思いますが、これを行う方法はわかりません。
  しかし、我々はいくつかの指針を与えることができます。
  レフリーの提案では、 Burge [l、 Chapt。 3] データ構造を処理するための一般的な機能に関します。
  そこにあるすべての関数(我々が調べなかった 3. 11 節を除く)は、 2 つの点で修正された ML 型チェッカから期待される型を取得しました。
  第 1 に、 Burge は、不連続和型とその被加数型の間の強制関数を暗黙のうちに残します。これらを明確にする必要がありました(この点は序文で言及されています)。
  次に、 Burge によって使用される再帰型定義を定式化するために、 ML 抽象型構文(例として第 5 章を参照)を使用しました。
  この構文では、定義された抽象型とその表現の間の同型写像は明示的に行われ、明示的に使用されなければなりません。
  この要件の必要性を見るために、αストリームの場合を考えてみましょう。これは、αとαストリームからなるペアを生成する関数であると定義されています。
  型方程式

    α-stream = - - - ➙ (α ☓ α-stream)

  (無限型表現を許さない限り)単一化によって解決することはできません。

<!-- 356 9/28 -->

  しかし、方程式を同型写像として扱い、 2 つの関数を使って抽象型とその表現の間で前後に変換することで、この困難は取り除かれます。
  我々は、この解決策が抽象的な型の概念に従っていると主張している(例えば [8] 参照)。

  否定的な側面では、間違いなく型することができない便利な表現がありますが、それらがなければどれほど煩わしいのかははっきりしていません。
  明白な例は、カレーの `Y` コンビネータです。

    Y = λf. (λx. f (x (x) ))(λx. f (x (x) ))

  自己申告は我々のために型されていないからです。
  しかし letrec は `Y` の必要性を避けています。
  より具体的には、

    let F (f) = λ(a, b) . (f (a) ,f (b) )

  議論の対象となるかもしれない - 異なる型の a と b で動作するのに十分な多相型である関数を引数として受け入れるべきです。
  例えば、

    F (reverse) (x, y)

    `x` と `y` が異なる型のリストである場合、異なる型の逆のリストのペアを生成します。
  我々のシステムでは、このような `F` の使用を拒否します (a と b には同じ型が必要です)。しかし、

    let reversepair = λ(x, y) . (reverse (x) , reverse (y) )

  または `F` の関数引数の他の特殊化を含みます。

  この例ではシステムの主な制限が示されていますが、明示的な型パラメータを使用せずに可能な限り柔軟に対応している可能性があります。
  これらが導入されると、型の型の問題が発生します。レイノルズ [12] は
  この問題を解決するためにいくつかの進歩を遂げましたが、回避しながらどれだけ多くのことができるのかが目に見えていました。

## 簡単なアプリケーション言語とその型

## 3. 1. 言語拡張

   x を識別子の上に置きます。

     x ∈ Id

   次に、式言語 Exp は次の文法によって生成されます。

     e :: = x | (e e ') | もしe ならe 'else e "|
           λx. e | x. e を修正する| e 'のx = e とします。

  ここで ` (e e') ` はアプリケーションを意味し、 `fix x. e` は最小固定点λ `x` を表す。最後の節は `e` の間に `e` の値に `x` を束縛します。
    `d` 、 `e` 、 `f` を素数と接尾辞で `Exp` の範囲で使用することがよくあります。
  定数は省略されています。初期の環境では、特定の識別子のための標準的なバインディングを想像することができます。

<！ - 357 10/28 - >

  実行時の失敗の検出に対応する値`間違い`を含む `Exp` の通常の意味論的セマンティクスを与える。
  この小さな言語では、唯一の失敗は、条件の条件としてのブール値ではない値の出現と、アプリケーションの演算子としての機能しない値の出現です。

  我々のセマンティックドメインは完全な部分的順序 (cpos) とみなされてもよい。 (a) 最小要素 `⊥D` が存在し、 (b) `D` のすべての有向サブセットが、 `D` 内で最小の上限を有するような、部分的に順序付けられた集合です。
  与えられたように基本ドメインのセット `{ Bi }` を取り、 3 つの要素の真理値ドメインである `B0 = T` を取ります

    true false
       \     /
         ⊥T

  再帰的に以下を定義します

    V = B0 + B1 +. .. + F + W (disjoint sum of domains, with
                                  ⊥V adjoined as minimum element) ,
    F = V ➙ V (continuous functions from V to V) ,
    W = {・}                      (error) .

  このような一連のドメイン方程式の解(同型まで)は、 Scott [15] によって保証されています。
  彼は完全な格子で作業しましたが、解は cpos にも存在します (Plotkin [11] を参照)。

  セマンティック関数は、環境の領域である `Env = Id➙V` で、 `ε∈ Exp➙Env➙V` です。
  `η` を使って `Env` を範囲指定します。
  `ε` を定義する際には、後で、 Scott と Strachey [16] のよく知られた表記法を使用します(この例では `D` は `V` のいくつかの要約):

    (i) `d ∈ D` の場合、 `V` の `d` は、 `V` の `D` の注入の下での `d` の画像です。

    (ii) `v ∈ V` ならば、

      v ⁅ D == true if v = d in V for some d ∈ D,
            == ⊥T if v = ⊥V,
            == false otherwise.

    (iii) `v ∈ V` ならば

      v | D == d if v = d in V, for some d ∈ D,
            == ⊥D otherwise.

<!-- 358 11/28 -->

  環境 'η' =η{v / x} `は`η '（x）= v`を除いて `η`と同じです。
  `V（・∈W）`の値 `・`は「間違っている」と書かれています。
  条件付き関数 `COND∈T➙V➙V➙V 'は` t➙v➙V'と書かれています。

    v if t == true,
    v '    if t == false,
    ⊥V if t == ⊥T.

## 3.2. Expのセマンティック方程式

   これらの方程式では、 `[| |]` は構文的な引数を示します。


    ε[|x|]η = η[|x|]
    ε[|e1 e2|]η = v1 ⁅ F ➙ (v2 ⁅ W ➙ wrong, (v1 | F)v2),
                     wrong
                  where vi is ε[|ei|]η            (i = 1,2).
    ε[|if e1 then e2 else e3|]η = v1 ⁅ B0 ➙ (v1 | B0 ➙ v2, v3), wrong
                          where vi is ε[|ei|]η    (i = 1,2,3)
    ε[|λx.e|]η = (λv・ε[|e|]η {v/x}) in V
    ε[|fix x.e|]η = Y(λv.ε[|e|]η{v/x})
    ε[|let x = e1 in e2|]η = v1 ⁅ W ➙ wrong, ε[|e2|]η{v1/x}
                         where v1 = ε[|e1|]η.

  ノート。 （i）「Y」は最小の固定小数点演算です。
  多くの言語では、 `fix f・e` の `e` は抽象化 `λy . e’` に制限されます。

    let f = fix f . (λy . e’)

  は以下の構文を受け取るかもしれません

    let rec f(y) = e’

  （ii） `e2` の `let x = e1`は `ε`と同じ意味を持ち、 `（λx* e2）e1` である。
  しかし、私たちの目標の一部は、最初の形式で特定の式を認めるとともに、2番目の形式への変換を拒否するタイプの規律です。 これは、λ抽象化は一般に明示的なオペランドなしで発生する可能性があり、より注意深い処理が必要なためです。

  （iii） `（e1 e2）` の意味は、 `e2` の意味が `e2` は `⊥V` です。
  このテストの省略は、名前による呼び出しのセマンティクスを提供する（同様のテストはlet構文のセマンティクスでは省略することができる）。この場合、セマンティック健全性定理は等しくなる。

<!-- 359 12/28 -->

## 3.3. タイプの議論

  ここで概要を説明します。
  型と呼ばれる新しいクラスの式を定義します。タイプを持つ値が意味するものを言う。
  いくつかの値は多くの型を持ち、ある型は全く型を持たない。
  実際、「間違っている」にはタイプがありません。
  しかし、機能的な値が型を持っていれば、適切な型（型）の引数に適用されている限り、結果の正しい種類（型）を生成します。これは "間違っていてはいけません"！

  ここでは、大まかに言えば、Exp式は（適切な環境で）型を持つ値を評価し、間違っていないことを示すことができます。
  事実、表現がこの堅牢な品質を持つという十分な構文条件を与えることができます。条件は、式が環境に関して「適切な型付け」を持つということだけです。つまり、ある種の法則を満たす方法で、その型とそのすべての部分式に型を割り当てることができます。

  したがって、タイプ割り当ての法則が与えられると、主に2つのタスクがあります。
  最初に、法的型割り当てを持つ式（またはプログラム）が「間違っていない」ことができないことを示すことは、このセクションで取り組まれています。驚くべきことに、少なくともアプリケーション言語の場合は、より簡単な作業です。
  第2の課題は、タイプ情報が不完全なプログラムが与えられた場合、法的なタイプ割り当てをディスクールすることです。
  このタスクは、しばしば型チェックと呼ばれます。もちろん、この用語は、指定された型の割り当てが合法であることを検証することだけを意味することもできます。実用的な状況では、プログラマがすべての部分式に型を付けることを期待できないので、おそらく両者の間に何かが必要です。
  セクション4では、与えられたプログラムのクラス型（クラスは無限大ですが、多態性を認めます）を見て、成功すれば正しい型の割り当てを行うアルゴリズムを与えます。
  後者が存在する場合、アルゴリズムは、他の法的型の代入が代入の型（型変数の型を代入すること）であるという意味で、最も一般的なものを見つけ出すと推測します。

## 3.4. 型とその意味

  型の構文は次のとおりです。

  （1） `ι0`、`ι1`、...は（基本）型です。 `Bi` ごとに1つ。

  （2）タイプ変数である、無数のセットがあります。
  我々は、型変数の範囲を決めるために `α`、`β`、`γ`、...などを使います。

  （3） `ρ` と `σ` が型であれば `p➙σ` も同様です。

  モノタイプは、型変数を含まない型です。
   私たちは単項式の範囲を決めるのに `μ`、`ν`、 `π`、...を使います。
   ある型に変数が含まれている、あるいは含まれていることを暗示したいときは、polytypeという単語を使用します。

   私たちは最初にモノタイプのセマンティクスを与えます。 つまり、我々は
   値v∈Vはモノタイプ「μ」を有し、これは「v：μ」と書く。

  （i）「v =⊥V」または「v≠Bi」の場合、「v：ιi」

  「u：μ」の場合は、「v =⊥V」または「v⁅F」および「（v | F）u：ν」の場合、「v：μ➙ν」を選択する。

<!-- 360 13/28 -->

多くの値に型がないことは明らかです。
   例は次のとおりです

     間違っている、（V、V、V、間違っている）
     （v | B0、VでV、BでV、yでV）、Vで
       （ここで、x∈B1、y∈B2など）。

   しかし、最後の例で `y∈B1`ならば、関数は`ι0➙ι1`という型を持ちます（他にはありません）。

   いくつかの値には多くの型があります。 アイデンティティ関数

     （λv∈V、v）をV

   たとえば、μごとに「μ➙μ」というタイプがあります。
   もちろん、「⊥V」にはあらゆるタイプがあります（すべてのタイプを持つ唯一の値です）。

このタイプの概念は、Scott [17]に由来します。
   実際、スコットが機能性をカレーの後に呼んでいるのは、それが退去という概念とは異なるものです。
   一時的に値を持つ型の値を持つ型を識別すると、その型が下向きに閉じられ、指示されたことが完全であることを示すことは容易です

  (i) `∀v, v’ ∈ V. (v : μ and v’ ⊑ v) ⇒ v’ : μ`、

  (ii) `V` の各有向部分集合 `X` に対して、`(∀v ∈ X . v : μ) ⇒ ∐ X : μ`。

後退は2番目のプロパティを共有しますが、最初のプロパティは共有しません。
   最近、ShamirとWadge [18]は、これらの2つの特性を持つ任意の集合を型として定義し、 'v'型で値 'v'を特定した結果を調べる。 v '⊑v} `。

   ポリタイプのセマンティクスは次のとおりです。
   まず、 `ρ⩽σ`を使って、型変数に型を代入することによって`σ`からρを得ることができることを意味します（ `⩽`は明らかに反射的で推移的です）。
   例えば、

     μ➙➙α➙α➙β➙

   だけど

     α➙β/⩽β➙β（α=βの場合を除く）。

   次に、

     v：σiff∀μ⩽σ.v：μ。

   例えば、

     （λv。v）をV：α➙αとする。

それによって、ポリタイプも「V」のサブセットを表し、これらもまた完全に向けられている。
   読者は、最も外側に普遍的に定量化されているように、ポリタイプの各型変数を考えることができる。 例えば、

     α➙α "は"Vα.α➙α "を意味し、

   結合されたαは単一型に及ぶ。
   実際、これは、ここでは「α」は単項型（すべての型ではない）と、式のような式を認めないからです

     （∀α.α➙α）➙（αα.αα）


   結合型変数が単型以上の範囲にあるとすれば、それらが型のより豊かな概念の中でReynolds [12]の困難（また興味のあるもの）を避けることを意味することがわかります。

<!-- 361 14/28 -->

   私たちの定義からすぐにわかる、以下の単純なプロパティが必要です。

  命題1.「v：σ」と「τ⩽σ」の場合、「v：τ」。

  命題2.「v：σ➙τ」と「v：σ」の場合、 `（v | F）v '：τ`。

  いずれの場合も、モノタイプの特性はポリタイプに持ち上げられる。

## 3.5。 タイプ割り当て

  よくタイプされた式が「間違っていない」という定理の根拠を準備するためには、式をタイプすることによって何を意味するのかを定義する必要があります。
  式の自由変数に型を与える型環境の概念がまず必要です。

  接頭辞 `p` は、メンバーが `let x`、` fix x`、または `λx`の形式を持つ有限のシーケンスです。ここで` x`は変数です。
   接頭辞付きの式 `（pe）`の形式は `p`です。 `e`にあり、` e`で空いているすべての変数は `p`のメンバにあります。
   接頭辞のメンバーをピリオド`（.）`で区切ります。

   すべての`pe`は、次のように sub-`pe` を与えます。
   推移的反射的閉包と一緒に：

    （i）p | xはそれ自身を除いてsub-peを持たず、
    （ii）p | （e e '）にはsub-peのp |があります。 eとp | e '、
    （iii）p | （もしeならe 'else e "）はsub-peのp | e、p | e 'とp | e "、
    （iv）p | （λx・e）はsub-pe pを有する。 λx| e、
    （v）P | （fix x。e）にはsub-pe pがあります。 xを修正する| e、
    （vi）p | （e 'のx = eとする）は、sub-peのp | eおよびp。 x | e '。

  たとえば、λy| （fy）にf =λx（xy）を代入する）にsub-peを（それ自体のほかに）

    λy | λx . (xy),      λy . λx | (xy),   λy . λx | x,      λy . λx | y,
    λy . let f | (fy),   λy . let f | f,   λy . let f | y

  sub-peは、それを囲むすべての変数バインディングの接頭辞の部分式に過ぎません。
   上記のλx。（x、v）はlet fで囲まれていないことに注意してください。このバインディングの範囲にはありません。

  メンバーは、pの右側にxが出現しない場合、pのxまたはλxを固定したメンバーがp内でアクティブであると言う。

  今、pe pのタイプ入力| eは、pの各要素への型の割当てであり、各部分式と各λx、fix x、またはeをxとし、部分式（eのx = e 'とする）には同じ型 xとe 'を代入するように割り当てられます。
  このように、図示されたpeの1つの型付け（それは、後に定義される意味では、ほとんど、しかしかなりではないが、よくタイプする）は以下の通りである。


    λy_α | let f_((α➙β)➙β) = (λx_(α➙β) (x_(α➙β) y_α)_β)_((α➙β)➙β) in (f_((α➙γ)➙γ)y_α)_γ)_γ .

  私たちは、p | e by p〜| e〜、またはp〜| eσ〜e自身に割り当てられた型σを示したいとき。

<!-- 362 15/28 -->

  任意のp〜| e〜、および任意の束縛は、p〜またはe〜のいずれかにxσを入れ、任意の囲みλyτまたはfixyτに出現しないσの型変数であり、束縛は束縛letxσ 。
  上記の例では、βは一般的なものですが、αは束縛のためにはありません。（ααββ）➙β）。
  直感的に、バインディングletxσのジェネリック型変数は、xを使用できる型の自由度を表します。 それらはxの局所多型を表す。
  λまたは拘束の束縛がletxσを囲んでいない場合、σのすべての型変数は総称であることに注意してください。
  σの大域的インスタンスは、一般的な型変数のみがインスタンス化されるσのインスタンスです。

  技術的な理由から、一般的な型変数が制御された方法で発生することが必要です。
  p〜|と言う。 d〜はすべての型付きサブペアに対して標準です。p '〜| 各メンバーのジェネリック型変数は、p '〜のxσをp'〜|にはどこにも置かないようにします。 d '〜。
  したがって、特に、eσ '〜の中のxρ=eρ〜が部分的なd - の型である場合、ρの一般的な型変数はeσ'〜には出現しないかもしれません（もちろんeρ〜でなければなりません） 。

  ここで、well-typed（wt）peの概念を次のように定義します。

  （i）p〜| xτは、標準であればwtであり、
       （a）λxτ、またはfixxτがp〜でアクティブである、または
       （b）xσはp〜で有効であり、τはσの一般的な例であるとする。
     （ii）p〜| （eρ〜eσ '〜）_τはwtfである。 e〜とp〜| e '〜はwtであり、ρ=σ➙τである。
     （iii）p〜| （eρ〜theneρ '〜elseeρ' '）_τ'は、 e〜、p〜| e '〜p | e "〜は全てwt、ρ=ι0、σ=τ=τ 'である。
     （iv）p〜| （λxρ、ρρ）_τはwtfである。 e〜はwtであり、τ=ρ➙σである。
     （v）p〜| （fixxρeρ〜）_τは、次のようになります。 e〜はwtであり、ρ=σ=τである。
     （vi）p〜| （xρ=eρ〜eσ '〜）_τはwtfである。 e〜とp〜。 xρ| e '〜は両方ともwtであり、σ=τである。

この再帰的な定義はいくつかの証明には有用ですが、wtの別の特徴付けが有用な場合もあります。
   次の命題の証明はかなり簡単です。それを省略します。
   wt p〜| 簡単な構造誘導によって、必然的に標準である。

   提案3.p〜| d〜aは、以下の条件が満たされる場合には、wtである。

   （A）標準です。

   （B）すべての（バウンド）オカレンスxσについて、対応するバインディング発生は、λxσ、OY fixxσ、またはletxσのいずれかであり、σはτの一般的なインスタンスである。

   （C）次の条件は、d〜のすべての部分式（誘導型入力）

      (eρ~ eσ'~)_τ                       ρ = a ➙ τ,
      (if eρ~ then eσ'~ else eτ"~)_τ'    ρ = τ0 and σ = τ = τ’,
      (λxρ . eσ~)_τ                      τ = ρ ➙ σ,
      (fix xρ . eσ~)_τ                   ρ = σ = τ,
      (let xρ = eρ~ in eσ'~)_τ           σ = τ. 

<!-- 363 16/28 -->
 
  したがって、上に示したタイピングは、1つの理由だけでは重くはなりません。
  部分表現 `（f_（（α➙γ）➙γ）_γ`は、命題3の条件（C）の最初に違反します。
  別の例を考えてみましょう。
  以下は（p〜空で）よくタイプされたものです：

    let I_(α➙α) = (λxα.xα)_(α➙α) in
      (I_((ι➙ι)➙(ι➙ι)) I_(ι➙ι))_(ι➙ι) .

  αは、Iの宣言のタイプα➙αにおいて一般的であるため、Iの結合された出現のタイプにおいてインスタンス化される（おそらく異なってもよい）ことに留意されたい。

  letによって宣言された変数に対して、generic型変数のみをインスタンス化する必要性を説明するために、λxα.xβでは、命題3の条件（B）によってα=βを持たなければならないことに注意してください。
  確かに、我々は以下のようにこれを直感的に議論することができます：

    let I = λx . x in ...,

  この宣言の範囲内にある式（Ie）のすべてが、部分式eと同じ型を受け取るようにしたいと考えています。
  しかし、今では（割り当てられた型で）

    let I_(α➙β) = (λxα . (let yα = xα in yβ)_β)_(α➙β) in ...

  それは意味的にはより単純な宣言と同等であるから、α=βを再び要求しなければならない。
  しかし、このことは、型定義の定義に課されています。なぜなら、αは束縛yαの一般的なものではないから、yの束縛された出現ではインスタンス化されない可能性があるからです。

## 3.6. 置換

   置換 'S'は型変数から型へのマップです。
   Sは、型から型、型付き型から型付き型などにマップを生成する自然な方法で拡張することができます。
  Sは、Sα≠αの場合には変数αを、β≠α、α∈Sβの場合には型変数αを含むと言う。
  （α∈τはτにαが生じることを意味する）
  この論文の後半では、置換を広範囲に必要としていますが、現在のところ、置換とwtに関連するプロパティは1つだけ必要です。

  命題 4.
  Sがwt p〜|の一般的な変数を含まない場合、 d - とすると、S（p - | d - ）もwtである。

  証明。
  まず、Sの仮定は、S（p〜| d〜）の各束縛に対する一般的な変数がp〜| d〜。
  βが一般的でない場合、Sβは一般変数を含まないので、S（p〜| d〜）は標準である。

  第2に、xσがλxσに束縛されている場合、またはxσをp_ | d〜であれば、xsσはλxsσに束縛されるか、またはS（p〜| d〜）にxsσを固定する。
  xσがletxτであり、σ= [ρ1/α1、...、αn/αn]_τである場合、αiはτの総称変数であり、S（p - | d - ）ではxsσはlet xsτであり、Sσ= [Sρ1/α1、...、Sρn/αn]（Sτ）はSτの一般的な例である。

<!-- 364 17/28 -->

## 3.7. よく型付けされた式は間違っていない

  まず、セマンティック環境ηとタイプ環境の間に単純な関係が必要です。
  私達は言う

    ηは、p〜、η[| x |]：ρにおいて、xρ、λxρ、またはfixxρが活性化されるときは常にp〜iffを尊重する。

  THEOREM 1（意味的健全性）。 ηがp〜とp〜|を尊重すれば、 τ[| d |]η：τである。

  証明。かなり単純な構造誘導。 6つの場合をdτ〜とする。

    （i）xτ。
    次に、λxτまたはfixxτのいずれかがp〜でアクティブであり、η[| x |]：τ、したがってε[| x |]η：τ、またはxσがp〜 σ;しかし、命題Iによると、ε[| x |]η=η[| x |]：τである。

    （ii） `（e_（σ➙ττ）eσ〜）_τ`となる。
     次にp〜| ε[| x |]η：σ➙τであり、同様にε[| e '|]η：σである。
    次に意味論的方程式（間違った型がないことを覚えている）から命題2によって、ε[| d |]η：τを得る。

    （ⅲ）（e0 0〜eσ '〜elseeσ」〜）。ここで必要とされる唯一の詳細は、⊥Vがあらゆるタイプを持つということです。

    （iv）（λxρ・eσ〜）_（ρ・σ・σ）である。それからp〜。 λxρ| eσは、wtである。ここで、V（ν[ε|] |η
 ：ρ➙σ
    命題2の逆は成り立ちません。すなわち、Vをρ➙σで表すと、v：ρ、fv：σが成り立つときは必ずしも必要ではありません。
    必要なのは、η➙➙ρ➙σσごとに、V：μ➙νにあることです。


μ➙⩽ρ➙σをμと仮定します。次に、μ➙ν= S（ρ➙σ）のようなρとσの型変数のみを含む置換Sがある。
  そして、これらの型変数のどれもがp〜・λxρ| eσ〜とすると、S（p〜）・λxμ| S（e〜）_ν "は命題4によって重み付けされる。
  また、ηは、S（p〜）を尊重する（η[| x |]：σ '、τ'⩽σ '、η[| x |]：τ' {v / x}はS（p〜）を考慮する。 λxμ。

  次に、ε[| e |]η{v / x}：νとなるので、v：μはfv：νを意味することを示しており、これは必要に応じてV：μ➙νでfをもたらす。

  （v）（fixxρ。eρ〜）_ρ。それからp〜。 xρを修正する| eρ〜はwtである。
  今、我々はv：ρを必要とする。

    v = Y（λv '、ε[| e |]η（v' / x））。

  ここでv0 =∐i、vi、v0 =⊥V、v_（i + 1）=ε[| e |]η{vi / x}、タイプの有向完全性によって、vi：ρそれぞれi。

  明らかにv0：ρ。
  vi：ρと仮定する。
  ηをpとすると、η{vi / x}はp〜fixxρを尊重するので、主帰納仮説v_（i + 1）：ρも同様であり、終了する。

  （vi）（x =eρ〜eσ ' - ）_σとする。
  次にp〜| eρ〜はwtなので、すぐにv：ρを持ちます。ここで、v =ε[| e |]ηです。 ε[| e '|]η（v / x）：σが必要です。

  今すぐp！・letxρ| σ{σ/ x}はρ - ・letxρを尊重している。 残りは誘導仮説に従う。 1

<!-- 365 18/28 -->

  結論として、

    ε[|d|]η ≠ wrong,

  が成り立ちます。なぜなら、間違った型はないからです。

### 4. タイプの良いアルゴリズムとその正確さ

## 4.1. アルゴリズム W

  このセクションでは、プレフィックス付きの式の型指定を見つける問題に取り組んでいます。
  このためにアルゴリズムWを提示する。
  Wが構文的に健全で（ある意味では）完全であることを証明したいと思います。
  統語的な健全性によって、Wが成功するたびにwtを生成することを意味します。 完全性によって、Wが存在するときはいつでも、Wは（ある意味では）少なくとも一般的なものを見つけることに成功することを意味する。

  Wはおそらく完成していますが、簡単な証拠を見つけるのは難しいです。
  だから、健全性に集中し、Wの実装についてコメントし、より豊かな言語に対応するようにWを拡張します。
  Wをシミュレートするタイプチェックアルゴリズムは、LCFメタ言語ML [2]の文脈でほぼ2年間正常に動作しているため、その完全性のために、その有用性がある程度証明されています。

  WはRobinson [14]の統一アルゴリズムに基づいている。
  確かに、統一の枠組みのなかに直接入っていない井戸型の唯一の特徴は、xτがletxσに束縛されるときはいつでも、τがσの一般的なインスタンスでなければならないという条件である。
  Wの完全性（ある意味では）は、統一に関する次の命題の第2部から続くべきであるが、Wが健全であるという証拠の前半だけが必要である。

  命題 5（ロビンソン）。
  アルゴリズムUがあります。一対の式を（変数のアルファベットを超えて）取って代入を行います。つまり、式σとτの任意の組

  （A）U（σ、τ）が成功してUを生じると、Uはσとτを統合する（すなわち、Uσ=Uτ）。

  （B）Rがσとτを統一するならば、U（σ、τ）は、ある置換Sに対してR = SUとなるようにUを生み出す。

  さらに、Uはσとτの変数のみを含む。

  完全なプログラムfの正しいタイプを見つけるために、letバインディングだけを含む型付き接頭辞p〜を与えて、あらかじめ定義された識別子にバインドされた値の型を与えることが期待されます。
  次に、Wが、p〜| f〜はwtである。

  しかし、Wを再帰的に宣言するためには、すべての型の束縛を含む接頭辞が出現し、Wは一般にプログラムに課せられた制約を満たすために接頭辞中の非行型変数を変更する必要があります。
  したがってWはWを必要な変換を表す代用Tにも戻す。

<!-- 366 19/28 -->

  正確には、W（p〜、f）が成功し、（T、f〜）を返すと、（T p〜）| f〜はwtである。

  我々はまずWを述べる。
  ある点では、以前に発生しなかった型変数が必要である。 そのような新しいタイプ変数は、βまたはβiによって示される。
  W（p〜、f）は、fの構造上の誘導によって定義される。 このアルゴリズムは、後で提示するより効率的なアルゴリズムとは対照的に、純粋に応用的なプログラミングスタイルで表現されています。これは、命令プログラミングのスタイルでより多く表現されています。

#### アルゴリズム W

    W(p~,f) = (T,f~), ここで

  (i) f が x のとき:

    もし λxσ, または fix xσ が p~ 内でアクティブならば
      T = I, f~ = xσ;
    もし let xσ が p~ 内でアクティブならば
      T = I, f~ = xτ
    ここで τ = [Bi/αi] σ, αi がσのジェネリック変数,
    かつ βi は新しい変数。

  (ii) f が (de), ならば:

    let (R, dρ~) = W(p~,d), かつ (S, eσ~) = W(R p~, e);
    let U = U(Sρ, σ ➙ β), β が新しい;
    ならば T = USR, かつ f~ = U(((S d~)e~)_β).

  (iii) f が (if d tha e else e’), ならば:

    let (R, dρ~) = W(p~, d) かつ U0 = U(ρ, ι0);
    let (S, eσ~) = W(U0 R p~, e), かつ (S’, e_(σ')'~) = W(S U0 R p~, e’);
    let U = U(S' σ, σ’);
    ならば T = U S’ S U0 R, かつ
         f = U((if S' S U0 d~ then S' e~ else e’~)_σ).

  (iv) f が (λx . d) ならば:

    let (R, d~) = W(p~ . λxβ, d), ここで β は新しい;
    ならば T = R, かつ f~ = (λxRβ . dρ~)_(Rβ➙ρ) .

  (v) f が (fix x . d) ならば:

    let (R, dρ~) = W(p~ . fix xβ, d), β は新しい;
    let U = U(R　β, ρ);
    ならば T = U R, かつ f~ = (fix xURβ . U d~)_(URβ) .

  (vi) f が (let x = d in e) ならば:

    let (R, dρ~) = W(p~, d);
    let (S, eσ~) = W(R p~ . let xρ, e);
    ならば T = S R, かつ f~ = (let xSρ = S d~ in e~)_σ . ■

<!-- 367 20/28 -->

## 4.2. Wの健全性

   Wが健全であることを示すために、いくつかの簡単な定義があると便利です。
   Aが型、型付きの接頭辞、型付きのpeならば

    Vars(A) ≝ {α | α ∈ A, α a type variable}.

  Aが型付きプリフィックスまたは型付きpeの場合

      Gen（A）≝{α| α∈A、αはジェネリック型変数）。
     Spec（A）≝Vars（A） - Gen（A）。

   Sが代入である場合、

    Inv(S) ≝ {α | S involves α}
           = {α | ∃β. S β ≠ β and α ∈ {β} ∪ Vars(S β)}.

  以下の単純な性質が必要です。その証明は省略します。

   命題 6.

    (A) Inv(RS) ⊆ Inv(R) ∪ Inv(S)
    (B) Vars(Sτ) ⊆ Vars(T) ∪ Inv(S).

  理論2（統語的健全性）。
  p〜を標準接頭語とし、p | f a（閉）pe。
  そして、W（p、f）=（T、fτ〜）ならば、

     （A）T p〜| f〜はwtであり、

     （B）Inv（T）⊆Spec（p〜）∪New、

   そして

     （C）Vars（τ）⊆Spec（p〜）∪New、

   ここで、NewはWによって使用される新しい型変数の集合です。

  証明。
   fの構造上の誘導によって、wtの再帰的定義を用いる。
   条件式と修正式のケースは省略されています。新しい式はありません。最初に他のケースよりも簡単に扱います

   （i）fはXである。そしてT = Iであるので、（B）は即時である。
   λxσ、またはfixxσがp〜で有効である場合、f〜=xσであり、（A）、（C）は即時です。

   letxσが有効な場合、τ= [βi/αi]σ、{αi}はσで一般的であり、New = {βi}である。
   そして、T p〜| f〜= p〜| xτは標準であり、（A）、（C）は容易に従う。

   （iv）fは（λx・d）である。 新しい変数New1を使って（R、dρ〜）= W（p〜。λxβ、d）とする。

<!-- 368 21/28 -->

  誘導により、R（p〜λxβ）| dρ〜はwtであるから、（A）f〜= R p〜| （λxRβ、d〜）_（Rβ➙ρ）はwt（重量％）である。
  誘導によっても、

     Inv（R）|
     Var（ρ）| ⊆Spec（p〜λxβ）∪New、
              = Spec（p）∪{β}∪New、
              = Spec（i）∪New（New = New1∪{p}以降）

   T = Rであるから（B）が続く。
   （C）

     命題6によるVars（Rβ➙ρ）⊆Inv（R）∪{@ U Vars（p）
                   ⊆Spec（p）∪New

   要求に応じ。

  （vi）fは（x = dでeとする）。
   次に、新しい変数New1を使って、（R、dρ〜）= W（p〜、d）としましょう。
   その後、誘導によって

    R p~ | d~ is wt                                    (1)

    Inv(R)  |
    Vars(ρ) | ⊆ Spec(p~) ∪ New1                       (2)

  今（2）から

     Spec（R p〜）⊆Inv（R）∪Spec（p〜）
                ⊆Spec（p〜）∪New1（3）

  （1）標準から

    Gen(R p~ | d~) ∩ Spec(R p~) = ∅.                   (4)

  また、Gen（R p〜）= Gen（p〜）は、Vars（ρ）と（2）で分かれているため、R p〜・letxρが標準的な接頭辞です。

  よって、新しい変数New2を使ってS、eσ〜= W（R p〜exρ、e）とする。
  その後、誘導によって

    S(R p~ ・ let xρ) | e~ is wt                         (5)

    Inv(S)  |
    Vars(σ) | ⊆ Spec(R p~ ・ let xρ) ∪ New2             (6)

  しかし、（6）と（4）をまとめると（New2は新しい変数なので）Spec（R p〜letxρ）= Spec

    Inv(S) n Gen(R p~ | d~) = ∅

  命題4により、S（R p〜| d〜）がwtであり、（5）を用いてwt

    S R p~ | (let xSρ = S d~ in e~)_σ

  wtである。 しかし、これはちょうどT p〜です。 私たちは（A）を証明しました。

<!-- 369 22/28 -->

  （B）については、

     Inv（T）⊆Inv（S）∪命題6によるInv（R）
            ⊆Spec（p〜）∪New1∪New2、（6）、（3）、（2）を用いて、

  （C）については、同様の推論によって、

    Vars(σ) ⊆ Spec(p~) ∪ New1 ∪ New2 .

  この場合、New = New1∪New2であるので、これだけで十分です。

  （ii）fは（de）である。
  新しい変数New2を使用して、新しい変数New1および（S、eσ〜）= W（Rp〜、e）を使用して（R、dρ〜）= W（p〜 ケース（vi）と同様の理由で、我々は

    S R p~ | S(dρ~) is wt                            (7)
    S R p~ | eσ~    is wt                            (8)

    Inv(S R)          |
    Vars(Sρ), Vars(σ) | ⊆ Spec(p~) ∪ New1 ∪ New2.  (9)

  ここで、U = U（Sp、σ➙β）、ここでβが新しい場合、命題5により、

    U Sρ = Uσ ➙ Uβ,                                  (10)
    Inv(U) ⊆ Vars(Sρ) ∪ Vars(σ) ∪ {β}.             (11)

   Uはwt（7）と（8）の一般的な変数を含まず、

    U S R p~ | U(((S d~) e~)_β)

   wtである。 しかし、これはちょうどT p〜です。 私たちは（A）を証明しました。 （B）については、まず

    New = New1 ∪ New2 ∪ {β},

   そう

     Inv（T）⊆命題6によるInv（U）∪Inv（SR）
            ⊆Spec（p〜）∪New、（9）と（11）から、

   （C）については、

     Vars（τ）= Vars（Uβ）
             命題6によるInv（U）∪{β}
             ⊆Spec（p〜）∪New、（9）と（11）から再び。 ■

## 4.3. Wの実装。 簡略化されたアルゴリズムI

  それが立っているので、Wはほとんど効率的なアルゴリズムではありません。 置換はあまりにも頻繁に適用される。
  健全性を証明するために策定されました。
  正確な意味でWをシミュレートするより簡単なアルゴリズムIを提示します。

<!-- 370 23/28 -->

  I は W と2つの点で違います。
  まず、置換が構成されているが、それが不可欠であるときにのみ適用される、解像度ベースの定理証明システムに関する文献に精通した考え方を採用する。
  第2に、実際にタイプタイピングアルゴリズムから実際に必要とされるのは、型の代入f全体ではなく、f自身に代入される型だけであるという事実を利用します。

  実際、 `I`は` E`という唯一の代入、すなわち `EE = E`を生成します
  つまり `β∈Eα`ならば`Eβ=β`となる。
  この置換はプログラム変数（ `E 'と呼ばれる）でグローバルに' I 'に保持され、` I`は `E'で変換されます。
  統一関数Uの代わりに、Iは統一手順UNIFYを呼び出し、結果UNICYを出力しますが、変数Eに影響します。
  `U`と` UNIFY`は、 `E`と` E`の次のような関係があると仮定します：コマンドの前後の `E`の値

    UNIFY(σ, τ)

   かつ、もし

    S(Eσ, Eτ) = U

   ならば

    E’ = U E.

  したがって、Eの存在下でタイプσおよびτにUNIFYを適用することは、タイプEσおよびEτにUを適用することに対応する。 σとτは、「探索」置換Eを適用することによって得られる明示的な型を表す暗黙の型と考えることができる（Eの等式は、さらなる解説が不要であることを意味する）。
  UNIFY（成功した場合）の効果は、新しい置換置換E 'を生成することです。
  同様に、暗黙の型付きプレフィックスp〜を扱います。これは、必要に応じてEを適用することで解説できます。
  私は局所変数ρ、σ、σ 'を持ち、それらの値は暗黙の型であり、その結果を第4の変数τで生成すると仮定する。

  初期冪等元 `E`を仮定すると、` I`は型付き接頭辞 `p〜`と `` e p〜 `が標準で` `p | fは `pe 'である（すなわち、` f'の全ての空き識別子は `p`に束縛されている）。
   アルゴリズムは次のとおりです。

  アルゴリズムI

    I(p~, f) = τ, ここで

   （i）fがxの場合、

     λxσまたはfixxσがp〜で有効である場合、τ：=σ。
     letxσがp〜で有効である場合、τ：= [βi/αi]Eσここで、αiはE p〜におけるletxEσの一般的な型変数であり、βiは新しい変数である。

   （ii）fが（de）ならば：

     ρ：= I（p〜、d）。 σ：= I（p、e）。
     UNIFY（ρ、σ➙β）; （βnew）
     τ：=β

<!-- 371 24/28 -->

  （iii）fが（dならばe else e 'なら）ならば、

    ρ := I(p~, d); UNIFY (ρ, ι0);
    u := I(p~, e); σ’ := I(p~, e’);
    UNIFY(σ, σ’); τ := σ

  （iv）fが（λx、d）の場合、

    ρ := I(p~ ・ λxβ, d); (β new)
    τ := β ➙ ρ

  （v）fが（fix x・d）ならば、

    ρ := I(p~ . fix xβ, d); (β new)
    UNIFY(β, ρ); τ := β

  （vi）fが（eのx == dとする）ならば、

    ρ := I(p~, d); σ := I(p~ . let xρ, e);
    τ := σ.      ■

  IとWのシミュレーション関係は何ですか？
  それは、私たちが健全性定理において遭遇したわずかな微妙なものを含む簡単な構造誘導であるため、省略した以下の命題によって単純に表される。

  命題7. pを| fはa peであり、Eは等冪であり、E p〜である。 標準である。
  W（E p〜、f）が成功すれば（TとfTを生成する）、I（p〜、f）は成功する（τ 'とEの新しい値E'を生成する）。

    (A) E’ = TE,
    (B) E’T’ = τ.

  したがって、Iによって生成される型は、説明されるとき、WによってFに帰される型である。

  実際には、Eは、これまでに例示された変数を表す変数型対のテーブルINSTによって効率的に表される。
  UNIFYの効果は、単にインスタンス化されていない変数のインスタンス化を表すINSTにいくつかのエントリを追加することです。
  INSTによって表される置換Eは、以下のように再帰的に与えられる

        E(ι) = ι      (basic types),
        E(α) = E(ρ)   if (α, ρ) ∈ INST for some ρ,
             = α      otherwise,
    E(σ ➙ τ) = Eσ ➙ Eτ.

  実際、LISPで書かれたML用に実装された拡張バージョンでは、INST自体は型変数の（LISPの意味で）INSTANCEのプロパティで表されます。
  各型変数αは、あるρに対して（α、ρ）∈INSTならば、そのINSTANCE特性値としてρを持つ。 それ以外の場合、プロパティ値はNILです。

<!-- 372 25/28 -->

## 5. 拡張言語の型

   私たちは現在、私たちの言語のいくつかの拡張を検討し、その結果をどのように強化してそれらに適用するかを検討します。

（1）冒頭で述べたように、☓（Cartesian product）、+（disjoint sum）、list（list forming）などの余分な（プリミティブ）型の演算子を追加することは難しくありません。
   ➙と一緒に、これらは言語MLのプリミティブ型演算子です。
   ☓については、標準の多形関数

    pair: α ➙ β ➙ (α ☓ β)    (one could add the syntax (e, e’) for pair (e)(e’)),
    fst: α ☓ β ➙ α,
    snd: α ☓ β ➙ β.

  + の場合は、

    inl: α ➙ α + β,    inr: β ➙ α + β    (left and right injections),
    outl: α + β ➙ α,   outr: α + β ➙ β   (left and right projections),
    isl: α + β ➙ bool, isr: α + β ➙ bool (left and right discriminators)

  自然な解釈で。
  リストについては、第2章で述べた標準的なリスト処理関数があります。
  リストのすべてのメンバーは同じタイプでなければならないことに注意してください。

  セマンティック・サウンド定理は、セマンティック・ドメインを適切に調整することで自然に拡張されます。 構文的健全性の定理は事実上変化しない。

  （2）次に、割り当て可能な変数と代入を検討する。
  これらを追加する1つの方法（MLで使用）は、代入式 "x：= e"（値はeの値）を許可し、式 "letref x = e in e '"を代入可能 eの値に初期化された変数。
  これらの追加の最初の効果は、セマンティックドメインの大きな変化です。これは、式が副作用を持つ可能性があるためです。
  セマンティック健全性定理が証明されるかもしれないと我々は信じているが、それは面倒な作業であるようである。
  難しさの理由は、

    λx.(y := x)

  これは副作用を伴う同一性関数である。
  タイプα➙αを持っていると言うと、タイプμの引数が与えられると、それはタイプμの結果を与え、yの副作用を考慮しないことを意味する。
  必要とされるのは、副作用を考慮して、そのような機能型が意味するもののより意味のある定義（意味論的領域の観点から）です。

  これとは対照的に、2つの新しい種類の式に対して適切な型指定規則を与えることは簡単です。
  wtの定義を次の節で拡張します。

  （i）（c）letrefxτが標準接頭辞p〜で有効であれば、p〜| xτはwtである。 （したがって、xのすべてのletrefバインドされたオカレンスは、同じタイプでなければなりません）。

<!-- 373 26/28 -->

  （vii）p〜| （xρ：=eσ〜）_τはwtfである。 e〜はwtであり、letrefxρはp〜で有効であり、ρ=σ=τである。

  （viii）p〜| （letrefxρ=eρ〜eσ '〜）_τはwtfである。 e〜とp〜.letrefxρ| e '〜はwtであり、σ=τである。

  アルゴリズムWと構文健全性定理を拡張してこれらの節を扱うのは日常的な問題です。
  しかし、意味論的考察に再び戻ると、λ抽象（手順）内の非局所的割り当てに関連する問題がある。
  検討する

    let g = (letref y = nil in λz . y := cons(z, y))

  これは関数gの隠れた（自身の）変数としてyを設定します。
  私たちのルールでは、gはジェネリックタイプα➙αリストを取得します。
  代入の値が割り当てられた値であることを思い出すと、gの各呼び出しは隠されたyを増やし、増補されたリストを値として返します。
  今ではαが一般的なので、式

    g(2),    g(true)

  gのスコープ内で、int型リストとboo1型の両方の型でそれぞれ許容されます。
  しかし、この順序で評価される場合、2番目の式の値は、2つのメンバーが真で2のリストです。 それはブール値のリストではありません！

  このジレンマには少なくとも2つの解決策があります。
  1つは、このような状況では、一般的な型の変数ではないということです。
  MLで採用されている別のものは、λ抽象（手順）内の多形性の割り当て可能変数への非局所的割り当てを禁止することです。
  ポリモーフィックの代入変数は、例えば、iterations（whileステートメント）自体にシンプルなwtルールを与えることができます。

  私は、第二の解決策が、わずかに緩和さえあっても、セマンティック健全性定理を認めていると信じています。
  しかし、詳細は魅力的ではなく、私は（特にジョン・レイノルズとの有用な議論の後で）証拠を完成させようとするのはお勧めしません。
  むしろ必要とされるのは、副作用をより重視する言語設計です。 1つのアプローチは、プロシージャに割り当てられたすべての変数がプロシージャの出力パラメータとしてリストされるように要求することによって、PASCALを変更することです。
  しかし、これをどのように自分の変数の有益な特性と組み合わせるかは、私が知る限り、言語設計における未解決の問題であり、良い解決策は貴重な一歩となるでしょう。
  最近の有望な副作用管理の試みとして、Reynolds [13]を参照してください。

  （3）MLに含まれている自明でない拡張のリストを完成させるには、新しい型の演算子を古いものとして宣言（再帰的）することを検討してください。
   そのような宣言は非グローバルな範囲を持つかもしれない。
   新しい型の演算子に対する一連の関数の宣言も伴い、型演算子の明示的な定義は、（新しい型の演算子の全範囲内ではなく）関数の集合を定義する場合にのみ利用可能であり、 現在抽象型と呼ばれるもののバージョンを持っています。
   MLでは、チップ変数の型を表す型変数αを使用して、チップが任意の型のオブジェクトによってラベル付けされたバイナリツリーのクラスを定義します。

    absrectype  α bitree = α ➙ (α bitree ☓ α bitree)
          with  sons(t) = ...
           and  maketree(t, t’) = ...
           and  tiptree(a) = ... 

<!-- 374 27/28 -->

  省略された定義式だけがビット・ツリーの表現へのアクセスを与えられる。
  定義された関数は多型であり、ジェネリック型

    α bitree ➙ (α bitree)^2,   (α bitree)^2 ➙ α bitree,   α ➙ α bitree.

  この構成の詳細については、[2]を参照してください。 我々は部分的にロックウッドモリスとジェリーシュワルツとの議論に構造を負う。
  この場合、wtルールも比較的簡単です。 文法的、意味的な健全性はチェックしていませんが、大きな困難はないと考えています。

 （4）一種の多型に寄与する二つの特徴はこれまで完全に無視されてきた。
  最初は強制です。 式x：= 42（ここで、xは実際の代入変数です）は、私たちのために型が不正です。
  しかし、タイプチェッカーがそのような不正な型入力を報告し、コンパイラーがレポートを受け取り、それを修正する強制を挿入できるようにすることに障壁はありません。

  第2の特徴は、特定の手順（標準またはユーザ定義のいずれか）が複数の種類を有することを可能にすることである。
  勿論、α^ 2➙α（もちろん2つの型を持つ最も一般的なポリタイプ）を持たずに、int ^ 2➙intとreal ^ 2➙realを持つことができます。
  私たちは質問を調査していませんが、私たちの規律にこの特徴を重ね合わせる良い可能性があるようです。

## 6. 結論

   私たちは、実用的に有用であると思われる多型プログラミングの規律を提示し、かなり単純な型チェックアルゴリズムを与えました。
   制限された言語では、このアルゴリズムが正しいことが証明できることが示されています（証明は2つの健全性定理に因数分解されました）。
   まだ多くの作業が残っていますが、タイプ・チェッキングの実践が意味論と証拠によってサポートされるべきであり、そうでなければならないという点を強調したいと考えています。

## 謝辞

   私は、このペーパーの最初のバージョンについて、審査員に謝意を表します。これは、いくつかの不正確さに注意を喚起し、いくつかの点でより明確な説明につながりました
   場所。
   Dorothy McKieにも、紙の2つのバージョンを慎重に準備していただき、ありがとうございます。

## REFERENCES

  1. W. H. BURGE, “Recursive Programming Techniques,” Addison-Wesley, Reading, Mass., 1975.
  2. M. GORDON, R. MILNER, AND C. WADSWORTH, “Edinburgh LCF,” CSR-11-77, Computer Science Dept., Edinburgh University, 1977.
  3. M. GORDON, R. MILNER, L. MORRIS, M. NEWEY, AND C. WADSWORTH, A metalanguage for interactive proof in LCF, in “Proc. 5th Annual ACM SIGACT-SIGPLAN Symposium on Principles of Programming Languages, Tucson, Arizona, 1978.” 

<!-- 375 28/28 -->

  4. D. GRIES AND N. GEHANI, Some ideas on data type in high-level lcnguages, Comm. ACM. 20 (1977), 414-420.
  5. R. HINDLEY, The principal type-scheme of an object in combinatory logic, %zx~. Amer. &ikth. Sot. 146 (1969), 29-60.
  6. B. W. LAMPSON, J. J. HORNING, R. L. LONDON, J. G. MITCHELL, AND G. L. POPEK, Report on the programming language Euclid, SIGPLAN Notices (ACM) 12, 2 (1977).
  7. P. J. LANDIN, The next 700 programming languages, Comm. ACM 9 (1966), 157-164.
  8. B. H. LISKOV AND S. ZrLLEs,Programming with abstract data types, in “Proc. of ACM SIGPLAN conference on Very High Level Languages,” SIGPLAN Notices (ACM) 9 (1974), 50-59.
  9. R. MILNER, “Models of LCF,” Mathematical Centre, Amsterdam, Tracts, Vol. 82, pp. 49-63, 1976.
  10. J. H. MORRIS, “Lambda-Calculus Models of Programming Languages,” Ph.D. Thesis, M.4CTR-57, MIT, 1968.
  11. G. PLOTKIN, A power-domain construction, SIAM J. Comput. 5 (1976), 452-487.
  12. J. C. REYNOLDS, “Towards a Theory of Type Structure,” Systems and Inform. Sci., Syracuse University, 1974.
  13. J. C. REYNOLDS, Syntactic control of interference, in “Proc. 5th ACM Symposium on Principles of Programming Languages, Tucson, Arizona, 1978,” pp. 39-46.
  14. J. A. ROBINSON, A machine-oriented logic based on the resolution principle, J. Assoc. Comput. Much. 12 (1965), 23-41.
  15. D. SCOTT, Lattice theoretic models for various type-free calculi, in “Proc. 4th International Congress for Logic, Methodology and Philosophy of Science, Bucharest, Rumania, 1972.”
  16. D. SCOTT AND C. STRACHEY, Towards a mathematical semantics for computer languages, in “Proc. Symposium on Computers and Automata,” Vol. 21, Microwave Res. Inst. Symposia Series, Polytech. Inst. of Brooklyn, 1971.
  17. D. SCOTT, Data types as lattices, SIAM j. Comput. 5 (1976), 522-587.
  18. A. SHAMIR AND W. WADGE, Data types as objects, in “Proc. 4th ICALP Conference, Turku, Finland, 1977.”
  19. C. STRACHEY, Fundamental concepts in programming languages, Notes for the International Summer School in Computer Programming, Copenhagen, 1967.
  20. R. D. TENNENT, On a new approach to representation-independent data classes, Acta Inform. 8 (1977), 315-324.
  21. B. WEGBREIT, The treatment of types in ELl, Comm. ACM 17 (1974), 251-264.
  22. A. VAN WIJNGAARDEN ET AL., Revised report on the algorithmic language ALGOL 68, Acta Informutica 5 (1975), l-236.
  23. R. A. WULF, R. L. LONDON, AND M. SHAW, “Abstraction and Verification in ALPHARD: Introduction to Language and Methodology,” ISIIRR-76-46, Univ. of California, 1976.
