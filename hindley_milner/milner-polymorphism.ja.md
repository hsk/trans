# プログラミングにおける多相型の理論 - A Theory of Type Polymorphism in Programming

  ROBIN MILNER

  Computer Science Department, University of Edinburgh, Edinburgh, Scotland

  Received October 10, 1977; revised April 19, 1978
  <!-- Edinburgh エジンバラ(イギリス北部、スコットランドの東の都市、スコットランドには西にグラスゴーがある。スコットランドはグラスゴーとエジンバラの２つの大きな都市がある) -->

  ----

  0022 - 0000/78/0173 - 0348 $ 02. 00/0
  Copyright 8 1978 by Academic Press, Inc.
  All rights of reproduction in any form reserved.

  ----

  この研究の目的は、主に実用的なものです。
  型の規律を課さない構造処理言語におけるプログラミングの広く採用されたスタイルは、多種多様なオブジェクトでうまく動作するプロシージャを定義することを必要とします。
  そのような多相的手続きのための形式的な型の規律を、単純なプログラミング言語の文脈で提示し、規律を強制するコンパイル時型検査アルゴリズム W を提示します。
  意味的健全性定理 (言語の形式的な意味論に基づく) は、 well-type プログラムは`間違っている`ことができないと述べており、構文健全性定理は、 W がプログラムを受け入れるならば型付けされていると述べています。
  これらの結果をより豊かな言語に拡張することについても議論します。 エジンバラ LCF システムのメタ言語 ML について、 W に基づく型検査アルゴリズムが実際に既に実装されて動作しています。
  <!-- aim 目標 largely 主に practical 実用 widely 広く employed 採用された particularly 特に impose 課す descipline 規律
  entails 必然的に variety バラエティー enforce 強制する -->

## 1. はじめに

  この作業の目的は、主に実用的なものです。
  広く使われているプログラミングのスタイルは、特に型の規律を課さない構造処理言語 (LISP は完全な例です)では、多種多様なオブジェクト(例えば、 atom のリスト、整数、またはリストなど)でうまく動作するプロシージャを定義します)。
  このような柔軟性は、このスタイルのプログラミングではほとんど不可欠です。残念ながら、誤って CDR を LISP のアトムに適用し、不自然にプロパティリストを整数に追加する人は、その症状を知ることになります。
  一方、上記の柔軟性を排除する ALGOL 68 [22] のような型の規律は、我々が話しているプログラミングスタイルを排除します。
  ALGOL 60 は柔軟性がありました。つまり、手続きパラメータは "手続き" として指定する必要がありました。しかし、柔軟性は一様ではなく、十分ではありませんでした。
  <!-- unfortunately 残念ながら rather むしろ inscrutable 不可解な absurdly 不当に
  symptom 症状, 徴候, 症候, 兆候, 病徴, 下地 preclude 排除する mention 言及 above 上の also さらに、また sufficient 十分 -->

  このような柔軟性についての初期の議論は、おそらく多相性と呼ばれる最初の者であった Strachey [19] に見出すことができます。
  実際、彼はそれを "パラメトリック" 多相性と呼んでいました。これは、"アドホック" 多相性とは対照的でした。
  後者の例は、整数加算と実加算の両方を表すために "-|" を使用することです(実際には、複素加算、ベクトル加算などを表すためにさらに拡張することができます)。いくつかの異なる型でこの識別子を使用することは、現在は "オーバーロード" と呼ばれていることが多く、このホワイトペーパーではそれに言及していません。

  <!-- 349 2/28 -->

  この論文では、型の柔軟性を獲得する方法を提示し、正当化する一方で、堅牢なプログラムを保証する規律を保持しています。
  この仕事は単なる理論的な運動ではないという証拠があります。ここで議論する多相型規律は、 LCF メタ言語 ML に組み込まれており、 2 年近く使用されています。
  この言語用のコンパイル時型チェッカーは、かなりの割合のプログラミングエラーをトラップする貴重なフィルタであることが証明されています。
  <!-- justify 正当化する gaining 獲得する but also だけでなく retaining 保持する ensures 確実に robust programs 堅牢なプログラム
  theoretical exercise 理論的な運動 incorporated 組み込まれた significant proportion かなりの割合 -->

  本論文の主要な部分は、シンプルな説明的言語の文脈における、型の規律に関する技術的な説明(意味論的および構文的な両方)に関係しているが、この時点では、非形式的にアプローチを特徴付けることが有用です。
  その主な特徴を概説します。
  <!-- concerned 心配している illustrative 説明的な helpful 役に立つ informally 非公式に predominant 支配的 concerning について  -->

  第一に、型に関するすべてがコンパイル時に行われます。型・チェッカー(コンパイラの一部)がプログラムまたはプログラム・フレーズを受け入れると、実行時にオブジェクトがその型を持たないことを前提としたコードが生成されます。
  これは、効率的なオブジェクトコードを生むものとして広く受け入れられていますが、 EL1 のアプローチと比較して型の使用に制約を課します [21]。

  第二に、多くの重要でないプログラムは、文脈から推論されるので、型の言及を完全に避けることができます。
  (ただし、 ML では、他の言語と同様に、ユーザーは実際には、これらの型の操作と一緒に自分の型を定義する必要があります。
  このようにユーザが自分の型を定義できるようにする最近の言語は、 CLU [8]、 ALPHARD [23]、 Euclid [6] です。
  プロシージャの正式なパラメータを含む宣言された変数の型指定を要求することは、より分かりやすい問題につながることを納得して論じることができますが、これらの仕様を省略できるようにすることは、特にオンラインプログラミングにおいても便利です。
  いずれにせよ、我々が提示する型チェッカーは非常に単純であり、たとえ変数の型が宣言で常に指定されていても、はるかに簡単にすることはできません。
  <!-- entirely 完全に may-indeed 本当にかもしれない Although しかし argued 主張した
  convincingly 説得力のある demand 要求 intelligible 分かりやすい convenient 便利 quite かなり-->

  第三に、多相型が主要な役割を果たします。
  たとえば、プロシージャーには多相型 (一般に polytype と略します)が割り当てられます。その引数の型および結果が文脈から一意的に決定される場合のみ、それは単相的(すなわち、単相型が割り当てられる)です。
  Gries と Gehani [4] は、 (LISP や SNOBOL の型なしプログラミングとは対照的に) 制御された多相型プログラミングの説得力のあるケースを作りました。しかし、また Tennent [20] では、多相型を指定するために型変数や識別子の存在が必要です。
  我々のために、プログラムに存在する多相型は、すべてのプログラミング言語に存在すると思われるプリミティブ多相型演算子の自然な成果です。そのような演算子は、代入、関数適用、ペアとタプル、およびリスト処理演算子です。
  これは、主に、これらの演算子の型制約と、変数の宣言と使用で、プログラムのフレーズの型とそのサブフレーズの種類を決定します。

  本書では、最終的に強制的にまたは識別子の "オーバーロード" のどちらかを除いて、このホワイトペーパーでは説明しません。
  我々の見解では、これらの概念やランタイム型の操作は、コンパイル時の多相型の規律とは幾分直交しており、ある程度は無効化せずに組み込むことができます。

  第 2 節では、 ML の断片の例による型の規律を説明します。
  この断片は自明であるべきでありますが、 ML の概要は [3] で与えられ、完全な記述は [2] に示されます。
  これらのイラストは、我々が有用な言語を扱うことができるようにするために役立つはずです。
  論文の残りの部分は、非常に簡単な適用言語 Exp を使って規律を正当化します。
  正当化は 2 つの部分に分かれます。

  <!-- 350 3/28 -->

  第 3 章では、型定義(正しい型の割り当て)の概念を定義し、型付きプログラムが意味的に型違反がないことを示す意味健全性定理を証明します。
  言語の操作上の定義を与える場合、これは、たとえば、整数が真理値に加算されることも、引数に適用されることもないことを意味し、その結果、実行時検査のためにその型を持ち運ぶ必要はありません。
  第 4 章では、よく型されたアルゴリズム W を提示し、文法健全性定理を証明します。文法健全性定理は、 W が成功すればプログラムの型付けを生成すると述べています。
    W をシミュレートする、より効率的なアルゴリズム I も提供します。

  Exp の型は基本的な型の集合に対する単なる関数型の階層です。
  つまり、 Exp の多相性は、単一のプリミティブ多相型演算子、関数適用、変数バインディングの自然な拡張です。
  ペアや(ML のような)リスト処理演算子のような他の基本多項式演算子を、基本的な `☓` (Cartesian Product)、list (リスト生成)、 `+` (分離した合計)は、(関数型)に加えて、 2 つの健全性定理に特別な困難を与えません。
  実際、代入演算子を追加することは、構文健全性定理に関する限り簡単ですが、セマンティック健全性定理は、このケースでは、アサイナブルの現在の値を保持するメモリまたはストアの余分なセマンティックの複雑さのために、拡張するのが難しい変数。
  これについては第 5 章でさらに議論します。

  我々の研究は、彼の論文で Morris [10] が表現した問題を次のように解決するための一歩です:
  プログラマが関数の呼び出しごとに異なる型を持つ関数を定義する言語と型システムを設計することができます。
  この論文の第 4 章では、問題の明確な紹介として推奨しています。
  Morris は形式の意味論について公式には議論していないが、多相型の系を与えているが、一連の連立 1 次方程式を解くことによって、λ-計算の項でどのように有効な型の割り当てが見つかるか説明しています。次のセクションでこの考え方をさらに進めていきます。

  この作業を行った後、我々は、結合論理の項のための "主要型スキーム" (これを多相型と呼ぶ)を導出する Hindley の方法 [5] を知るようになりました。
  Hindley は、 Robinson の単一化アルゴリズム [14] がこの問題に適切であることに気づく最初の者であるように思われます。
  我々の仕事は、 Hindley の方法をローカル宣言を使ってプログラミング言語に拡張し、そのメソッドの意味論的正当性とみなすことができます。

  要約すると、命令型の機能を持つ現在使用されているプログラミング言語に対して構文的によく理解され、正当化されている多相型の規律を提示します。また、重要ではないが非必須のサブ言語についても意味論的に説明されます。

## 2. 型の規律の実例

  多相性の概念を簡単な例を使って説明します。
  それらは ML の断片で書かれていますが、これはわかりやすいものです。この断片は実際には Landins ISWIM [7] にすぎず、読者は Burge の本 [1] に言及して、このプログラミングのスタイルをほぼ正確に使用しています。

  <!-- 351 4/28 -->

  ここでは必須の構成要素を使用しません(割り当てやジャンプ)。
  コンストラクト

    let x = e in e’,
    let f (x1, ..., xn) = e in e’

  はそれぞれ`e'`内で、 `e` の値に  `x` を与える、 あるいは `e` には抽象 `λ(x1, ..., xn) .e` の値を与えるために使用されます。
  再帰関数では `let` の代わりに `letrec` が使われ、 `e’` の部分が省略されたときの宣言があります。

  ML の完全に決定された型(すなわち単層型)は、バイナリの中置演算子 `☓`(デカルト積)、`+` (非交和) と `➙` (関数型)と単項後置演算子 `list` です。
  多相型 (polytypes) は、型変数を受け入れることによって得られます。これは、ここでは`α` 、 `β` 、 `γ` ···...で表されます。
  我々は任意の型を `ρ`、 `σ`、 `τ` で表します。
  この章では、型の意味を読者の直感に任せます。それは次の章で正確にされています。

  例 1. リスト上のマッピング関数。

    letrec map (f, m) = if null (m) then nil
                       else cons (f (hd (m) ), map (f, tl (m) )).

  直感的には、このように宣言された関数 `map` は、あるソートのものから別のソートのものへの関数と、第 1 ソートのもののリストを取り、第 2 ソートのリストを生成します。そこで、`map` には以下の型がつきます:

    ((α ➙ β) ☓ α list) + β list,

  ここで、 `α`、 `β` は型変数です。

  この型は `map` の裸の宣言からどのように決定されるのでしょう？
  まず、宣言で自由に出現する識別子のジェネリック型(後で "ジェネリック" と呼ぶ)は、

    null : α list ➙ bool,
     nil : α list,
      hd : α list ➙ α,
      tl : α list ➙ a list,
    cons : (α ☓ α list) ➙ α list,

  つまり、それらの型には 1 つ以上の型変数が含まれており、その規則は次のとおりです。このような識別子が出現するたびに、その型の代入インスタンス(型変数の型を代入する)である型が割り当てられます。

  これらの識別子はそれぞれ宣言の中で一度だけ出現するので、識別子 `id` に割り当てられた型を `σid` で表す場合、いくつかの型 `τ1,..., τ5` に対して、

    σnull = τ1 list ➙ bool,
    σnil = τ2 list,
      σhd = τ3 list ➙ τ3
      σtl = τ4 list ➙ τ4 list,
    σcons = (τ5 ☓ τ5 list) ➙ τ5 list.

  <!-- 352 5/28 -->

  他の識別子 (`map`、 `f`、 `m`) はそれぞれ 2 回以上現れます。我々の規則では、それぞれのオカレンスに同じ型が割り当てられることを要求しています。規則はまた、いくつかの型 `ρ1、 ρ2、...`に対して以下の式が満たされることを要求します。

    σmap = σf ☓ σm ➙ ρ1,
    σnull = σm ➙ bool,
      σhd = σm ➙ ρ2,
      σtl = σm ➙ ρ3,
      σf = ρ2 ➙ ρ4,
    σmap = σf ☓ ρ3 ➙ ρ5,
    σcons = ρ4 ☓ ρ5 ➙ ρ6
      ρ1 = ρnil = ρ6.

  これらの条件の 1 つ目は、関数の型をその仮パラメータの型に関連付けることです。
  条件付き式がその 2 つの腕と同じ型を持ち、宣言の確定数と定義数が同じ型であるため、最後のものを除いて、関数適用であるいくつかの下位句から発生します。

  これらの方程式は、変数 `ρi`、 `τi`、および `σid` に対して解くことができます。
  Morris [10] は、このような方程式の解を論じています。
  事実、 Robinson [14] の単一化アルゴリズムの使用には完全に適切です。我々の型タイピングアルゴリズムはこのアルゴリズムに基づいており(この場合、単一化以上のものは必要ないので)、最も一般的な型のマップが得られたと Robinson の研究から結論づけることができます。すなわち、方程式取得した型の置換インスタンスでなければなりません。
  実際、上記の方程式の解は

    σmap = (γ ➙ δ) ☓ γ list ➙ δ list,

  ここで、 `γ`、 `δ` は任意の異なる型変数です。
  だから、これは `map` のジェネリック型です。つまり、この宣言のスコープ内のマップの出現には、この型のいくつかの置換インスタンスを割り当てる必要があります。

  これらのインスタンスは同じである必要はありません。
  `tok` は基本型(トークンが文字列である)であり、識別子(型を持つ)が利用可能であると仮定します。

  そして

      tokl: tok list    (a variable),
    length: tok ➙ int,
    sqroot: int + real,     two obvious functions.

  次に、式の

    map(sqroot, map(length, tokl))

  で、 `map` の 2 つの出現には型があります

    ((tok ➙ int) ☓ tok list) ➙ int list,
    ((id ➙ real) ☓ int list) ➙ real list.

  <!-- 353 6/28 -->

  同様に、 `null` の場合、たとえば `map` の定義で 2 回発生した場合、その型は

    α list ➙ bool

  我々の規則では、仮パラメータ(たとえば f) や識別子(map)の再帰的定義の異なる出現が同じ型を持つことを要求しています。

  上に述べた `map` の出現は、別々に宣言された 2 つのマップ関数の使用と見なすことができることに注意してください。
  Gries と Gehani が述べているように、コンパイラは、これらの明確な宣言を生成するタスクを与えることができます(プログラマが複製を見る必要はなく、意識する必要もないため)。異なる型で使用するマップ関数。
  効率のために、トークンリストが整数リストとは異なって実装されている(そして原始的な多相関数 `hd`、 `tl` 等が相応に異なっている)場合は、上記の例では本当に必要になります。
  我々は、これらの `map` 関数がすべて意味論的に同じオブジェクトであるとみなされる概念的なフレームワークに関心を持っています。実装者は望むように少数または多くの変種として実装する自由が残されます。

  この例から明らかなように、型付け規則は慎重に設定する必要があります。
  let または letrec をローカルで使用するときに何が起こるかを説明するもう 1 つの例を見てみましょう。

  例 2 タグ付け。 tagpair` (a) ` が関数であるような関数 tagpair が必要であるとします。

    (b,c) |➙ ((a, b), (a, c)).

  もちろん、我々は簡単に書くことができます

    let tagpair = λ(b, c) . ((a, b), (a, c)).

  ここで、方程式を設定することなく、型定義アルゴリズムがこの宣言にどのように取り組んでいるかを説明することができます。
  まず、 `a`、 `b`、および `c` に "未知" の型(すなわち、型変数) `α`、 `β`、および `γ` を割り当てます。
  次に、 `((a, b), (a, c))` は `(α ☓ β) ☓ (α ☓ γ)` 、λ式は `β ☓ γ ➙ (α ☓ γ) ☓ (α ☓ γ)` と型付けされます;最後に　tagpair

    α ➙ (β ☓ γ ➙ (α ☓ β) ☓ (α ☓ γ) )     (*)

  (型方程式は `a`、 `b`、 `c` の型に制約を課していません)。

  しかし、(埋め込まれた)関数を使用して、タグペアを定義する別の方法を検討してください

    #: (α ➙ β) ☓ (γ ➙ δ) ➙ ((α ☓ γ) ➙ (β ☓ δ))

  ` (f # g) (a, c) = (f (a), g (c))` とペアリング関数

    pair : α ➙ (β ➙ (α ☓ β) )

  <!-- 354 7/28 -->

  `pair (a) (b) = (a, b) ` となるようにします。
  我々は以下のように書くことができます

    let tagpair write = λa. (let tag = pair (a) in tag # tag)

  次に、 well - typing アルゴリズムが次のように進むことが期待されるかもしれません。
  まず、 `α` に `a` を代入します。
  次に、ジェネリック型の `pair` を使用して、 `pair(a)` は `δ ➙ α ☓ δ` を取得します。
  これをローカルのジェネリック型のタグとして使用し、 `tag # tag` の `tag` の 2 つの出現にはそれぞれ `β ➙ α1 ☓ β`、 `γ ➙ α2 ☓ γ` を割り当てます。
  `#` の出現にはジェネリック型のインスタンスが割り当てられます(新しい型変数を使います)。そして、関数適用の型方程式は型

    β ☓ γ ➙ (α1 ☓ β) ☓ (α2 ☓ γ)

  タグ `#` タグとλ式の本体に代入され、タグペアがその型を取得する

    α ➙ (β ☓ γ ➙ (α1 ☓ β) ☓ (α2 ☓ γ)).  (**)

  `(*)` と `(**)` を比較すると、何かが間違っていました。 2 番目の型はあまりにも一般的です。
  問題は、タグおよびその一般的な型がλ束縛変数 a およびその型 `α` に依存し、λ束縛変数の異なる束縛出現が異なる型を持つことを許さないことです。
  実際、型に関する限り、 tagpair が 3 番目の方法で定義されているのと同じようになるはずです。

    let tagpair = λa . (pair(a) # pair(a))

  読者は、この場合、期待される型 `（*）`を（例1のようないくつかの方程式を設定することによって）得ることができます。

  解決策は幸運にも簡単です。
  let または letrec によってバインドされた変数の型をインスタンス化する際に、それを宣言します。
  包括的なλ束縛(または仮パラメータ束縛)の型には存在しない型変数だけがインスタンス化されるかもしれません。
  このようなインスタンス化可能な変数(ジェネリック型)はジェネリック型変数と呼ばれます。

  今度は tagpair の 2 番目の定義では、ローカルに定義されたタグがジェネリック型 `δ ➙ α ☓ δ` を取得しました。ここで `δ` は一般的ですが `α` は一般的ではありません。
  したがって、タグは、タグの出現に型を割り当てる際にインスタンス化されていてはならず、 `(**)` は `(*)` と同一であったはずです。
  この例は少し工夫されているように見えるかもしれません。確かに、我々の経験は、ほとんどの場合、ジェネリック型の型変数のすべてが一般的なものか、まったく共通なものではありませんでした。
  しかし、例外を排除する簡単な構文上の制約はなく、そうすることも望ましいとは思われません。

  これらの例から、それぞれ let (または letrec) とλによってバインドされた変数を入力するためのルールが異なることが明らかになります。
  したがって、 2 つの式に対する我々の意味論

    let x = e in e’;    (λx . e’)e

  (そして等価であるかもしれませんが)前者に正しく型を割り当てることは可能かもしれませんが、後者には正しく型を割り当てることはできません。
  例はペアです

    let I = λx . x in I(I);    (λI . I(l))(λx. x).

  <!-- 355 8/28 -->

  これに対する部分的な直観は、λ抽象化が引数なしでしばしば起こることがあることです。上記の 2 番目の式は明示的な引数-`(λx . x)`-が存在するという点で、抽象化の特別な(むしろ不要な)使用を含んでいます。
  let 構文は(変換されると)抽象化のこの制限された使用を伴うので、型割り当ての規則がそれほど制約されないことは不自然ではません。
  コンパイラはもちろん、 ` (λx. e’) e` のすべての明示的な出現をあまり制約のない方法で扱うことができます。

  λ-束縛(すなわち、仮パラメータ束縛)と束縛との間の相互作用における型の処理は、実際に我々のアプローチの中核です。
  これは、無関係の変数として囲む手続きの仮パラメータを含むかもしれない手続きの非グローバル宣言の一貫した扱いを提供します。
  これは多相性の重大な困難の 1 つと思われるため、難易度に無関係な可能な限り除外する簡単な言語 (Exp) の観点から分析を提示することが正当だと考えています。

  読者は、我々の規則が任意に選択され、直感によって部分的にしかサポートされていないと感じるかもしれません。
  規則が唯一のものであるとは確かには言いませんが、後で与えられる結果は意味的に正当化されていることを示しています。
  実際には、正しい型の割り当てを認めるプログラムは、型エラーのために実行時に失敗しないか、より正確には、そのセマンティクスでコード化された型制約が常に満たされることを示します。
  このことから、コンパイル時の型検査(すなわち、正しい型割当てを発見しようと試みる)は実行時に型を持たせる必要がなくなり、実装の効率が明らかに向上します。

  これはもちろん、コンパイル時型検査の主な目的です。もう 1 つは、プログラミングエラーの早期検出です(その多くが不正プログラムの原因となります)。
  我々の業績は、多相型を含むように型検査を拡張することです。
  さらに、最終的な形式(第 3 節のアルゴリズム 1) の型検査アルゴリズムは、構文型健全性定理の証明が正しいとしても正しい型割り当てを生成することはかなり面倒であると述べているが、非常に単純です。

  我々は、システムでうまく型付けできるプログラムのクラスの独立した特徴付けをしたいと思いますが、これを行う方法はわかりません。
  しかし、我々はいくつかの指針を与えることができます。
  レフリーの提案では、 Burge [l、 Chapt。 3] データ構造を処理するための一般的な関数に関します。
  そこにあるすべての関数(我々が調べなかった 3. 11 節を除く)は、 2 つの点で修正された ML 型チェッカから期待される型を取得しました。
  第 1 に、 Burge は、不連続和型とその被加数型の間の強制関数を暗黙のうちに残します。これらを明確にする必要がありました(この点は序文で言及されています)。
  次に、 Burge によって使用される再帰型定義を定式化するために、 ML 抽象型構文(例として第 5 章を参照)を使用しました。
  この構文では、定義された抽象型とその表現の間の同型写像は明示的に行われ、明示的に使用されなければなりません。
  この要件の必要性を見るために、αストリームの場合を考えてみましょう。これは、αとαストリームからなるペアを生成する関数であると定義されています。
  型方程式

    α-stream = - - - ➙ (α ☓ α-stream)

  (無限型表現を許さない限り)単一化によって解決することはできません。

  <!-- 356 9/28 -->

  しかし、方程式を同型写像として扱い、 2 つの関数を使って抽象型とその表現の間で前後に変換することで、この困難は取り除かれます。
  我々は、この解決策が抽象的な型の概念に従っていると主張しています(例えば [8] 参照)。

  否定的な側面では、間違いなく型付けすることができない便利な式がありますが、それらがなければどれほど煩わしいのかははっきりしていません。
  明白な例は、カリーの `Y` コンビネータです。

    Y = λf.(λx.f(x(x)))(λx.f(x(x)))

  自己適用は我々のために型付けされていないからです。
  しかし letrec は `Y` の必要性を避けています。
  より具体的には、

    let F(f) = λ(a, b). (f(a),f(b))

  議論の対象となるかもしれない - 異なる型の a と b で動作するのに十分な多相型である関数を引数として受け入れるべきです。
  例えば、

    F(reverse)(x, y)

  `x` と `y` が異なる型のリストである場合、異なる型の逆のリストのペアを生成します。
  我々のシステムでは、このような `F` の使用を拒否します (a と b には同じ型が必要です)。しかし、

    let reversepair = λ(x, y) . (reverse(x), reverse(y))

  または `F` の関数引数の他の特殊化を含みます。

  この例ではシステムの主な制限が示されていますが、明示的な型パラメータを使用せずに可能な限り柔軟に対応している可能性があります。
  これらが導入されると、型の型の問題が発生します。レイノルズ [12] はこの問題を解決するためにいくつかの進歩を遂げましたが、回避しながらどれだけ多くのことができるのかが目に見えていました。

## 3. 簡単な応用言語とその型
## 3.1. 言語拡張

   `x` は以下のように識別子であるとします。

     x ∈ Id

   次に、式言語 Exp は次の文法によって生成されます:

    e ::= x | (e e’) | if e then e’ else e” |
          λx.e | fix x.e | let x = e in e’.

  ここで `(e e')` は関数適用を意味し、 `fix x . e` は `λx . e` の不動点を表します。最後の節は `e'` の中で `e` の値を `x` に束縛します。
  `d` 、 `e` 、 `f` を主に接尾辞で `Exp` の範囲で使用することがよくあります。
  定数は省略されています。初期環境では、特定の識別子のための標準的なバインディングを想像することができます。

  <!-- 357 10/28 -->

  実行時の失敗の検出に対応する値 "wrong" を含む `Exp` の通常の意味論的セマンティクスを与えます。
  この小さな言語では、唯一の失敗は、条件の条件としてのブール値ではない値の出現と、関数適用の演算子としての関数ではない値の出現です。

  我々のセマンティックドメインは完全な部分的順序 (cpos) とみなすこともできます。cpo `D` ([9]を参照) は (a) 最小要素 `⊥D` が存在し、 (b) `D` のすべての有向サブセットが、 `D` 内で最小の上限を有するような、部分的に順序付けられた集合です。
  与えられたように基本ドメインのセット `{Bi}` を取り、 3 つの要素の真理値ドメインである `B0 = T` を取ります

    true    false
       \     /
         ⊥T

  再帰的に以下を定義します

    V = B0 + B1 + ... + F + W    (disjoint sum of domains, with
                                  ⊥V adjoined as minimum element),
    F = V ➙ V                    (continuous functions from V to V),
    W = {・}                      (error).

  このような一連のドメイン方程式の解(同型まで)は、 Scott [15] によって保証されています。
  彼は完全な格子で作業しましたが、解は cpos にも存在します (Plotkin [11] を参照)。

  セマンティック関数は、環境の領域である `Env = Id➙V` で、 `ε∈ Exp➙Env➙V` です。
  `η` を使って `Env` を範囲指定します。
  `ε` を定義する際には、後で、 Scott と Strachey [16] のよく知られた表記法を使用します(この例では `D` は `V` のいくつかの要約):

    (i) `d ∈ D` の場合、 `V` の `d` は、 `V` の `D` の注入の下での `d` のイメージです。

    (ii) `v ∈ V` ならば、

      v ⁅ D == true     if v = d in V for some d ∈ D,
            == ⊥T      if v = ⊥V,
            == false    otherwise.

    (iii) `v ∈ V` ならば

      v | D == d      if v = d in V, for some d ∈ D,
            == ⊥D    otherwise.

  <!-- 358 11/28 -->

  環境 `η' = η{v/x}` は `η'(x) = v` を除いて `η` と同じです。
   `V (・∈ W) `の値 `・` は "wrong" と書かれます。
  条件付き関数 `COND ∈ T➙V➙V➙V` が必要で、ここで `COND ∈ T➙V➙V` は `t➙v` かつ、 `v'` と書かれ、以下の値を取ります:

    v     if t == true,
    v'    if t == false,
    ⊥V   if t == ⊥T.
 
## 3.2. Exp のセマンティック方程式

  これらの方程式では、 `[| |]` は構文的な引数を示します。


    ε[|x|]η = η[|x|]
    ε[|e1 e2|]η = v1 ⁅ F ➙ (v2 ⁅ W ➙ wrong, (v1 | F)v2),
                     wrong
                  where vi is ε[|ei|]η            (i = 1,2).
    ε[|if e1 then e2 else e3|]η = v1 ⁅ B0 ➙ (v1 | B0 ➙ v2, v3), wrong
                          where vi is ε[|ei|]η    (i = 1,2,3)
    ε[|λx.e|]η = (λv・ε[|e|]η {v/x}) in V
    ε[|fix x.e|]η = Y(λv.ε[|e|]η{v/x})
    ε[|let x = e1 in e2|]η = v1 ⁅ W ➙ wrong, ε[|e2|]η{v1/x}
                         where v1 = ε[|e1|]η.

#### ノート

  (i) `Y` は最小の不動点演算です。
  多くの言語では、 `fix f ・ e` の `e` は抽象 `λy. e’` に制限され、

    let f = fix f . (λy . e’)

  は以下の構文を受け取るかもしれません

    let rec f(y) = e’

  (ii) `"let x = e1 in e2”` は `ε` と同じ意味を持ち、 `"(λx . e2) e1"` です。
  しかし、我々の目標の一部は、最初の形式で特定の式を認めるとともに、 2 番目の形式への変換を拒否する型の規律です。 これは、λ抽象は一般に明示的なオペランドなしで発生する可能性があり、より注意深い処理が必要なためです。

  (iii) テスト `"v2 ⁅ W"` は `e2` の意味が `⊥V` であれば `(e1 e2)` の意味は `⊥V` であることを保証するため、 `(e1 e2)` のセマンティクスは call-by-value に対応します。
  このテストの省略は、call-by-valueのセマンティクスを提供する(同様のテストは let 構文のセマンティクスでは省略することができる)。この場合、セマンティック健全性定理は等しくなります。

  <!-- 359 12/28 -->

## 3.3. 型の議論

  ここで概要を説明します。
  型と呼ばれる新しいクラスの式を定義します。型を持つ値が意味するものを言います。
  いくつかの値は多くの型を持ち、ある型は全く型を持たません。
  実際、`間違っている`には型がありません。
  しかし、関数的な値が型を持っていれば、適切な種類(型)の引数に適用されている限り、結果の正しい種類(型)を生成します。これは "間違っていてはいけません"！

  ここでは、大まかに言えば、 Exp 式は(適切な環境で)型を持つ値を評価し、間違っていないことを示すことができます。
  事実、表現がこの堅牢な品質を持つという十分な構文条件を与えることができます。条件は、式が環境に関して"適切な型付け"を持つということだけです。つまり、ある種の法則を満たす方法で、その型とそのすべての部分式に型を割り当てることができます。

  したがって、型割り当ての法則が与えられると、主に 2 つのタスクがあります。
  第一に、法的型割り当てを持つ式(またはプログラム)が`間違っていない`ことができないことを示すことは、このセクションで取り組まれています。驚くべきことに、少なくとも応用言語の場合は、より簡単な作業です。
  第 2 の課題は、型情報が不完全なプログラムが与えられた場合、法的な型割り当てをディスクールすることです。
  このタスクは、しばしば型検査と呼ばれます。もちろん、この項は、指定された型の割り当てが合法であることを検証することだけを意味することもできます。実用的な状況では、プログラマがすべての部分式に型を付けることを期待できないので、おそらく両者の間に何かが必要です。
  セクション 4 では、与えられたプログラムのクラス型(クラスは無限大ですが、多相性を認めます)を見て、成功すれば正しい型の割り当てを行うアルゴリズムを与えます。
  後者が存在する場合、アルゴリズムは、他の法的型の代入が代入の型(型変数の型を代入すること)であるという意味で、最も一般的なものを見つけ出すと推測します。

## 3.4. 型とその意味

  型の構文は次のとおりです。

  (1) `ι0`、 `ι1`、...は(基本)型です。 `Bi` ごとに 1 つ。

  (2) 型変数である、無数のセットがあります。
  我々は、型変数の範囲を決めるために `α`、 `β`、 `γ`、...などを使います。

  (3) `ρ` と `σ` が型であれば `p ➙ σ` も同様です。

  単相型は、型変数を含まない型です。
  我々は単相型の範囲を決めるのに `μ`、 `ν`、 `π`、...を使います。
  ある型に変数が含まれている、あるいは含まれていることを暗示したいときは、 多相型(polytype) という単語を使用します。

  我々は最初に単相型のセマンティクスを与えます。 つまり、我々は値 `v ∈ V` は単相型 `μ` を有し、これは `v :μ` と書きます。

  (i) `v = ⊥V` または `v ⁅ Bi` ならば、 `v : ιi`

  (ii) `v = ⊥V` もしくは `v ⁅ F` かつ ` (v | F) u :ν` で常に `u :μ` ならば `v :μ➙ν` です。

  <!-- 360 13/28 -->

  多くの値に型がないことは明らかです。
  例は次のとおりです

    wrong, (λv ∈ V . wrong) in V,
    (λv ∈ V . v ⁅ B0 ➙ (v | B0, ➙ x in V, y in V), wrong) in V
      (where x ∈ B1, y ∈ B2, for example).

  しかし、最後の例で `y ∈ B1` ならば、関数は `ι0 ➙ ι1` という型を持ちます(他にはありません)。

  いくつかの値には多くの型があります。 アイデンティティ関数

    (λv ∈ V . v) in V

  たとえば、 `μ` ごとに `μ ➙ μ` という型があります。
  もちろん、 `⊥V` にはあらゆる型があります(すべての型を持つ唯一の値です)。

  この型の概念は、 Scott [17] に由来します。
  実際、スコットが機能性をカレーの後に呼んでいるのは、それが退去という概念とは異なるものです。
  一時的に値を持つ型の値を持つ型を識別すると、その型が下向きに閉じられ、指示されたことが完全であることを示すことは容易です

  (i) `∀ v, v ’ ∈ V. (v : μ and v ’ ⊑ v) ⇒ v ’ : μ`、

  (ii) `V` の各有向部分集合 `X` に対して、`(∀ v ∈ X. v : μ) ⇒ ∐ X : μ`。

  後退は 2 番目のプロパティを共有しますが、最初のプロパティは共有しません。
   最近、 Shamir と Wadge [18] は、これらの 2 つの特性を持つ任意の集合を型として定義し、 'v '型で値 'v 'を特定した結果を調べる。 v '⊑ v } `。

   ポリ型のセマンティクスは次のとおりです。
   まず、 `ρ⩽σ` を使って、型変数に型を代入することによって `σ` からρを得ることができることを意味します(`⩽`は明らかに反射的で推移的です)。
   例えば、

    μ ➙ ⩽ α ➙ α ⩽ β ➙ β ⩽ α ➙ β

   だけど

     α➙β/⩽β➙β(α=βの場合を除く)。

   次に、

    v : σ iff ∀μ ⩽ σ.v : μ.

   例えば、

     (λv。 v) をV :α➙αとします。

  それによって、ポリ型も `V` のサブセットを表し、これらもまた完全に向けられています。
  読者は、最も外側に普遍的に定量化されているように、ポリ型の各型変数を考えることができます。 例えば、

     α➙α "は"Vα. α➙α "を意味し、

  結合されたαは単一型に及びます。
  実際、これは、ここでは `α` は単項型(すべての型ではない)と、式のような式を認めないからです

    (∀α . α ➙ α) ➙ (∀α . α ➙ α) 


  結合型変数が単型以上の範囲にあるとすれば、それらが型のより豊かな概念の中で Reynolds [12] の困難(また興味のあるもの)を避けることを意味することがわかります。

  <!-- 361 14/28 -->

  我々の定義からすぐにわかる、以下の単純なプロパティが必要です。

#### 命題 1. `v : σ` と `τ⩽σ` の場合、 `v :τ`。
#### 命題 2. `v : σ ➙ τ` と `v :σ` の場合、 ` (v | F) v ':τ`。

  いずれの場合も、モノ型の特性はポリ型に持ち上げられます。

## 3.5. 型割り当て

  よく型された式が`間違っていない`という定理の根拠を準備するためには、式を型することによって何を意味するのかを定義する必要があります。
  式の自由変数に型を与える型環境の概念がまず必要です。

  接頭辞 `p` は、メンバーが `let x`、 `fix x`、または `λx` の形式を持つ有限のシーケンスです。ここで `x` は変数です。
  接頭辞付きの式 ` (pe) `の形式は `p` です。 `e` にあり、 `e` で空いているすべての変数は `p` のメンバにあります。
  接頭辞のメンバーをピリオド`(.)`で区切ります。

  すべての `pe` は、次のように sub - `pe` を与えます。
  推移的反射的閉包と一緒に:

    (i) p | x はそれ自身を除いてsub -pe を持たず、
    (ii) p | (e e ') にはsub -pe のp |があります。 e とp | e '、
    (iii) p | (もしe ならe 'else e ") はsub -pe のp | e、 p | e 'とp | e "、
    (iv) p | (λx ・e) はsub -pe p を有します。 λx | e、
    (v) P | (fix x。 e) にはsub -pe p があります。 x を修正する| e、
    (vi) p | (e 'のx = e とする)は、sub -pe のp | e およびp。 x | e '。

  たとえば、λ y | (fy) に f =λ x (xy) を代入する)に sub - pe を(それ自体のほかに)

    λy | λx. (xy) ,      λy. λx | (xy) ,   λy. λx | x, λy. λx | y,
    λy. let f | (fy) ,   λy. let f | f, λy. let f | y

  sub - pe は、それを囲むすべての変数バインディングの接頭辞の部分式に過ぎません。
  上記のλ x。 (x、 v) は let f で囲まれていないことに注意してください。このバインディングの範囲にはありません。

  メンバーは、 p の右側に x が出現しない場合、 p の x またはλ x を固定したメンバーが p 内でアクティブであると言います。

  今、 pe p の型入力| e は、 p の各要素への型の割当てであり、各部分式と各λ x、 fix x、 または e を x とし、部分式 (e の x = e 'とする)には同じ型 x と e 'を代入するように割り当てられます。
  このように、図示された pe の 1 つの型付け(それは、後に定義される意味では、ほとんど、しかしかなりではないが、よく型する)は以下の通りです。


    λy_ α | let f_ ((α➙β) ➙β) = (λx_ (α➙β) (x_ (α➙β) y_α) _β) _ ((α➙β) ➙β) in (f_ ((α➙γ) ➙γ) y_α) _γ) _γ.

  我々は、 p | e by p 〜| e 〜、または p 〜| e σ〜 e 自身に割り当てられた型σを示したいとき。

  <!-- 362 15/28 -->

  任意の p 〜| e 〜、および任意の束縛は、 p 〜または e 〜のいずれかに x σを入れ、任意の囲みλ y τまたは fixy τに出現しないσの型変数であり、束縛は束縛 letxσ。
  上記の例では、βは一般的なものですが、αは束縛のためにはありません。 (ααββ) ➙β)。
  直感的に、バインディング letx σのジェネリック型変数は、 x を使用できる型の自由度を表します。 それらは x の局所多相型を表します。
  λまたは拘束の束縛が letx σを囲んでいない場合、σのすべての型変数は総称であることに注意してください。
  σの大域的インスタンスは、一般的な型変数のみがインスタンス化されるσのインスタンスです。

  技術的な理由から、一般的な型変数が制御された方法で発生することが必要です。
  p 〜|と言います。 d 〜はすべての型付きサブペアに対して標準です。 p '〜| 各メンバーのジェネリック型変数は、 p '〜の x σを p '〜|にはどこにも置かないようにします。 d '〜。
  したがって、特に、 e σ '〜の中の x ρ= e ρ〜が部分的な d - の型である場合、ρの一般的な型変数は e σ'〜には出現しないかもしれません(もちろん e ρ〜でなければなりません)。

  ここで、 well - typed (wt) pe の概念を次のように定義します。

    (i) p 〜| x τは、標準であれば wt であり、
       (a) λxτ、 またはfixx τがp 〜でアクティブである、または
       (b) x σはp 〜で有効であり、τはσの一般的な例であるとします。
    (ii) p 〜| (e ρ〜e σ '〜)_ τはwtf です。 e 〜とp 〜| e '〜はwt であり、ρ=σ➙τです。
    (iii) p 〜| (e ρ〜thene ρ '〜elsee ρ' ') _ τ'は、 e 〜、p 〜| e '〜p | e "〜は全てwt、 ρ=ι0、 σ=τ=τ 'です。
    (iv) p 〜| (λxρ、 ρρ) _ τはwtf です。 e 〜はwt であり、τ=ρ➙σです。
    (v) p 〜| (fixxρe ρ〜)_ τは、次のようになります。 e 〜はwt であり、ρ=σ=τです。
    (vi) p 〜| (x ρ=e ρ〜e σ '〜)_ τはwtf です。 e 〜とp 〜。 x ρ| e '〜は両方ともwt であり、σ=τです。

  この再帰的な定義はいくつかの証明には有用ですが、 wt の別の特徴付けが有用な場合もあります。
  次の命題の証明はかなり簡単です。それを省略します。
  wt p 〜| 簡単な構造誘導によって、必然的に標準です。

#### 命題 3. p 〜| d 〜 a は、以下の条件が満たされる場合には、 wt です。

  (A) 標準です。

  (B) すべての(バウンド)オカレンス x σについて、対応するバインディング発生は、λ xσ、 OY fixxσ、 または letx σのいずれかであり、σはτの一般的なインスタンスです。

  (C) 次の条件は、 d 〜のすべての部分式(誘導型入力)

      (eρ~ eσ'~)_τ                       ρ = a ➙ τ,
      (if eρ~ then eσ'~ else eτ"~)_τ'    ρ = τ0 and σ = τ = τ’,
      (λxρ . eσ~)_τ                      τ = ρ ➙ σ,
      (fix xρ . eσ~)_τ                   ρ = σ = τ,
      (let xρ = eρ~ in eσ'~)_τ           σ = τ. 

  <!-- 363 16/28 -->

  したがって、上に示したタイピングは、 1 つの理由だけでは重くはなりません。
  部分表現 ` (f_ ((α➙γ) ➙γ) _γ` は、命題 3 の条件 (C) の最初に違反します。
  別の例を考えてみましょう。
  以下は (p 〜空で)よく型されたものです:

    let I_(α➙α) = (λxα.xα)_(α➙α) in
      (I_((ι➙ι)➙(ι➙ι)) I_(ι➙ι))_(ι➙ι) .

  αは、 I の宣言の型α➙αにおいて一般的であるため、 I の結合された出現の型においてインスタンス化される(おそらく異なってもよい)ことに留意されたい。

  let によって宣言された変数に対して、 generic 型変数のみをインスタンス化する必要性を説明するために、λ xα. x βでは、命題 3 の条件 (B) によってα=βを持たなければならないことに注意してください。
  確かに、我々は以下のようにこれを直感的に議論することができます:

    let I = λx . x in ...,

  この宣言の範囲内にある式 (Ie) のすべてが、部分式 e と同じ型を受け取るようにしたいと考えています。
  しかし、今では(割り当てられた型で)

    let I_(α➙β) = (λxα . (let yα = xα in yβ)_β)_(α➙β) in ...

  それは意味的にはより単純な宣言と同等であるから、α=βを再び要求しなければならません。
  しかし、このことは、型定義の定義に課されています。なぜなら、αは束縛 y αの一般的なものではないから、 y の束縛された出現ではインスタンス化されない可能性があるからです。

## 3.6. 置換

  置換 `S` は型変数から型へのマップです。
  `S` は、型から型、型付き型から型付き型などにマップを生成する自然な方法で拡張することができます。
  `S` は、 S α≠αの場合には変数αを、β≠α、 α∈ S βの場合には型変数αを含むと言います。
  (α∈τはτにαが生じることを意味します)
  この論文の後半では、置換を広範囲に必要としていますが、現在のところ、置換と wt に関連するプロパティは 1 つだけ必要です。

#### 命題 4.

  S が wt p 〜|の一般的な変数を含まない場合、 d - とすると、 S (p - | d -)も wt です。

#### 証明

  まず、 S の仮定は、 S (p 〜| d 〜)の各束縛に対する一般的な変数が p 〜| d 〜。
  βが一般的でない場合、 S βは一般変数を含まないので、 S (p 〜| d 〜)は標準です。

  第 2 に、 x σがλ x σに束縛されている場合、または x σを p_ | d 〜であれば、 xs σはλ xs σに束縛されるか、または S (p 〜| d 〜)に xs σを固定します。
  x σが letx τであり、σ= [ρ1/α 1、...、α n/α n] _ τである場合、α i はτの総称変数であり、 S (p - | d -)では xs σは let xs τであり、 S σ= [Sρ1/α 1、...、 Sρn/α n] (Sτ) は S τの一般的な例です。

  第3に、命題3の条件（C）は、S（u➙τ）=Sσ➙Sτのようなアイデンティティを用いて、S（p〜| d〜）に対して容易に検証される。 ■

  <!-- 364 17/28 -->

## 3.7. よく型付けされた式は間違っていない

  まず、セマンティック環境ηと型環境の間に単純な関係が必要です。
  我々は言う

  η は、 p〜、 η[| x |]:ρにおいて、xρ、 λxρ、 またはfixx ρが活性化されるときは常にp 〜iff を尊重します。

#### 定理 1 (意味的健全性)。 ηが p 〜と p 〜|を尊重すれば、 τ[| d |]η:τです。
#### 証明

  かなり単純な構造誘導。 6 つの場合を d τ〜とします。

    (i) xτ。
    次に、λx τまたはfixx τのいずれかがp 〜でアクティブであり、η[| x |]:τ、 したがってε[| x |]η:τ、 またはx σがp 〜 σ; しかし、命題I によると、ε[| x |]η=η[| x |]:τです。

    (ii) `(e_ (σ➙ττ) e σ〜)_τ` となります。
     次にp 〜| ε[| x |]η:σ➙τであり、同様にε[| e '|]η:σです。
    次に意味論的方程式(間違った型がないことを覚えている)から命題2 によって、ε[| d |]η:τを得ます。

    (ⅲ)(e0 0 〜e σ '〜elseeσ` 〜)。ここで必要とされる唯一の詳細は、⊥V があらゆる型を持つということです。

    (iv) (λx ρ・e σ〜)_ (ρ・σ・σ) です。それからp 〜。 λx ρ| e σは、wt です。ここで、V (ν[ε|] |η :ρ➙σ
    命題2 の逆は成り立ちません。すなわち、V をρ➙σで表すと、v :ρ、 fv :σが成り立つときは必ずしも必要ではありません。
    必要なのは、η➙➙ρ➙σσごとに、V :μ➙νにあることです。


  μ➙⩽ρ➙σをμと仮定します。次に、μ➙ν= S (ρ➙σ) のようなρとσの型変数のみを含む置換 S がある。
  そして、これらの型変数のどれもが p 〜・λ x ρ| e σ〜とすると、 S (p 〜)・λ x μ| S (e 〜) _ ν "は命題 4 によって重み付けされます。
  また、ηは、 S (p 〜)を尊重する (η[| x |]:σ '、 τ'⩽σ '、 η[| x |]:τ' { v/x }は S (p 〜)を考慮します。 λxμ。

  次に、ε[| e |]η{ v/x }:νとなるので、 v :μは fv :νを意味することを示しており、これは必要に応じて V :μ➙νで f をもたらす。

   (v) (fixxρ。 e ρ〜) _ρ。 それから p 〜。 x ρを修正する| e ρ〜は wt です。
  今、我々は v :ρを必要とします。

    v = Y (λv '、 ε[| e |]η(v ' / x) )。

  ここで v0 =∐ i、 vi、 v0 =⊥ V、 v_ (i + 1) =ε[| e |]η{ vi/x }、型の有向完全性によって、 vi :ρそれぞれ i。

  明らかに v0 :ρ。
  vi :ρと仮定します。
  ηを p とすると、η{ vi/x }は p 〜 fixx ρを尊重するので、主帰納仮説 v_ (i + 1) :ρも同様であり、終了します。

   (vi) (x = e ρ〜 e σ ' -) _ σとします。
  次に p 〜| e ρ〜は wt なので、すぐに v :ρを持ちます。ここで、 v =ε[| e |]ηです。 ε[| e '|]η (v/x) :σが必要です。

  今すぐ p ！・ letx ρ| σ{σ/x }はρ - ・ letx ρを尊重しています。 残りは誘導仮説に従います。 ■

  <!-- 365 18/28 -->

  結論として、

    ε[|d |]η ≠ wrong,

  が成り立ちます。なぜなら、間違った型はないからです。

## 4. 型の良いアルゴリズムとその正確さ
## 4.1. アルゴリズム W

  このセクションでは、プレフィックス付きの式の型指定を見つける問題に取り組んでいます。
  このためにアルゴリズム W を提示します。
  W が構文的に健全で(ある意味では)完全であることを証明したいと思います。
  統語的な健全性によって、 W が成功するたびに wt を生成することを意味します。 完全性によって、 W が存在するときはいつでも、 W は(ある意味では)少なくとも一般的なものを見つけることに成功することを意味します。

  W はおそらく完成していますが、簡単な証拠を見つけるのは難しいです。
  だから、健全性に集中し、 W の実装についてコメントし、より豊かな言語に対応するように W を拡張します。
  W をシミュレートする型検査アルゴリズムは、 LCF メタ言語 ML [2] の文脈でほぼ 2 年間正常に動作しているため、その完全性のために、その有用性がある程度証明されています。

  W は Robinson [14] の単一化アルゴリズムに基づいています。
  確かに、単一化の枠組みのなかに直接入っていない井戸型の唯一の特徴は、 x τが letx σに束縛されるときはいつでも、τがσの一般的なインスタンスでなければならないという条件です。
  W の完全性(ある意味では)は、単一化に関する次の命題の第 2 部から続くべきであるが、 W が健全であるという証拠の前半だけが必要です。

#### 命題 5 (ロビンソン)

  アルゴリズム U があります。一対の式を(変数のアルファベットを超えて)取って代入を行います。つまり、式σとτの任意の組

  (A) U (σ、 τ) が成功して U を生じると、 U はσとτを統合します(すなわち、 U σ= Uτ)。

  (B) R がσとτを単一化するならば、 U (σ、 τ) は、ある置換 S に対して R = SU となるように U を生み出します。

  さらに、 U はσとτの変数のみを含みます。

  完全なプログラム f の正しい型を見つけるために、 let バインディングだけを含む型付き接頭辞 p 〜を与えて、あらかじめ定義された識別子にバインドされた値の型を与えることが期待されます。
  次に、 W が、 p 〜| f 〜は wt です。

  しかし、 W を再帰的に宣言するためには、すべての型の束縛を含む接頭辞が出現し、 W は一般にプログラムに課せられた制約を満たすために接頭辞中の非行型変数を変更する必要があります。
  したがって W は W を必要な変換を表す代用 T にも戻します。

  <!-- 366 19/28 -->

  正確には、 W (p 〜、 f) が成功し、 (T、 f 〜)を返すと、 (T p 〜)| f 〜は wt です。

  我々はまず W を述べます。
  ある点では、以前に発生しなかった型変数が必要です。 そのような新しい型変数は、βまたはβ i によって示されます。
  W (p 〜、 f) は、 f の構造上の誘導によって定義されます。 このアルゴリズムは、後で提示するより効率的なアルゴリズムとは対照的に、純粋に応用的なプログラミングスタイルで表現されています。これは、命令プログラミングのスタイルでより多く表現されています。

#### アルゴリズム W

  `W (p ~,f) = (T, f~)`, ここで

  (i) f が x のとき:

    もし λxσ, または fix x σ が p ~ 内でアクティブならば
      T = I, f ~ = xσ;
    もし let x σ が p ~ 内でアクティブならば
      T = I, f ~ = x τ
    ここで τ = [Bi /αi] σ, αi がσのジェネリック変数,
    かつ βi は新しい変数。

  (ii) f が (de), ならば:

    let (R, d ρ~) = W (p ~,d) , かつ (S, e σ~) = W (R p ~, e) ;
    let U = U (Sρ, σ ➙ β) , β が新しい;
    ならば T = USR, かつ f ~ = U (((S d ~)e ~)_β) .

  (iii) f が (if d tha e else e’), ならば:

    let (R, d ρ~) = W (p ~, d) かつ U0 = U (ρ, ι0) ;
    let (S, e σ~) = W (U0 R p ~, e) , かつ (S’, e_ (σ') '~) = W (S U0 R p ~, e’) ;
    let U = U (S ' σ, σ’) ;
    ならば T = U S ’ S U0 R, かつ
         f = U ((if S ' S U0 d ~ then S ' e ~ else e ’~)_σ) .

  (iv) f が (λx. d) ならば:

    let (R, d ~) = W (p ~ . λxβ, d) , ここで β は新しい;
    ならば T = R, かつ f ~ = (λxRβ. d ρ~)_ (Rβ➙ρ) .

  (v) f が (fix x. d) ならば:

    let (R, d ρ~) = W (p ~ . fix xβ, d) , β は新しい;
    let U = U (R 　β, ρ) ;
    ならば T = U R, かつ f ~ = (fix xURβ. U d ~)_ (URβ) .

  (vi) f が (let x = d in e) ならば:

    let (R, d ρ~) = W (p ~, d) ;
    let (S, e σ~) = W (R p ~ . let xρ, e) ;
    ならば T = S R, かつ f ~ = (let xS ρ = S d ~ in e ~)_σ. ■

  <!-- 367 20/28 -->

## 4.2. W の健全性

  W が健全であることを示すために、いくつかの簡単な定義があると便利です。
  A が型、型付きの接頭辞、型付きの pe ならば

    Vars (A) ≝ {α | α ∈ A, α a type variable }.

  A が型付きプリフィックスまたは型付き pe の場合

      Gen (A) ≝{α| α∈A、 αはジェネリック型変数)。
     Spec (A) ≝Vars (A) - Gen (A) 。

  S が代入である場合、

    Inv (S) ≝ {α | S involves α}
           = {α | ∃β. S β ≠ β and α ∈ {β} ∪ Vars (S β) }.

  以下の単純な性質が必要です。その証明は省略します。

#### 命題 6.

    (A) Inv(RS) ⊆ Inv(R) ∪ Inv(S)
    (B) Vars(Sτ) ⊆ Vars(T) ∪ Inv(S).

#### 理論 2 (統語的健全性)

  `p~` を標準接頭語とし、 p | f a (閉) pe。
  このとき、 W (p、 f) = (T、 f τ〜)ならば、

    (A) T p~ | f~ は wt であり、

    (B) Inv(T) ⊆ Spec(p~) ∪ New,

   かつ

    (C) Vars(τ) ⊆ Spec(p~) ∪ New,

   ここで、 New は W によって使用される新しい型変数の集合です。

#### 証明

  f の構造上の誘導によって、 wt の再帰的定義を用います。
  条件式と修正式のケースは省略されています。新しい式はありません。最初に他のケースよりも簡単に扱います

  (i) f は X です。そして T = I であるので、 (B) は即時です。
  λxσ、 または fixx σが p 〜で有効である場合、 f 〜= x σであり、 (A)、 (C) は即時です。

  letx σが有効な場合、τ= [βi/α i] σ、 {α i }はσで一般的であり、 New = {β i }です。
  そして、 T p 〜| f 〜= p 〜| x τは標準であり、 (A)、 (C) は容易に従います。

  (iv) f は (λx ・ d) です。 新しい変数 New1 を使って (R、 d ρ〜)= W (p 〜。λ xβ、 d) とします。

  <!-- 368 21/28 -->

  誘導により、 R (p 〜λ xβ) | d ρ〜は wt であるから、 (A) f 〜= R p 〜| (λxRβ、 d 〜) _ (Rβ➙ρ) は wt (重量％)です。
  誘導によっても、

    Inv(R) |
    Var(ρ) | ⊆ Spec(p~ ・ λxβ) ∪ New,
             = Spec(p) ∪ {β} ∪ New,
             = Spec(i) ∪ New     (since New = New1 ∪ {p})

  T = R であるから (B) が続きます。 (C)

     命題6 によるVars (Rβ➙ρ) ⊆Inv (R) ∪{@ U Vars (p)
                   ⊆Spec (p) ∪New
   要求に応じて。

   (vi) f は (x = d で e とする)。
   次に、新しい変数 New1 を使って、 (R、 d ρ〜)= W (p 〜、 d) としましょう。
   その後、誘導によって

    R p ~ | d ~ is wt (1)

    Inv (R) |
    Vars (ρ) | ⊆ Spec (p ~) ∪ New1 (2)

  今 (2) から

     Spec (R p 〜)⊆Inv (R) ∪Spec (p 〜)
                ⊆Spec (p 〜)∪New1 (3)

  (1) 標準から

    Gen (R p ~ | d ~) ∩ Spec (R p ~) = ∅.                   (4)

  また、 Gen (R p 〜)= Gen (p 〜)は、 Vars (ρ) と (2) で分かれているため、 R p 〜・ letx ρが標準的な接頭辞です。

  よって、新しい変数 New2 を使って S、 e σ〜= W (R p 〜 exρ、 e) とします。
  その後、誘導によって

    S(R p~ ・ let xρ) | e~ is wt                         (5)

    Inv(S)  |
    Vars(σ) | ⊆ Spec(R p~ ・ let xρ) ∪ New2             (6)

  しかし、 (6) と (4) をまとめると (New2 は新しい変数なので) Spec (R p 〜 letxρ) = Spec

    Inv(S) n Gen(R p~ | d~) = ∅

  命題 4 により、 S (R p 〜| d 〜)が wt であり、 (5) を用いて wt

    S R p~ | (let xSρ = S d~ in e~)_σ

  wt です。 しかし、これはちょうど T p 〜です。 我々は (A) を証明しました。

  <!-- 369 22/28 -->

  (B) については、

    Inv (T) ⊆Inv (S) ∪命題6 によるInv (R)
            ⊆Spec (p 〜)∪New1 ∪New2、 (6) 、(3) 、(2) を用いて、

  (C) については、同様の推論によって、

    Vars (σ) ⊆ Spec (p ~) ∪ New1 ∪ New2.

  この場合、 New = New1 ∪ New2 であるので、これだけで十分です。

  (ii) f は (de) です。
  新しい変数 New2 を使用して、新しい変数 New1 および (S、 e σ〜)= W (Rp 〜、 e) を使用して (R、 d ρ〜)= W (p 〜 ケース (vi) と同様の理由で、我々は

    S R p~ | S(dρ~) is wt                            (7)
    S R p~ | eσ~    is wt                            (8)

    Inv(S R)          |
    Vars(Sρ), Vars(σ) | ⊆ Spec(p~) ∪ New1 ∪ New2.  (9)

  ここで、 U = U (Sp、 σ➙β)、ここでβが新しい場合、命題 5 により、

    U Sρ = Uσ ➙ Uβ,                                  (10)
    Inv(U) ⊆ Vars(Sρ) ∪ Vars(σ) ∪ {β}.             (11)

  U は wt (7) と (8) の一般的な変数を含まず、

    U S R p~ | U(((S d~) e~)_β)

  wt です。 しかし、これはちょうど T p 〜です。 我々は (A) を証明しました。 (B) については、まず

    New = New1 ∪ New2 ∪ {β},

  そう

     Inv (T) ⊆命題6 によるInv (U) ∪Inv (SR)
            ⊆Spec (p 〜)∪New、 (9) と(11) から、

  (C) については、

     Vars (τ) = Vars (Uβ)
             命題6 によるInv (U) ∪{β}
             ⊆Spec (p 〜)∪New、 (9) と(11) から再び。 ■

## 4.3. W の実装。 簡略化されたアルゴリズム I

  置換はあまりにも頻繁に適用されるので、 W は全然効率的なアルゴリズムではありません。
  健全性を証明するために策定されました。
  ここでは正確な意味で W をシミュレートするより簡単なアルゴリズム I を提示します。

  <!-- 370 23/28 -->

  I は W と 2 つの点で違います。
  まず、置換が構成されているが、それが不可欠であるときにのみ適用される、解像度ベースの定理証明システムに関する文献に精通した考え方を採用します。
  第 2 に、実際に型タイピングアルゴリズムから実際に必要とされるのは、型の代入 f 全体ではなく、 f 自身に代入される型だけであるという事実を利用します。

  実際、 `I` は `E` という唯一の代入、すなわち `EE = E` を生成します
  つまり `β∈ Eα` ならば `E β=β` となります。
  この置換はプログラム変数(`E`と呼ばれる)でグローバルに `I` に保持され、 `I` は `E 'で変換されます。
  単一化関数 U の代わりに、 I は単一化手順 UNIFY を呼び出し、結果 UNICY を出力しますが、変数 E に影響します。
   `U` と `UNIFY` は、 `E` と `E` の次のような関係があると仮定します:コマンドの前後の `E` の値

    UNIFY(σ, τ)

   かつ、もし

    S(Eσ, Eτ) = U

   ならば

    E’ = U E.

  したがって、 E の存在下で型σおよびτに UNIFY を適用することは、型 E σおよび E τに U を適用することに対応します。 σとτは、`探索`置換 E を適用することによって得られる明示的な型を表す暗黙の型と考えることができる (E の等式は、さらなる解説が不要であることを意味します)。
  UNIFY (成功した場合)の効果は、新しい置換置換 E 'を生成することです。
  同様に、暗黙の型付きプレフィックス p 〜を扱います。これは、必要に応じて E を適用することで解説できます。
  私は局所変数ρ、 σ、 σ 'を持ち、それらの値は暗黙の型であり、その結果を第 4 の変数τで生成すると仮定します。

  初期冪等元 `E` を仮定すると、 `I` は型付き接頭辞 `p 〜`と ` `e p 〜 `が標準で` `p | f は `pe 'である(すなわち、 `f 'の全ての空き識別子は `p` に束縛されている)。
  アルゴリズムは次のとおりです。

#### アルゴリズム I

  I (p ~, f) = τ, ここで

  (i) f が x の場合、

    λx σまたはfixx σがp 〜で有効である場合、τ:=σ。
    letx σがp 〜で有効である場合、τ:= [βi /αi] E σここで、αi はE p 〜におけるletxE σの一般的な型変数であり、βi は新しい変数です。

  (ii) f が (de) ならば:

    ρ:= I (p 〜、d) 。 σ:= I (p、 e) 。
    UNIFY (ρ、 σ➙β) ; (βnew)
    τ:=β

  <!-- 371 24/28 -->

  (iii) f が (d ならば e else e 'なら)ならば、

    ρ := I (p ~, d) ; UNIFY (ρ, ι0) ;
    u := I (p ~, e) ; σ’ := I (p ~, e’) ;
    UNIFY (σ, σ’) ; τ := σ

  (iv) f が (λx、 d) の場合、

    ρ := I (p ~ ・ λxβ, d) ; (β new)
    τ := β ➙ ρ

  (v) f が (fix x ・ d) ならば、

    ρ := I (p ~ . fix xβ, d) ; (β new)
    UNIFY (β, ρ) ; τ := β

  (vi) f が (e の x == d とする)ならば、

    ρ := I (p ~, d) ; σ := I (p ~ . let xρ, e) ;
    τ := σ. ■

  I と W のシミュレーション関係は何ですか？
  それは、我々が健全性定理において遭遇したわずかな微妙なものを含む簡単な構造誘導であるため、省略した以下の命題によって単純に表されます。

#### 命題 7. p を| f は a pe であり、 E は等冪であり、 E p 〜です。 標準とします。
  このとき、W (E p 〜、 f) が成功すれば (T と fT を生成する)、 I (p 〜、 f) は成功します (τ 'と E の新しい値 E 'を生成する)。

    (A) E’ = TE,
    (B) E’T’ = τ.

  したがって、 I によって生成される型は、説明されるとき、 W によって F に帰される型です。

  実際には、 E は、これまでに例示された変数を表す変数型対のテーブル INST によって効率的に表されます。
  UNIFY の効果は、単にインスタンス化されていない変数のインスタンス化を表す INST にいくつかのエントリを追加することです。
  INST によって表される置換 E は、以下のように再帰的に与えられます

        E(ι) = ι      (basic types),
        E(α) = E(ρ)   if (α, ρ) ∈ INST for some ρ,
             = α      otherwise,
    E(σ ➙ τ) = Eσ ➙ Eτ.

  実際、 LISP で書かれた ML 用に実装された拡張バージョンでは、 INST 自体は型変数の (LISP の意味で) INSTANCE のプロパティで表されます。
  各型変数αは、あるρに対して (α、 ρ) ∈ INST ならば、その INSTANCE 特性値としてρを持つ。 それ以外の場合、プロパティ値は NIL です。

  <!-- 372 25/28 -->

## 5. 拡張言語の型

  我々は現在、我々の言語のいくつかの拡張を検討し、その結果をどのように強化してそれらに適用するかを検討します。

#### (1) 冒頭で述べたように、☓ (Cartesian product)、+ (disjoint sum)、 list (list forming) などの余分な(プリミティブ)型の演算子を追加することは難しくありません。
  ➙と一緒に、これらは言語 ML のプリミティブ型演算子です。
  ☓については、標準の多相関数

    pair : α ➙ β ➙ (α ☓ β) (one could add the syntax (e, e’) for pair (e) (e’) ),
    fst : α ☓ β ➙ α,
    snd : α ☓ β ➙ β.

  `+` の場合は、

    inl : α ➙ α + β, inr : β ➙ α + β    (left and right injections) ,
    outl : α + β ➙ α, outr : α + β ➙ β   (left and right projections) ,
    isl : α + β ➙ bool, isr : α + β ➙ bool (left and right discriminators)

  自然な解釈で。
  リストについては、第 2 章で述べた標準的なリスト処理関数があります。
  リストのすべてのメンバーは同じ型でなければならないことに注意してください。

  セマンティック・サウンド定理は、セマンティック・ドメインを適切に調整することで自然に拡張されます。 構文的健全性の定理は事実上変化しません。

#### (2) 次に、割り当て可能な変数と代入を検討します。
  これらを追加する 1 つの方法 (ML で使用)は、代入式 "x := e "(値は e の値)を許可し、式 "letref x = e in e '"を代入可能 e の値に初期化された変数。
  これらの追加の最初の効果は、セマンティックドメインの大きな変化です。これは、式が副作用を持つ可能性があるためです。
  セマンティック健全性定理が証明されるかもしれないと我々は信じているが、それは面倒な作業であるようです。
  難しさの理由は、

    λx. (y := x)

  これは副作用を伴う同一性関数です。
  型α➙αを持っていると言うと、型μの引数が与えられると、それは型μの結果を与え、 y の副作用を考慮しないことを意味します。
  必要とされるのは、副作用を考慮して、そのような機能型が意味するもののより意味のある定義(意味論的領域の観点から)です。

  これとは対照的に、 2 つの新しい種類の式に対して適切な型指定規則を与えることは簡単です。
  wt の定義を次の節で拡張します。

  (i) (c) letrefx τが標準接頭辞 p 〜で有効であれば、 p 〜| x τは wt です。 (したがって、 x のすべての letref バインドされたオカレンスは、同じ型でなければなりません)。

  <!-- 373 26/28 -->

  (vii) p 〜| (x ρ:= e σ〜) _ τは wtf です。 e 〜は wt であり、 letrefx ρは p 〜で有効であり、ρ=σ=τです。

  (viii) p 〜| (letrefx ρ= e ρ〜 e σ '〜) _ τは wtf です。 e 〜と p 〜. letrefx ρ| e '〜は wt であり、σ=τです。

  アルゴリズム W と構文健全性定理を拡張してこれらの節を扱うのは日常的な問題です。
  しかし、意味論的考察に再び戻ると、λ抽象(手順)内の非局所的割り当てに関連する問題がある。
  検討する

    let g = (letref y = nil in λz. y := cons (z, y) )

  これは関数 g の隠れた(自身の)変数として y を設定します。
  我々のルールでは、 g はジェネリック型α➙αリストを取得します。
  代入の値が割り当てられた値であることを思い出すと、 g の各呼び出しは隠された y を増やし、増補されたリストを値として返します。
  今ではαが一般的なので、式

    g (2) ,    g (true)

  g のスコープ内で、 int 型リストと boo1 型の両方の型でそれぞれ許容されます。
  しかし、この順序で評価される場合、 2 番目の式の値は、 2 つのメンバーが真で 2 のリストです。 それはブール値のリストではありません！

  このジレンマには少なくとも 2 つの解決策があります。
  1 つは、このような状況では、一般的な型の変数ではないということです。
  ML で採用されている別のものは、λ抽象(手順)内の多相性の割り当て可能変数への非局所的割り当てを禁止することです。
  ポリモーフィックの代入変数は、例えば、 iterations (while ステートメント)自体にシンプルな wt ルールを与えることができます。

  私は、第二の解決策が、わずかに緩和さえあっても、セマンティック健全性定理を認めていると信じています。
  しかし、詳細は魅力的ではなく、私は(特にジョン・レイノルズとの有用な議論の後で)証拠を完成させようとするのはお勧めしません。
  むしろ必要とされるのは、副作用をより重視する言語設計です。 1 つのアプローチは、プロシージャに割り当てられたすべての変数がプロシージャの出力パラメータとしてリストされるように要求することによって、 PASCAL を変更することです。
  しかし、これをどのように自分の変数の有益な特性と組み合わせるかは、私が知る限り、言語設計における未解決の問題であり、良い解決策は貴重な一歩となるでしょう。
  最近の有望な副作用管理の試みとして、 Reynolds [13] を参照してください。

#### (3) ML に含まれている自明でない拡張のリストを完成させるには、新しい型の演算子を古いものとして宣言(再帰的)することを検討してください。
   そのような宣言は非グローバルな範囲を持つかもしれません。
   新しい型の演算子に対する一連の関数の宣言も伴い、型演算子の明示的な定義は、(新しい型の演算子の全範囲内ではなく)関数の集合を定義する場合にのみ利用可能であり、 現在抽象型と呼ばれるもののバージョンを持っています。
   ML では、チップ変数の型を表す型変数αを使用して、チップが任意の型のオブジェクトによってラベル付けされたバイナリツリーのクラスを定義します。

    absrectype α bitree = α ➙ (α bitree ☓ α bitree)
          with sons (t) = ...
           and maketree (t, t’) = ...
           and tiptree (a) = ...

  <!-- 374 27/28 -->

  省略された定義式だけがビット・ツリーの表現へのアクセスを与えられます。
  定義された関数は多相型であり、ジェネリック型

    α bitree ➙ (α bitree) ^2, (α bitree) ^2 ➙ α bitree, α ➙ α bitree.

  この構成の詳細については、 [2] を参照してください。 我々は部分的にロックウッドモリスとジェリーシュワルツとの議論に構造を負います。
  この場合、 wt ルールも比較的簡単です。 文法的、意味的な健全性は検査していませんが、大きな困難はないと考えています。

#### (4) 一種の多相型に寄与する二つの特徴はこれまで完全に無視されてきました。
  第 1 の特徴は、強制です。 式 x := 42 (ここで、 x は実際の代入変数です)は、我々のために型が不正です。
  しかし、型チェッカーがそのような不正な型入力を報告し、コンパイラーがレポートを受け取り、それを修正する強制を挿入できるようにすることに障壁はありません。

  第 2 の特徴は、特定の手順(標準またはユーザ定義のいずれか)が複数の種類を有することを可能にすることです。
  勿論、α^ 2 ➙α(もちろん 2 つの型を持つ最も一般的なポリ型)を持たずに、 int ^ 2➙int と real ^ 2➙real を持つことができます。
  我々は質問を調査していませんが、我々の規律にこの特徴を重ね合わせる良い可能性があるようです。

## 6. 結論

   我々は、実用的に有用であると思われる多相型プログラミングの規律を提示し、かなり単純な型検査アルゴリズムを与えました。
   制限された言語では、このアルゴリズムが正しいことが証明できることが示されています(証明は 2 つの健全性定理に因数分解されました)。
   まだ多くの作業が残っていますが、型・チェッキングの実践が意味論と証拠によってサポートされるべきであり、そうでなければならないという点を強調したいと考えています。

## 謝辞

   私は、このペーパーの最初のバージョンについて、審査員に謝意を表します。これは、いくつかの不正確さに注意を喚起し、いくつかの点でより明確な説明につながりました。
   Dorothy McKie にも、紙の 2 つのバージョンを慎重に準備していただき、感謝します。

## REFERENCES

  1. W. H. BURGE, “Recursive Programming Techniques,” Addison-Wesley, Reading, Mass., 1975.
  2. M. GORDON, R. MILNER, AND C. WADSWORTH, “Edinburgh LCF,” CSR-11-77, Computer Science Dept., Edinburgh University, 1977.
  3. M. GORDON, R. MILNER, L. MORRIS, M. NEWEY, AND C. WADSWORTH, A metalanguage for interactive proof in LCF, in “Proc. 5th Annual ACM SIGACT-SIGPLAN Symposium on Principles of Programming Languages, Tucson, Arizona, 1978.” 

  <!-- 375 28/28 -->

  4. D. GRIES AND N. GEHANI, Some ideas on data type in high-level lcnguages, Comm. ACM. 20 (1977), 414-420.
  5. R. HINDLEY, The principal type-scheme of an object in combinatory logic, %zx~. Amer. &ikth. Sot. 146 (1969), 29-60.
  6. B. W. LAMPSON, J. J. HORNING, R. L. LONDON, J. G. MITCHELL, AND G. L. POPEK, Report on the programming language Euclid, SIGPLAN Notices (ACM) 12, 2 (1977).
  7. P. J. LANDIN, The next 700 programming languages, Comm. ACM 9 (1966), 157-164.
  8. B. H. LISKOV AND S. ZrLLEs,Programming with abstract data types, in “Proc. of ACM SIGPLAN conference on Very High Level Languages,” SIGPLAN Notices (ACM) 9 (1974), 50-59.
  9. R. MILNER, “Models of LCF,” Mathematical Centre, Amsterdam, Tracts, Vol. 82, pp. 49-63, 1976.
  10. J. H. MORRIS, “Lambda-Calculus Models of Programming Languages,” Ph.D. Thesis, M.4CTR-57, MIT, 1968.
  11. G. PLOTKIN, A power-domain construction, SIAM J. Comput. 5 (1976), 452-487.
  12. J. C. REYNOLDS, “Towards a Theory of Type Structure,” Systems and Inform. Sci., Syracuse University, 1974.
  13. J. C. REYNOLDS, Syntactic control of interference, in “Proc. 5th ACM Symposium on Principles of Programming Languages, Tucson, Arizona, 1978,” pp. 39-46.
  14. J. A. ROBINSON, A machine-oriented logic based on the resolution principle, J. Assoc. Comput. Much. 12 (1965), 23-41.
  15. D. SCOTT, Lattice theoretic models for various type-free calculi, in “Proc. 4th International Congress for Logic, Methodology and Philosophy of Science, Bucharest, Rumania, 1972.”
  16. D. SCOTT AND C. STRACHEY, Towards a mathematical semantics for computer languages, in “Proc. Symposium on Computers and Automata,” Vol. 21, Microwave Res. Inst. Symposia Series, Polytech. Inst. of Brooklyn, 1971.
  17. D. SCOTT, Data types as lattices, SIAM j. Comput. 5 (1976), 522-587.
  18. A. SHAMIR AND W. WADGE, Data types as objects, in “Proc. 4th ICALP Conference, Turku, Finland, 1977.”
  19. C. STRACHEY, Fundamental concepts in programming languages, Notes for the International Summer School in Computer Programming, Copenhagen, 1967.
  20. R. D. TENNENT, On a new approach to representation-independent data classes, Acta Inform. 8 (1977), 315-324.
  21. B. WEGBREIT, The treatment of types in ELl, Comm. ACM 17 (1974), 251-264.
  22. A. VAN WIJNGAARDEN ET AL., Revised report on the algorithmic language ALGOL 68, Acta Informutica 5 (1975), l-236.
  23. R. A. WULF, R. L. LONDON, AND M. SHAW, “Abstraction and Verification in ALPHARD: Introduction to Language and Methodology,” ISIIRR-76-46, Univ. of California, 1976.
