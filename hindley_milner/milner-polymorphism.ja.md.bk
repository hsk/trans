# プログラミングにおける多相型の理論

 ROBIN MILNER 

 Computer Science Department, University of Edinburgh, Edinburgh, Scotland 

 Received October 10, 1977; revised April 19, 1978 

  この作業の目的は、主に実用的なものです。
   型の規律を課さない構造処理言語におけるプログラミングの広く採用されたスタイルは、多種多様なオブジェクトでうまく動作するプロシージャを定義することを必要とします。
   そのような多相的手続きのための形式的な型の規律を、単純なプログラミング言語の文脈で提示し、規律を強制するコンパイル時型検査アルゴリズム W を提示します。
   意味的健全性定理(言語の正式な意味論に基づく)は、井戸型プログラムは`間違っていない`ことができないと述べており、構文健全性定理は、 W がプログラムを受け入れるならば型付けされていると述べています。
   これらの結果をより豊かな言語に拡張することについても議論します。 エジンバラ LCF システムのメタ言語 ML については、 W に基づく型検査アルゴリズムが実際には既に実装されて動作しています。

## 1.はじめに

  この作業の目的は、主に実用的なものです。
  広く使われているプログラミングのスタイルは、特に型の規律を課さない構造処理言語(LISP は完全な例です)では、多種多様なオブジェクト(例えば、 atom のリスト、整数、またはリストなど)でうまく動作するプロシージャを定義します)。
  このような柔軟性は、このスタイルのプログラミングではほとんど不可欠です。残念ながら、誤って CDR を LISP のアトムに適用し、不自然にプロパティリストを整数に追加する人は、その症状を知ることになります。
  一方、上記の柔軟性を排除する ALGOL 68 [22]のような型の規律は、我々が話しているプログラミングスタイルを排除します。
  ALGOL 60 は柔軟性がありました。つまり、手続きパラメータは "手続き"として指定する必要がありました。しかし、柔軟性は一様ではなく、十分ではありませんでした。

  このような柔軟性についての初期の議論は、おそらく多相性と呼ばれる最初の者であった Strachey [19]に見出すことができます。
  実際、彼はそれを`パラメトリック`多相型と呼んでいました。これは、`アドホック`多相型とは対照的でした。
  後者の例は、整数加算と実加算の両方を表すために "-|" を使用することです(実際には、複素加算、ベクトル加算などを表すためにさらに拡張することができます)。いくつかの異なる型でこの識別子を使用することは、現在は`オーバーロード`と呼ばれていることが多く、このホワイトペーパーではそれに言及していません。


<!-- 348 1/28 -->

  0022 - 0000/78/0173 - 0348 $ 02. 00/0 
  Copyright 8 1978 by Academic Press, Inc.
  All rights of reproduction in any form reserved.

<!-- 349 2/28 -->

  この論文では、型の柔軟性を獲得する方法を提示し、正当化する一方で、堅牢なプログラムを保証する規律を保持しています。
  この仕事は単なる理論的な運動ではないという証拠があります。ここで議論する多相型規律は、 LCF メタ言語 ML に組み込まれており、 2 年近く使用されています。
  この言語用のコンパイル時型チェッカーは、かなりの割合のプログラミングエラーをトラップする貴重なフィルタであることが証明されています。

  本論文の主要な部分は、シンプルな説明的言語の文脈における、型の規律に関する技術的な説明(意味論的および構文的な両方)に関係しているが、この時点では、非形式的にアプローチを特徴付けることが有用です。
  その主な特徴を概説します。

  まず、型に関するすべてがコンパイル時に行われます。型・チェッカー(コンパイラの一部)がプログラムまたはプログラム・フレーズを受け入れると、実行時にオブジェクトがその型を持たないことを前提としたコードが生成されます。
  これは、効率的なオブジェクトコードを生むものとして広く受け入れられていますが、 EL1 のアプローチと比較して型の使用に制約を課します[21]。

  第二に、多くの重要でないプログラムは、文脈から推論されるので、型の言及を完全に避けることができます。
  (ただし、 ML では、他の言語と同様に、ユーザーは実際には、これらの型の操作と一緒に自分の型を定義する必要があります。
  このようにユーザが自分の型を定義できるようにする最近の言語は、 CLU [8]、 ALPHARD [23]、 Euclid [6]です。
  プロシージャの正式なパラメータを含む宣言された変数の型指定を要求することは、より分かりやすい問題につながることを納得して論じることができますが、これらの仕様を省略できるようにすることは、特にオンラインプログラミングにおいても便利です。
  いずれにせよ、我々が提示する型チェッカーは非常に単純であり、たとえ変数の型が宣言で常に指定されていても、はるかに簡単にすることはできません。

  第三に、多相型が主要な役割を果たします。
  たとえば、プロシージャーには多相型(polytype)(一般に polytype と略します)が割り当てられます。その引数の型および結果が文脈から一意的に決定される場合のみ、それは単相性(すなわち、単相型が割り当てられる)です。
  Gries と Gehani [4]は、(LISP や SNOBOL の型レスプログラミングとは対照的に)制御された多相型プログラミングの説得力のあるケースを作りました。しかし、また Tennent [20]では、多相型を指定するために型変数や識別子の存在が必要です。
  我々のために、プログラムに存在する多相型は、すべてのプログラミング言語に存在すると思われるプリミティブ多相型演算子の自然な成果です。そのような演算子は、代入、関数適用、ペアリングとタプル、およびリスト処理演算子です。
  これは、主に、これらの演算子の型制約と、変数の宣言と使用で、プログラムのフレーズの型とそのサブフレーズの種類を決定します。

  本書では、最終的に強制的にまたは識別子の`オーバーロード`のどちらかを除いて、このホワイトペーパーでは説明しません。
  我々の見解では、これらの概念やランタイム型の操作は、コンパイル時の多相型の規律とは幾分直交しており、ある程度は無効化せずに組み込むことができます。

  第 2 節では、 ML の断片の例による型の規律を説明します。
  この断片は自明であるべきであるが、 ML の概要は[3]で与えられ、完全な記述は[2]に示されます。
  これらのイラストは、我々が有用な言語を扱うことができるようにするために役立つはずです。
  論文の残りの部分は、非常に簡単な適用言語Expを使って規律を正当化します。
  正当化は 2 つの部分に分かれます。

<!-- 350 3/28 -->

  第 3 節では、型定義(正しい型の割り当て)の概念を定義し、型付きプログラムが意味的に型違反がないことを示す意味健全性定理を証明します。
  言語の操作上の定義を与える場合、これは、たとえば、整数が真理値に加算されることも、引数に適用されることもないことを意味し、その結果、実行時検査のためにその型を持ち運ぶ必要はありません。
  第 4 節では、よく型されたアルゴリズム W を提示し、文法健全性定理を証明します。文法健全性定理は、 W が成功すればプログラムの型付けを生成すると述べています。
  W をシミュレートする、より効率的なアルゴリズム I も提供します。

  Exp の型は基本的な型の集合に対する単なる関数型の階層です。
  つまり、 Exp の多相性は、単一のプリミティブ多相型演算子、関数適用、変数バインディングの自然な伸びです。
  ペアリングやリスト処理演算子(ML のように)のような他の基本多項式演算子を、基本的な `☓`(Cartesian Product)、リスト(リスト生成)、`+`(分離した合計)は、(関数型)に加えて、 2 つの健全性定理に特別な困難を与えません。
  実際、代入演算子を追加することは、構文健全性定理に関する限り簡単ですが、セマンティック健全性定理は、このケースでは、アサイナブルの現在の値を保持するメモリまたはストアの余分なセマンティックの複雑さのために、拡張するのが難しい変数。
  これについては第 5 章でさらに議論します。

  我々の研究は、彼の論文で Morris [10]が表現した問題を次のように解決するための一歩です:
  プログラマが関数の呼び出しごとに異なる型を持つ関数を定義する言語と型システムを設計することができます。
  この論文の第 4 章では、問題の明確な紹介として推奨しています。
  Morris は形式の意味論について公式には議論していないが、多相型の系を与えているが、一連の連立 1 次方程式を解くことによって、λ-計算の項でどのように有効な型の割り当てが見つかるか説明しています。次のセクションでこの考え方をさらに進めていきます。

  この作業を行った後、我々は、結合論理の項のための "主型スキーム"(これを多相型と呼ぶ)を導出する Hindley の方法[5]を知るようになりました。
  Hindley は、 Robinson の単一化アルゴリズム[14]がこの問題に適切であることに気づく最初の者であるように思われます。
  我々の仕事は、 Hindley の方法をローカル宣言を使ってプログラミング言語に拡張し、そのメソッドの意味論的正当性とみなすことができます。

  要約すると、命令型の機能を持つ現在使用されているプログラミング言語に対して構文的によく理解され、正当化されている多相型の規律を提示します。また、重要ではないが非必須のサブ言語についても意味論的に説明されます。

## 2. 型の規律の図

  多相性の概念を簡単な例を使って説明します。
  それらはMLの断片で書かれていますが、これはわかりやすいものです。この断片は実際にはLandins ISWIM [7]にすぎず、読者はBurgeの本[1]に言及して、このプログラミングのスタイルをほぼ正確に使用しています。

<!-- 351 4/28 -->

  ここでは必須の構成要素を使用しません(割り当てやジャンプ)。
  コンストラクト

    let x = e in e’,
    let f(x1,..., xn) = e in e’

  `e`の値に` x`を与え、 `e`には抽象度`λ(x1、...、xn).e`の値を与えるために使用されます。
  再帰関数ではletの代わりにletrecが使われ、 `e 'の部分が省略されたときには宣言があります。

  MLの完全に決定された型(すなわち単項式)は、バイナリの中置演算子 `☓`(デカルト積)、` + `(分離されたsum)と `➙`(関数型)と単項の後置演算子リストです。
  多相型(ポリ型)は、型変数を受け入れることによって得られます。
  `α`、`β`、`γ`···。
  任意の型を `ρ`、`σ`、 `τ`で表す。
  このセクションでは、型の意味を読者の直感に任せます。それは次のセクションで正確にされています。

  例1.リスト上の関数のマッピング。

    letrec map(f, m) = if null (m) then nil
                       else cons (f(hd(m)), map (f, tl(m))).

  直感的には、このように宣言された関数マップは、あるソートのものから別のソートのものへの関数と、第1ソートのもののリストを取り、第2ソートのリストを生成します。そこで、マップには型があります

    ((α ➙ β) ☓ α list) + β list,

  ここで、 `α`、 `β` は型変数です。

  この型はマップの裸宣言からどのように決定されますか？
  まず、宣言で自由に出現する識別子のジェネリック型(後で`ジェネリック`と呼ぶ)は、

    null: α list ➙ bool,
     nil: α list,
      hd: α list ➙ α,
      tl: α list ➙ a list,
    cons: (α ☓ α list) ➙ α list,

  つまり、それらの型には1つ以上の型変数が含まれており、その規則は次のとおりです。このような識別子が出現するたびに、その型の代入インスタンス(型変数の型を代入する)である型が割り当てられます。

  これらの識別子はそれぞれ宣言の中で一度だけ出現するので、識別子 `id` に割り当てられた型を `σid` で表す場合、いくつかの型 `τ1、...、τ5` に対して、

    σnull = τ1 list ➙ bool,
    σnil = τ2 list,
      σhd = τ3 list ➙ τ3
      σtl = τ4 list ➙ τ4 list,
    σcons = (τ5 ☓ τ5 list) ➙ τ5 list.

<!-- 352 5/28 -->

  他の識別子 (`map`、 `f`、  `m`) はそれぞれ2回以上現れます。我々の規則では、それぞれのオカレンスに同じ型が割り当てられることを要求しています。規則はまた、いくつかの型 `ρ1、ρ2、...`に対して以下の式が満たされることを要求します。

    σmap = σf ☓ σm ➙ ρ1,
    σnull = σm ➙ bool,
      σhd = σm ➙ ρ2,
      σtl = σm ➙ ρ3,
      σf = ρ2 ➙ ρ4,
    σmap = σf ☓ ρ3 ➙ ρ5,
    σcons = ρ4 ☓ ρ5 ➙ ρ6
      ρ1 = ρnil = ρ6.

  これらの条件の1つ目は、関数の型をその仮パラメータの型に関連付けることです。
  条件付き式がその2つの腕と同じ型を持ち、宣言の確定数と定義数が同じ型であるため、最後のものを除いて、関数適用であるいくつかの下位句から発生します。

  これらの方程式は、変数 `ρi`、`τi`、および `σid` に対して解くことができます。
  Morris [10]は、このような方程式の解を論じています。
  事実、Robinson [14]の単一化アルゴリズムの使用には完全に適切です。我々の型タイピングアルゴリズムはこのアルゴリズムに基づいており(この場合、単一化以上のものは必要ないので)、最も一般的な型のマップが得られたと Robinson の研究から結論づけることができます。すなわち、方程式取得した型の置換インスタンスでなければなりません。
  実際、上記の方程式の解は

    σmap = (γ ➙ δ) ☓ γ list ➙ δ list,

  ここで、 `γ`、 `δ` は任意の異なる型変数です。
  だから、これは `map` のジェネリック型です。つまり、この宣言のスコープ内のマップの出現には、この型のいくつかの置換インスタンスを割り当てる必要があります。

  これらのインスタンスは同じである必要はありません。
  `tok` は基本型(トークンが文字列である)であり、識別子(型を持つ)が利用可能であると仮定します。

  そして

      tokl: tok list (a variable),
    length: tok ➙ int,
    sqroot: int + real,     two obvious functions.

  次に、式の

    map(sqroot, map(length, tokl))

  で、`map` の2つのオカレンスには型があります

    ((tok ➙ int) ☓ tok list) ➙ int list,
    ((id ➙ real) ☓ int list) ➙ real list.

<!-- 353 6/28 -->

同様に、`null` の場合、たとえば `map` の定義で2回発生した場合、その型は

    α list ➙ bool

  我々の規則では、仮パラメータ(たとえばf)や識別子(マップ)の再帰的定義の異なる出現が同じ型を持つことを要求しています。

  上に述べたマップの出現は、別々に宣言された2つのマップ関数の使用と見なすことができることに注意してください。
  Gries と Gehani が述べているように、コンパイラは、これらの明確な宣言を生成するタスクを与えることができます(プログラマが複製を見る必要はなく、意識する必要もないため)。異なる型で使用するマップ関数。
  効率のために、トークンリストが整数リストとは異なって実装されている(そして原始的な多相関数`hd`、`tl` 等が相応に異なっている)場合は、上記の例では本当に必要になります。
  我々は、これらのマップ関数がすべて意味論的に同じオブジェクトであるとみなされる概念的なフレームワークに関心を持っています。実装者は望むように少数または多くの変種として実装する自由が残されます。

  この例から明らかなように、タイピングのルールは慎重に設定する必要があります。
  letまたはletrecをローカルで使用するときに何が起こるかを説明するもう1つの例を見てみましょう。

  例2 タグ付け。 tagpair `(a)` が関数であるような関数 tagpair が必要であるとします。

    (b,c) |➙ ((a, b), (a, c)).

  もちろん、我々は簡単に書くことができます

    let tagpair = λ(b, c). ((a, b), (a, c)).

  ここで、方程式を設定することなく、型定義アルゴリズムがこの宣言にどのように取り組んでいるかを説明することができます。
  まず、`a`、`b`、および `c` に "未知" の型(すなわち、型変数) `α`、`β`、および `γ` を割り当てます。
  次に、 `((a, b), (a, c))` は `(α ☓ β) ☓ (α ☓ γ)` 、λ式は `β ☓ γ ➙ (α ☓ γ) ☓ (α ☓ γ)` と型付けされます;ついにタグペアアイア

    α ➙ (β ☓ γ ➙ (α ☓ β) ☓ (α ☓ γ))     (*)

  (型方程式は `a`、` b`、 `c`の型に制約を課していません)。

  しかし、(埋め込まれた)関数を使用して、タグペアを定義する別の方法を検討してください

    #: (α ➙ β) ☓ (γ ➙ δ) ➙ ((α ☓ γ) ➙ (β ☓ δ))

  `(f # g)(a, c) = (f(a), g(c))` とペアリング関数

    pair: α ➙ (β ➙ (α ☓ β))

<!-- 354 7/28 -->

  `pair(a)(b) = (a, b)` となるようにします。
  我々は書くことができる

    let tagpair write = λa. (let tag = pair(a) in tag # tag)

  次に、 well-typing アルゴリズムが次のように進むことが期待されるかもしれません。
  まず、`α` に `a` を代入します。
  次に、ジェネリック型の `pair` を使用して、`pair(a)` は `δ ➙ α ☓ δ` を取得します。
  これをローカルのジェネリック型のタグとして使用し、 `tag # tag` の `tag` の2つの出現にはそれぞれ `β ➙ α1 ☓ β`、`γ ➙ α2 ☓ γ` を割り当てます。
  `#` の出現にはジェネリック型のインスタンスが割り当てられます(新しい型変数を使います)。そして、関数適用の型方程式は型

    β ☓ γ ➙ (α1 ☓ β) ☓ (α2 ☓ γ)

  タグ `#` タグとλ式の本体に代入され、タグペアがその型を取得する

    α ➙ (β ☓ γ ➙ (α1 ☓ β) ☓ (α2 ☓ γ)).  (**)

  `(*)`と `(**)`を比較すると、何かが間違っていました。 2番目の型はあまりにも一般的です。
  問題は、タグおよびその一般的な型がλバウンド変数aおよびその型`α`に依存し、λバウンド変数の異なるバウンド出現が異なる型を持つことを許さないことです。
  実際、型に関する限り、tagpairが3番目の方法で定義されているのと同じようになるはずです。

    let tagpair = λa. (pair(a) # pair(a))

  読者は、(実施例1のようないくつかの方程式を設定することによって)
  この場合、期待される型は `(*)` です。

  解決策は幸運にも簡単です。
  let または letrec によってバインドされた変数の型をインスタンス化する際に、それを宣言します。
  包括的なλ結合(または仮パラメータ束縛)の型には存在しない型変数だけがインスタンス化されるかもしれません。
  このようなインスタンス化可能な変数(ジェネリック型)はジェネリック型変数と呼ばれます。

  今度は tagpair の2番目の定義では、ローカルに定義されたタグがジェネリック型 `δ ➙ α ☓ δ` を取得しました。ここで `δ` は一般的ですが `α` は一般的ではありません。
  したがって、タグは、タグの出現に型を割り当てる際にインスタンス化されていてはならず、 `(**)` は `(*)` と同一であったはずです。
  この例は少し工夫されているように見えるかもしれません。確かに、我々の経験は、ほとんどの場合、ジェネリック型の型変数のすべてが一般的なものか、まったく共通なものではありませんでした。
  しかし、例外を排除する簡単な構文上の制約はなく、そうすることも望ましいとは思われません。

これらの例から、それぞれlet(またはletrec)とλによってバインドされた変数を入力するためのルールが異なることが明らかになります。
  したがって、2つの式に対する我々の意味論

    let x = e in e’;    (λx. e’)e

  (そして等価であるかもしれませんが)前者に正しく型を割り当てることは可能かもしれませんが、後者には正しく型を割り当てることはできません。
  例はペアです

    let I = λx. x in I(I);    (λI. I(l))(λx. x).

<!-- 355 8/28 -->

  これに対する部分的な直観は、λ抽象化が引数なしでしばしば起こることがあることです。上記の2番目の式は明示的な引数-`(λx. x)`-が存在するという点で、抽象化の特別な(むしろ不要な)使用を含んでいます。
  let構文は(変換されると)抽象化のこの制限された使用を伴うので、型割り当ての規則がそれほど制約されないことは不自然ではません。
  コンパイラはもちろん、 `(λx. e’)e` のすべての明示的な出現をあまり制約のない方法で扱うことができます。

  λ-バインディング(すなわち、仮パラメータバインディング)とバインディングとの間の相互作用における型の処理は、実際に我々のアプローチの中核です。
  これは、無関係の変数として囲む手続きの仮パラメータを含むかもしれない手続きの非グローバル宣言の一貫した扱いを提供します。
  これは多相性の重大な困難の1つと思われるため、難易度に無関係な可能な限り除外する簡単な言語(Exp)の観点から分析を提示することが正当だと考えています。

  読者は、我々のルールが任意に選択され、直感によって部分的にしかサポートされていないと感じるかもしれません。
  ルールが唯一のものであるとは確かには言いませんが、後で与えられる結果は意味的に正当化されていることを示しています。
  実際には、正しい型の割り当てを認めるプログラムは、型エラーのために実行時に失敗しないか、より正確には、そのセマンティクスでコード化された型制約が常に満たされることを示します。
  このことから、コンパイル時の型検査(すなわち、正しい型割当てを発見しようと試みる)は実行時に型を持たせる必要がなくなり、実装の効率が明らかに向上します。

  これはもちろん、コンパイル時型検査の主な目的です。もう1つは、プログラミングエラーの早期検出です(その多くが不正プログラムの原因となります)。
  我々の業績は、多相型を含むように型検査を拡張することです。
  さらに、最終的な形式(第3節のアルゴリズム1)の型検査アルゴリズムは、構文型健全性定理の証明が正しいとしても正しい型割り当てを生成することはかなり面倒であると述べているが、非常に単純です。

  我々は、システムでうまく入力できるプログラムのクラスの独立した特徴付けをしたいと思いますが、これを行う方法はわかりません。
  しかし、我々はいくつかの指針を与えることができます。
  レフリーの提案では、Burge [l、Chapt。 3]データ構造を処理するための一般的な機能に関します。
  そこにあるすべての関数(我々が調べなかった3.11節を除く)は、2つの点で修正されたML型チェッカから期待される型を取得しました。
  第1に、Burgeは、不連続和型とその被加数型の間の強制関数を暗黙のうちに残します。これらを明確にする必要がありました(この点は序文で言及されています)。
  次に、Burgeによって使用される再帰型定義を定式化するために、ML抽象型構文(例として第5章を参照)を使用しました。
  この構文では、定義された抽象型とその表現の間の同型写像は明示的に行われ、明示的に使用されなければなりません。
  この要件の必要性を見るために、αストリームの場合を考えてみましょう。これは、αとαストリームからなるペアを生成する関数であると定義されています。
  型方程式

    α-stream = - - - ➙ (α ☓ α-stream)

  (無限型表現を許さない限り)単一化によって解決することはできません。

<!-- 356 9/28 -->

  しかし、方程式を同型写像として扱い、2つの関数を使って抽象型とその表現の間で前後に変換することで、この困難は取り除かれます。
  我々は、この解決策が抽象的な型の概念に従っていると主張している(例えば[8]参照)。

  否定的な側面では、間違いなく型することができない便利な表現がありますが、それらがなければどれほど煩わしいのかははっきりしていません。
  明白な例は、カレーの `Y` コンビネータです。

    Y = λf.(λx.f(x(x)))(λx.f(x(x)))

  自己申告は我々のために型されていないからです。
  しかし letrec は `Y` の必要性を避けています。
  より具体的には、

    let F(f) = λ(a, b). (f(a),f(b))

  議論の対象となるかもしれない - 異なる型のaとbで動作するのに十分な多相型である関数を引数として受け入れるべきです。
  例えば、

    F(reverse)(x, y)

  `x` と `y` が異なる型のリストである場合、異なる型の逆のリストのペアを生成します。
  我々のシステムでは、このような `F` の使用を拒否します(aとbには同じ型が必要です)。しかし、

    let reversepair = λ(x, y). (reverse(x), reverse(y))

  または `F` の関数引数の他の特殊化を含みます。

  この例ではシステムの主な制限が示されていますが、明示的な型パラメータを使用せずに可能な限り柔軟に対応している可能性があります。
  これらが導入されると、型の型の問題が発生します。レイノルズ[12]は
  この問題を解決するためにいくつかの進歩を遂げましたが、回避しながらどれだけ多くのことができるのかが目に見えていました。
