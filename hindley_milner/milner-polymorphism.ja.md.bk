# プログラミングにおける多相型の理論

    ROBIN MILNER

    Computer Science Department, University of Edinburgh, Edinburgh, Scotland

    Received October 10, 1977; revised April 19, 1978

  この作業の目的は、主に実用的なものです。
  型の規律を課さない構造処理言語におけるプログラミングの広く採用されたスタイルは、多種多様なオブジェクトでうまく動作するプロシージャを定義することを必要とします。
  そのような多相的手続きのための形式的な型の規律を、単純なプログラミング言語の文脈で提示し、規律を強制するコンパイル時型検査アルゴリズム W を提示します。
  意味的健全性定理(言語の正式な意味論に基づく)は、井戸型プログラムは`間違っていない`ことができないと述べており、構文健全性定理は、 W がプログラムを受け入れるならば型付けされていると述べています。
  これらの結果をより豊かな言語に拡張することについても議論します。 エジンバラ LCF システムのメタ言語 ML については、 W に基づく型検査アルゴリズムが実際には既に実装されて動作しています。

## 1. はじめに

  この作業の目的は、主に実用的なものです。
  広く使われているプログラミングのスタイルは、特に型の規律を課さない構造処理言語 (LISP は完全な例です)では、多種多様なオブジェクト(例えば、 atom のリスト、整数、またはリストなど)でうまく動作するプロシージャを定義します)。
  このような柔軟性は、このスタイルのプログラミングではほとんど不可欠です。残念ながら、誤って CDR を LISP のアトムに適用し、不自然にプロパティリストを整数に追加する人は、その症状を知ることになります。
  一方、上記の柔軟性を排除する ALGOL 68 [22] のような型の規律は、我々が話しているプログラミングスタイルを排除します。
  ALGOL 60 は柔軟性がありました。つまり、手続きパラメータは "手続き" として指定する必要がありました。しかし、柔軟性は一様ではなく、十分ではありませんでした。

  このような柔軟性についての初期の議論は、おそらく多相性と呼ばれる最初の者であった Strachey [19] に見出すことができます。
  実際、彼はそれを "パラメトリック" 多相型と呼んでいました。これは、"アドホック" 多相型とは対照的でした。
  後者の例は、整数加算と実加算の両方を表すために "-|" を使用することです(実際には、複素加算、ベクトル加算などを表すためにさらに拡張することができます)。いくつかの異なる型でこの識別子を使用することは、現在は "オーバーロード" と呼ばれていることが多く、このホワイトペーパーではそれに言及していません。


<!-- 348 1/28 -->

  0022 - 0000/78/0173 - 0348 $ 02. 00/0
  Copyright 8 1978 by Academic Press, Inc.
  All rights of reproduction in any form reserved.

<!-- 349 2/28 -->

  この論文では、型の柔軟性を獲得する方法を提示し、正当化する一方で、堅牢なプログラムを保証する規律を保持しています。
  この仕事は単なる理論的な運動ではないという証拠があります。ここで議論する多相型規律は、 LCF メタ言語 ML に組み込まれており、 2 年近く使用されています。
  この言語用のコンパイル時型チェッカーは、かなりの割合のプログラミングエラーをトラップする貴重なフィルタであることが証明されています。

  本論文の主要な部分は、シンプルな説明的言語の文脈における、型の規律に関する技術的な説明(意味論的および構文的な両方)に関係しているが、この時点では、非形式的にアプローチを特徴付けることが有用です。
  その主な特徴を概説します。

  まず、型に関するすべてがコンパイル時に行われます。型・チェッカー(コンパイラの一部)がプログラムまたはプログラム・フレーズを受け入れると、実行時にオブジェクトがその型を持たないことを前提としたコードが生成されます。
  これは、効率的なオブジェクトコードを生むものとして広く受け入れられていますが、 EL1 のアプローチと比較して型の使用に制約を課します [21]。

  第二に、多くの重要でないプログラムは、文脈から推論されるので、型の言及を完全に避けることができます。
  (ただし、 ML では、他の言語と同様に、ユーザーは実際には、これらの型の操作と一緒に自分の型を定義する必要があります。
  このようにユーザが自分の型を定義できるようにする最近の言語は、 CLU [8]、 ALPHARD [23]、 Euclid [6] です。
  プロシージャの正式なパラメータを含む宣言された変数の型指定を要求することは、より分かりやすい問題につながることを納得して論じることができますが、これらの仕様を省略できるようにすることは、特にオンラインプログラミングにおいても便利です。
  いずれにせよ、我々が提示する型チェッカーは非常に単純であり、たとえ変数の型が宣言で常に指定されていても、はるかに簡単にすることはできません。

  第三に、多相型が主要な役割を果たします。
  たとえば、プロシージャーには多相型 (polytype) (一般に polytype と略します)が割り当てられます。その引数の型および結果が文脈から一意的に決定される場合のみ、それは単相性(すなわち、単相型が割り当てられる)です。
  Gries と Gehani [4] は、 (LISP や SNOBOL の型レスプログラミングとは対照的に)制御された多相型プログラミングの説得力のあるケースを作りました。しかし、また Tennent [20] では、多相型を指定するために型変数や識別子の存在が必要です。
  我々のために、プログラムに存在する多相型は、すべてのプログラミング言語に存在すると思われるプリミティブ多相型演算子の自然な成果です。そのような演算子は、代入、関数適用、ペアリングとタプル、およびリスト処理演算子です。
  これは、主に、これらの演算子の型制約と、変数の宣言と使用で、プログラムのフレーズの型とそのサブフレーズの種類を決定します。

  本書では、最終的に強制的にまたは識別子の`オーバーロード`のどちらかを除いて、このホワイトペーパーでは説明しません。
  我々の見解では、これらの概念やランタイム型の操作は、コンパイル時の多相型の規律とは幾分直交しており、ある程度は無効化せずに組み込むことができます。

  第 2 節では、 ML の断片の例による型の規律を説明します。
  この断片は自明であるべきであるが、 ML の概要は [3] で与えられ、完全な記述は [2] に示されます。
  これらのイラストは、我々が有用な言語を扱うことができるようにするために役立つはずです。
  論文の残りの部分は、非常に簡単な適用言語 Exp を使って規律を正当化します。
  正当化は 2 つの部分に分かれます。

<!-- 350 3/28 -->

  第 3 節では、型定義(正しい型の割り当て)の概念を定義し、型付きプログラムが意味的に型違反がないことを示す意味健全性定理を証明します。
  言語の操作上の定義を与える場合、これは、たとえば、整数が真理値に加算されることも、引数に適用されることもないことを意味し、その結果、実行時検査のためにその型を持ち運ぶ必要はありません。
  第 4 節では、よく型されたアルゴリズム W を提示し、文法健全性定理を証明します。文法健全性定理は、 W が成功すればプログラムの型付けを生成すると述べています。
    W をシミュレートする、より効率的なアルゴリズム I も提供します。

  Exp の型は基本的な型の集合に対する単なる関数型の階層です。
  つまり、 Exp の多相性は、単一のプリミティブ多相型演算子、関数適用、変数バインディングの自然な伸びです。
  ペアリングやリスト処理演算子 (ML のように)のような他の基本多項式演算子を、基本的な `☓` (Cartesian Product)、リスト(リスト生成)、 `+` (分離した合計)は、(関数型)に加えて、 2 つの健全性定理に特別な困難を与えません。
  実際、代入演算子を追加することは、構文健全性定理に関する限り簡単ですが、セマンティック健全性定理は、このケースでは、アサイナブルの現在の値を保持するメモリまたはストアの余分なセマンティックの複雑さのために、拡張するのが難しい変数。
  これについては第 5 章でさらに議論します。

  我々の研究は、彼の論文で Morris [10] が表現した問題を次のように解決するための一歩です:
  プログラマが関数の呼び出しごとに異なる型を持つ関数を定義する言語と型システムを設計することができます。
  この論文の第 4 章では、問題の明確な紹介として推奨しています。
  Morris は形式の意味論について公式には議論していないが、多相型の系を与えているが、一連の連立 1 次方程式を解くことによって、λ-計算の項でどのように有効な型の割り当てが見つかるか説明しています。次のセクションでこの考え方をさらに進めていきます。

  この作業を行った後、我々は、結合論理の項のための "主要型スキーム" (これを多相型と呼ぶ)を導出する Hindley の方法 [5] を知るようになりました。
  Hindley は、 Robinson の単一化アルゴリズム [14] がこの問題に適切であることに気づく最初の者であるように思われます。
  我々の仕事は、 Hindley の方法をローカル宣言を使ってプログラミング言語に拡張し、そのメソッドの意味論的正当性とみなすことができます。

  要約すると、命令型の機能を持つ現在使用されているプログラミング言語に対して構文的によく理解され、正当化されている多相型の規律を提示します。また、重要ではないが非必須のサブ言語についても意味論的に説明されます。

## 2. 型の規律の図

  多相性の概念を簡単な例を使って説明します。
  それらは ML の断片で書かれていますが、これはわかりやすいものです。この断片は実際には Landins ISWIM [7] にすぎず、読者は Burge の本 [1] に言及して、このプログラミングのスタイルをほぼ正確に使用しています。

<!-- 351 4/28 -->

  ここでは必須の構成要素を使用しません(割り当てやジャンプ)。
  コンストラクト

    let x = e in e’,
    let f (x1, ..., xn) = e in e ’

    `e` の値に  `x` を与え、   `e` には抽象度 `λ(x1, ..., xn) .e` の値を与えるために使用されます。
  再帰関数では let の代わりに letrec が使われ、 `e` の部分が省略されたときには宣言があります。

    ML の完全に決定された型(すなわち単項式)は、バイナリの中置演算子 `☓`(デカルト積)、`+` (分離された sum) と `➙` (関数型)と単項の後置演算子リストです。
  多相型(ポリ型)は、型変数を受け入れることによって得られます。
    `α` 、 `β` 、 `γ` ···。
  任意の型を `ρ`、 `σ`、 `τ` で表す。
  このセクションでは、型の意味を読者の直感に任せます。それは次のセクションで正確にされています。

  例 1. リスト上の関数のマッピング。

    letrec map (f, m) = if null (m) then nil
                       else cons (f (hd (m) ), map (f, tl (m) )).

  直感的には、このように宣言された関数マップは、あるソートのものから別のソートのものへの関数と、第 1 ソートのもののリストを取り、第 2 ソートのリストを生成します。そこで、マップには型があります

    ((α ➙ β) ☓ α list) + β list,

  ここで、 `α`、 `β` は型変数です。

  この型はマップの裸宣言からどのように決定されますか？
  まず、宣言で自由に出現する識別子のジェネリック型(後で "ジェネリック" と呼ぶ)は、

    null : α list ➙ bool,
     nil : α list,
      hd : α list ➙ α,
      tl : α list ➙ a list,
    cons : (α ☓ α list) ➙ α list,

  つまり、それらの型には 1 つ以上の型変数が含まれており、その規則は次のとおりです。このような識別子が出現するたびに、その型の代入インスタンス(型変数の型を代入する)である型が割り当てられます。

  これらの識別子はそれぞれ宣言の中で一度だけ出現するので、識別子 `id` に割り当てられた型を `σid` で表す場合、いくつかの型 `τ1,..., τ5` に対して、

    σnull = τ1 list ➙ bool,
    σnil = τ2 list,
      σhd = τ3 list ➙ τ3
      σtl = τ4 list ➙ τ4 list,
    σcons = (τ5 ☓ τ5 list) ➙ τ5 list.

<!-- 352 5/28 -->

  他の識別子 (`map`、 `f`、 `m`) はそれぞれ 2 回以上現れます。我々の規則では、それぞれのオカレンスに同じ型が割り当てられることを要求しています。規則はまた、いくつかの型 `ρ 1、 ρ 2、...`に対して以下の式が満たされることを要求します。

    σmap = σf ☓ σm ➙ ρ1,
    σnull = σm ➙ bool,
      σhd = σm ➙ ρ2,
      σtl = σm ➙ ρ3,
      σf = ρ2 ➙ ρ4,
    σmap = σf ☓ ρ3 ➙ ρ5,
    σcons = ρ4 ☓ ρ5 ➙ ρ6
      ρ1 = ρnil = ρ6.

  これらの条件の 1 つ目は、関数の型をその仮パラメータの型に関連付けることです。
  条件付き式がその 2 つの腕と同じ型を持ち、宣言の確定数と定義数が同じ型であるため、最後のものを除いて、関数適用であるいくつかの下位句から発生します。

  これらの方程式は、変数 `ρ i`、 `τ i`、および `σ id` に対して解くことができます。
    Morris [10] は、このような方程式の解を論じています。
  事実、 Robinson [14] の単一化アルゴリズムの使用には完全に適切です。我々の型タイピングアルゴリズムはこのアルゴリズムに基づいており(この場合、単一化以上のものは必要ないので)、最も一般的な型のマップが得られたと Robinson の研究から結論づけることができます。すなわち、方程式取得した型の置換インスタンスでなければなりません。
  実際、上記の方程式の解は

    σmap = (γ ➙ δ) ☓ γ list ➙ δ list,

  ここで、 `γ`、 `δ` は任意の異なる型変数です。
  だから、これは `map` のジェネリック型です。つまり、この宣言のスコープ内のマップの出現には、この型のいくつかの置換インスタンスを割り当てる必要があります。

  これらのインスタンスは同じである必要はありません。
    `tok` は基本型(トークンが文字列である)であり、識別子(型を持つ)が利用可能であると仮定します。

  そして

      tokl : tok list (a variable) ,
    length : tok ➙ int,
    sqroot : int + real, two obvious functions.

  次に、式の

    map (sqroot, map (length, tokl) )

  で、 `map` の 2 つのオカレンスには型があります

    ((tok ➙ int) ☓ tok list) ➙ int list,
    ((id ➙ real) ☓ int list) ➙ real list.

<!-- 353 6/28 -->

同様に、 `null` の場合、たとえば `map` の定義で 2 回発生した場合、その型は

    α list ➙ bool

  我々の規則では、仮パラメータ(たとえば f) や識別子(マップ)の再帰的定義の異なる出現が同じ型を持つことを要求しています。

  上に述べたマップの出現は、別々に宣言された 2 つのマップ関数の使用と見なすことができることに注意してください。
    Gries と Gehani が述べているように、コンパイラは、これらの明確な宣言を生成するタスクを与えることができます(プログラマが複製を見る必要はなく、意識する必要もないため)。異なる型で使用するマップ関数。
  効率のために、トークンリストが整数リストとは異なって実装されている(そして原始的な多相関数 `hd`、 `tl` 等が相応に異なっている)場合は、上記の例では本当に必要になります。
  我々は、これらのマップ関数がすべて意味論的に同じオブジェクトであるとみなされる概念的なフレームワークに関心を持っています。実装者は望むように少数または多くの変種として実装する自由が残されます。

  この例から明らかなように、タイピングのルールは慎重に設定する必要があります。
    let または letrec をローカルで使用するときに何が起こるかを説明するもう 1 つの例を見てみましょう。

  例 2 タグ付け。 tagpair` (a) ` が関数であるような関数 tagpair が必要であるとします。

    (b, c) |➙ ((a, b) , (a, c) ).

  もちろん、我々は簡単に書くことができます

    let tagpair = λ(b, c) . ((a, b) , (a, c) ).

  ここで、方程式を設定することなく、型定義アルゴリズムがこの宣言にどのように取り組んでいるかを説明することができます。
  まず、 `a`、 `b`、および `c` に " 未知" の型(すなわち、型変数) `α`、 `β`、および `γ` を割り当てます。
  次に、 `((a, b), (a, c))` は ` (α ☓ β) ☓ (α ☓ γ) `、λ式は `β ☓ γ ➙ (α ☓ γ) ☓ (α ☓ γ) ` と型付けされます;ついにタグペアアイア

    α ➙ (β ☓ γ ➙ (α ☓ β) ☓ (α ☓ γ) )     (*)

  (型方程式は `a`、 `b`、 `c` の型に制約を課していません)。

  しかし、(埋め込まれた)関数を使用して、タグペアを定義する別の方法を検討してください

    #: (α ➙ β) ☓ (γ ➙ δ) ➙ ((α ☓ γ) ➙ (β ☓ δ) )

  ` (f # g) (a, c) = (f (a), g (c))` とペアリング関数

    pair : α ➙ (β ➙ (α ☓ β) )

<!-- 354 7/28 -->

    `pair (a) (b) = (a, b) ` となるようにします。
  我々は書くことができる

    let tagpair write = λa. (let tag = pair (a) in tag # tag)

  次に、 well - typing アルゴリズムが次のように進むことが期待されるかもしれません。
  まず、 `α` に `a` を代入します。
  次に、ジェネリック型の `pair` を使用して、 `pair (a) ` は `δ ➙ α ☓ δ` を取得します。
  これをローカルのジェネリック型のタグとして使用し、 `tag # tag` の `tag` の 2 つの出現にはそれぞれ `β ➙ α1 ☓ β`、 `γ ➙ α2 ☓ γ` を割り当てます。
  `#` の出現にはジェネリック型のインスタンスが割り当てられます(新しい型変数を使います)。そして、関数適用の型方程式は型

    β ☓ γ ➙ (α1 ☓ β) ☓ (α2 ☓ γ)

  タグ `#` タグとλ式の本体に代入され、タグペアがその型を取得する

    α ➙ (β ☓ γ ➙ (α1 ☓ β) ☓ (α2 ☓ γ) ).  (**)

  `(*)` と `(**)` を比較すると、何かが間違っていました。 2 番目の型はあまりにも一般的です。
  問題は、タグおよびその一般的な型がλバウンド変数 a およびその型 `α` に依存し、λバウンド変数の異なるバウンド出現が異なる型を持つことを許さないことです。
  実際、型に関する限り、 tagpair が 3 番目の方法で定義されているのと同じようになるはずです。

    let tagpair = λa. (pair (a) # pair (a) )

  読者は、(実施例 1 のようないくつかの方程式を設定することによって)
  この場合、期待される型は `(*)` です。

  解決策は幸運にも簡単です。
    let または letrec によってバインドされた変数の型をインスタンス化する際に、それを宣言します。
  包括的なλ結合(または仮パラメータ束縛)の型には存在しない型変数だけがインスタンス化されるかもしれません。
  このようなインスタンス化可能な変数(ジェネリック型)はジェネリック型変数と呼ばれます。

  今度は tagpair の 2 番目の定義では、ローカルに定義されたタグがジェネリック型 `δ ➙ α ☓ δ` を取得しました。ここで `δ` は一般的ですが `α` は一般的ではありません。
  したがって、タグは、タグの出現に型を割り当てる際にインスタンス化されていてはならず、 `(**)` は `(*)` と同一であったはずです。
  この例は少し工夫されているように見えるかもしれません。確かに、我々の経験は、ほとんどの場合、ジェネリック型の型変数のすべてが一般的なものか、まったく共通なものではありませんでした。
  しかし、例外を排除する簡単な構文上の制約はなく、そうすることも望ましいとは思われません。

これらの例から、それぞれ let (または letrec) とλによってバインドされた変数を入力するためのルールが異なることが明らかになります。
  したがって、 2 つの式に対する我々の意味論

    let x = e in e ’; (λx. e ’) e

  (そして等価であるかもしれませんが)前者に正しく型を割り当てることは可能かもしれませんが、後者には正しく型を割り当てることはできません。
  例はペアです

    let I = λx. x in I (I) ;    (λI. I (l) )(λx. x) .

<!-- 355 8/28 -->

  これに対する部分的な直観は、λ抽象化が引数なしでしばしば起こることがあることです。上記の 2 番目の式は明示的な引数-` (λx. x) `-が存在するという点で、抽象化の特別な(むしろ不要な)使用を含んでいます。
    let 構文は(変換されると)抽象化のこの制限された使用を伴うので、型割り当ての規則がそれほど制約されないことは不自然ではません。
  コンパイラはもちろん、 ` (λx. e’) e` のすべての明示的な出現をあまり制約のない方法で扱うことができます。

  λ-バインディング(すなわち、仮パラメータバインディング)とバインディングとの間の相互作用における型の処理は、実際に我々のアプローチの中核です。
  これは、無関係の変数として囲む手続きの仮パラメータを含むかもしれない手続きの非グローバル宣言の一貫した扱いを提供します。
  これは多相性の重大な困難の 1 つと思われるため、難易度に無関係な可能な限り除外する簡単な言語 (Exp) の観点から分析を提示することが正当だと考えています。

  読者は、我々のルールが任意に選択され、直感によって部分的にしかサポートされていないと感じるかもしれません。
  ルールが唯一のものであるとは確かには言いませんが、後で与えられる結果は意味的に正当化されていることを示しています。
  実際には、正しい型の割り当てを認めるプログラムは、型エラーのために実行時に失敗しないか、より正確には、そのセマンティクスでコード化された型制約が常に満たされることを示します。
  このことから、コンパイル時の型検査(すなわち、正しい型割当てを発見しようと試みる)は実行時に型を持たせる必要がなくなり、実装の効率が明らかに向上します。

  これはもちろん、コンパイル時型検査の主な目的です。もう 1 つは、プログラミングエラーの早期検出です(その多くが不正プログラムの原因となります)。
  我々の業績は、多相型を含むように型検査を拡張することです。
  さらに、最終的な形式(第 3 節のアルゴリズム 1) の型検査アルゴリズムは、構文型健全性定理の証明が正しいとしても正しい型割り当てを生成することはかなり面倒であると述べているが、非常に単純です。

  我々は、システムでうまく入力できるプログラムのクラスの独立した特徴付けをしたいと思いますが、これを行う方法はわかりません。
  しかし、我々はいくつかの指針を与えることができます。
  レフリーの提案では、 Burge [l、 Chapt。 3] データ構造を処理するための一般的な機能に関します。
  そこにあるすべての関数(我々が調べなかった 3. 11 節を除く)は、 2 つの点で修正された ML 型チェッカから期待される型を取得しました。
  第 1 に、 Burge は、不連続和型とその被加数型の間の強制関数を暗黙のうちに残します。これらを明確にする必要がありました(この点は序文で言及されています)。
  次に、 Burge によって使用される再帰型定義を定式化するために、 ML 抽象型構文(例として第 5 章を参照)を使用しました。
  この構文では、定義された抽象型とその表現の間の同型写像は明示的に行われ、明示的に使用されなければなりません。
  この要件の必要性を見るために、αストリームの場合を考えてみましょう。これは、αとαストリームからなるペアを生成する関数であると定義されています。
  型方程式

    α-stream = - - - ➙ (α ☓ α-stream)

  (無限型表現を許さない限り)単一化によって解決することはできません。

<!-- 356 9/28 -->

  しかし、方程式を同型写像として扱い、 2 つの関数を使って抽象型とその表現の間で前後に変換することで、この困難は取り除かれます。
  我々は、この解決策が抽象的な型の概念に従っていると主張している(例えば [8] 参照)。

  否定的な側面では、間違いなく型することができない便利な表現がありますが、それらがなければどれほど煩わしいのかははっきりしていません。
  明白な例は、カレーの `Y` コンビネータです。

    Y = λf. (λx. f (x (x) ))(λx. f (x (x) ))

  自己申告は我々のために型されていないからです。
  しかし letrec は `Y` の必要性を避けています。
  より具体的には、

    let F (f) = λ(a, b) . (f (a) ,f (b) )

  議論の対象となるかもしれない - 異なる型の a と b で動作するのに十分な多相型である関数を引数として受け入れるべきです。
  例えば、

    F (reverse) (x, y)

    `x` と   `y` が異なる型のリストである場合、異なる型の逆のリストのペアを生成します。
  我々のシステムでは、このような `F` の使用を拒否します (a と b には同じ型が必要です)。しかし、

    let reversepair = λ(x, y) . (reverse (x) , reverse (y) )

  または `F` の関数引数の他の特殊化を含みます。

  この例ではシステムの主な制限が示されていますが、明示的な型パラメータを使用せずに可能な限り柔軟に対応している可能性があります。
  これらが導入されると、型の型の問題が発生します。レイノルズ [12] は
  この問題を解決するためにいくつかの進歩を遂げましたが、回避しながらどれだけ多くのことができるのかが目に見えていました。

## 簡単なアプリケーション言語とその型

## 3. 1. 言語拡張

   x を識別子の上に置きます。

     x ∈ Id

   次に、式言語 Exp は次の文法によって生成されます。

     e :: = x | (e e ') | もしe ならe 'else e "|
           λx. e | x. e を修正する| e 'のx = e とします。

  ここで ` (e e') ` はアプリケーションを意味し、 `fix x. e` は最小固定点λ `x` を表す。最後の節は `e` の間に `e` の値に `x` を束縛します。
    `d`、 `e`、 `f` を素数と接尾辞で `Exp` の範囲で使用することがよくあります。
  定数は省略されています。初期の環境では、特定の識別子のための標準的なバインディングを想像することができます。

<！ - 357 10/28 - >

  実行時の失敗の検出に対応する値`間違い`を含む `Exp` の通常の意味論的セマンティクスを与える。
  この小さな言語では、唯一の失敗は、条件の条件としてのブール値ではない値の出現と、アプリケーションの演算子としての機能しない値の出現です。

  我々のセマンティックドメインは完全な部分的順序 (cpos) とみなされてもよい。 (a) 最小要素 `⊥ D` が存在し、 (b) `D` のすべての有向サブセットが、 `D` 内で最小の上限を有するような、部分的に順序付けられた集合です。
  与えられたように基本ドメインのセット `{ Bi }` を取り、 3 つの要素の真理値ドメインである `B0 = T` を取ります

    true false
       \     /
         ⊥T

  再帰的に以下を定義します

    V = B0 + B1 +. .. + F + W (disjoint sum of domains, with
                                  ⊥V adjoined as minimum element) ,
    F = V ➙ V (continuous functions from V to V) ,
    W = {・}                      (error) .

  このような一連のドメイン方程式の解(同型まで)は、 Scott [15] によって保証されています。
  彼は完全な格子で作業しましたが、解は cpos にも存在します (Plotkin [11] を参照)。

  セマンティック関数は、環境の領域である `Env = Id➙V` で、 `ε∈ Exp➙Env➙V` です。
   `η` を使って `Env` を範囲指定します。
   `ε` を定義する際には、後で、 Scott と Strachey [16] のよく知られた表記法を使用します(この例では `D` は
   `V` のいくつかの要約):

    (i) `d ∈ D` の場合、 `V` の `d` は、 `V` の `D` の注入の下での `d` の画像です。

    （ii） `v∈V`ならば、

      v ⁅ D == true if v = d in V for some d ∈ D,
            == ⊥T if v = ⊥V,
            == false otherwise.

    (iii) If v ∈ V, then

      v | D == d if v = d in V, for some d ∈ D,
            == ⊥D otherwise.

<!-- 358 11/28 -->

  The environment η’ = η{ v/x } is identical with η except that η’ (x) = v. The value ・ in V
  {・ ∈ IV) is written “ wrong. ” We require the conditional function COND ∈ T ➙ V ➙
  V ➙ V, where COND tvv ’ is written t ➙ v, v ’ and takes the value

    v if t == true,
    v '    if t == false,
    ⊥V if t == ⊥T.

## 3. 2. Semantic Equations for Exp

  In these equations, the open brackets [| |] indicate syntactic arguments.


    ε[|x |]η = η[|x |]
    ε[|e1 e2 |]η = v1 ⁅ F ➙ (v2 ⁅ W ➙ wrong, (v1 | F) v2) ,
                     wrong
                  where vi is ε[|ei |]η            (i = 1, 2) .
    ε[|if e1 then e2 else e3 |]η = v1 ⁅ B0 ➙ (v1 | B0 ➙ v2, v3) , wrong
                          where vi is ε[|ei |]η    (i = 1, 2, 3)
    ε[|λx. e |]η = (λv ・ε[|e |]η {v /x }) in V
    ε[|fix x. e |]η = Y (λv. ε[|e |]η{v /x })
    ε[|let x = e1 in e2 |]η = v1 ⁅ W ➙ wrong, ε[|e2 |]η{v1 /x }
                         where v1 = ε[|e1 |]η.

  Notes. (i) Y is the least fixed - point operation. In many languages the e in fix f ・ e
  would be restricted to be an abstraction λy. e’, and then

    let f = fix f. (λy. e’)

  might receive the syntax

    let rec f (y) = e ’

    (ii) It is easy to see that “ let x = e1 in e2 ” has the same meaning under ε as
  “ (λx * e2) e1 “. But part of our aim is a type discipline which admits certain expressions in
  the first form and yet rejects their translations into the second form; this is because λ-
  abstractions may in general occur without an explicit operand, and need more careful
  treatment.

    (iii) The semantics for (e1 e2) corresponds to call - by - value, since the test “ v2 ⁅ W ”
  ensures that the meaning of (e1 e2) is ⊥ V if the meaning of e2 is ⊥ V. The omission of
  this test gives a call - by - name semantics (a similar test may be omitted in the semantics of
  the let construct), and the Semantic Soundness Theorem goes through equally in this
  case.

<!-- 359 12/28 -->

## 3. 3. Discussion of Types

  We now proceed, in outline, as follows. We define a new class of expressions which
  we shall call types; then we say what is meant by a value possessing a type. Some values
  have many types, and some have no type at all. In fact “ wrong ” has no type. But if a
  functional value has a type, then as long as it is applied to the right kind (type) of argument
  it will produce the right kind (type) of result - which cannot be “ wrong ”!

  Now we wish to be able to show that - roughly speaking - an Exp expression evaluates
    (in an appropriate environment) to a value which has a type, and so cannot be wrong.
  In fact, we can give a sufficient syntactic condition that an expression has this robust
  quality; the condition is just that the expression has a “ well - typing ” with respect to the
  environment, which means that we can assign types to it and all its subexpressions in a
  way which satisfies certain laws.

  So there are two main tasks, once the laws of type assignment are given. The first - to
  show that an expression (or program) with a legal type assignment cannot “ go wrong ”--
  is tackled in this section; surprisingly enough, it is the easier task (at least for an applicative
  language). The second task is to discooer a legal type assignment, given a program with
  incomplete type information. This task is often called type checking. Of course, this term
  can also mean just verifying that a given type assignment is legal; in a practical situation
  we probably require something between the two, since one cannot expect a programmer
  to attach a type to every subexpression. In Section 4 we look at the class of legal type
  assignments for a given program (the class is infinite in general, since we admit polymorphism),
  and we give an algorithm which, if it succeeds, produces a legal type assignment.
  We conjecture that if the latter exists then the algorithm finds one which is most
  general, in the sense that any other legal type assignment is a substitution instance of it
    (substituting types for type variables) .

## 3. 4. Types and their Semantics

  The syntax of types is as follows.

    (1) ι0, ι1, ... are (basic) types; one for each Bi.

    (2) There is a denumerable set of type variables, which are types. We use α, β, γ, ...

  to range over type variables.

    (3) If ρ and σ are types, so is p ➙ σ.

  A monotype is a type containing no type variables. We use μ, ν, π,... to range over
  monotypes. We use the word polytype when we wish to imply that a type may, or does,
  contain a variable.

  We first give the semantics of monotypes; that is, we give the conditions under which
  a value v ∈ V possesses a monotype μ, which we write v : μ.

    (i) v : ιi iff v = ⊥ V or v ⁅ Bi

    (ii) v : μ ➙ ν iff either v = ⊥ V, or v ⁅ F and (v | F) u : ν whenever u : μ.

<!-- 360 13/28 -->

  It is clear then that many values have no type. Examples are

    wrong, (λv ∈ V. wrong) in V,
    (λv ∈ V. v ⁅ B0 ➙ (v | B0, ➙ x in V, y in V) , wrong) in V
      (where x ∈ B1, y ∈ B2, for example) .

  But in the last example if y ∈ B1, instead, then the function has type ι0 ➙ ι1 (and no
  other).

  Some values have many types; the identity function

    (λv ∈ V. v) in V

  for example has type μ ➙ μ for every μ. And of course ⊥ V has every type (it is the only
  value which has every type).

  This notion of type is derived from Scott [17]. In fact, it is what Scott calls functionality
    (after Curry) , and is distinct from the notion of a retract. If we temporarily identify a type
  with the set of values which possess it, then it is easy to show that types are downward
  closed and directed complete, that is

    (i) ∀ v, v ’ ∈ V. (v : μ and v ’ ⊑ v) ⇒ v ’ : μ,

    (ii) For each directed subset X of V, (∀ v ∈ X. v : μ) ⇒ ∐ X : μ.

  Retracts share the second property, but not the first. Recently Shamir and Wadge [18]
  have defined a type to be any set with these two properties, and they investigate the
  consequences of identifying a value v with the type { v ’ | v ’ ⊑ v }.

  The semantics of polytypes is as follows. First, we use ρ ⩽ σ to mean that ρ may be
  obtained from σ by substituting types for type variables (⩽ is clearly reflexive and
  transitive). For example,

    μ ➙ ⩽ α ➙ α ⩽ β ➙ β ⩽ α ➙ β

  but

TODO > 記号
    α ➙ β /⩽ β ➙ β    (unless α = β) .

  Then we define

    v : σ iff ∀μ ⩽ σ. v : μ.

  For example,

    (λv. v) in V : α ➙ α.

  Polytypes thereby also stand for subsets of V, and these are also directed complete. The
  reader may like to think of each type variable in a polytype as universally quantified at
  the outermost; for example,

    α ➙ α “means ” Vα. α ➙ α,

  where the bound α ranges over monotypes. In fact, it is because α here ranges over
  monotypes (not all types) and because we do not admit expressions like

    (∀α. α ➙ α) ➙ (∀α. α ➙ α)

<!-- 361 14/28 -->

  as types - though we can see they “ mean ” if the bound variables are taken to range over
  monotypes - that we avoid the difficulties (and also some of the interest) of Reynolds [12]
  in his richer notion of type.

  We need the following simple properties, which are immediate from our definitions.

  PROPOSITION 1. If v : σ and τ ⩽ σ then v : τ.

  PROPOSITION 2. If v : σ ➙ τ and v ’ : σ, then (v | F) v ’ : τ.

  In each case, a property of monotypes is lifted to polytypes.

## 3. 5. Type Assignments

  To prepare the ground for the theorem that well - typed expressions cannot “ go wrong, ”
  we need to define what is meant by typing an expression. We need first some notion of
  a type environment to give types to the free variables in an expression.

  A prefix p is a finite sequence whose members have the form let x, fix x, or λX, where x
  is a variable. A prefixed expression (pe) has the form p | e, where every variable free in e
  occurs in a member of p. We separate the members of a prefix by a period (.).

  Every pe has sub - pe’s given by the following, together with transitive reflexive closure :

    (i) p | x has no sub -pe’s except itself,
    (ii) p | (e e’) has sub -pe’s p | e and p | e’,
    (iii) p | (if e then e ’ else e ”) has sub -pe’s p | e, p | e ’ and p | e ”,
    (iv) p | (λx. e) has sub -pe p. λx | e,
    (v) P | (fix x. e) has sub -pe p. fix x | e,
    (vi) p | (let x = e in e’) has sub -pe’s p | e and p. let x | e’.

  For example, λy | (let f = λx. (xy) in (fy)) has sub - pe’s (besides itself)

    λy | λx. (xy) ,      λy. λx | (xy) ,   λy. λx | x, λy. λx | y,
    λy. let f | (fy) ,   λy. let f | f, λy. let f | y

  so a sub - pe is just a subexpression prefixed with all the variable bindings which enclose it.
  Note that λx. (x, v) in the above is not enclosed by let f - it is not in the scope of this
  binding.

  We say that a member let x or fix x or λx of p is active in p just if no x occurs to the
  right of it in p.

  Now a typing of a pe p | e is an assignment of a type to each element of p, and to each
  subexpression and each λx, fix x, or let x in e, with the constraint that in a subexpression
    (let x = e ’ in e ”) the same type is assigned to let x and e’. Thus one typing of the illustrated
  pe (it is nearly, but not quite, a well typing in the sense later defined) is as follows :


    λy_ α | let f_ ((α➙β) ➙β) = (λx_ (α➙β) (x_ (α➙β) y_α) _β) _ ((α➙β) ➙β) in (f_ ((α➙γ) ➙γ) y_α) _γ) _γ.

  We denote a typing of p | e by p ~ | e ~, or by p ~ | e σ~ when we want to indicate the type σ
  assigned to e itself.

<!-- 362 15/28 -->

  In any p ~ | e ~, and any binding let x σ in either p ~ or e ~, a type variable in σ which does not
  occur in (the type of) any enclosing λy τ or fix yτ, binding is called a generic type variable
  for the binding let xσ. In the example above, β is generic, but α is not, for the binding
  let f_ ((α➙β) ➙β). Intuitively, the generic type variables in a binding let x σ represent degrees
  of freedom for the types at which x may be used; they represent the local polymorphism
  of x. Notice that if no λ or fix bindings enclose let xσ, then all the type variables in σ are
  generic. Ageneric instance of σ is an instance of σ in which only generic type variables are
  instantiated.

  For technical reasons we require that generic type variables occur in a controlled
  manner. We say that p ~ | d ~ is standard if for every typed sub - pe p ’~ | d ’~ (with induced
  typing) the generic type variables of each member let x σ of p ’~ occur nowhere else in
  p ’~ | d '~. Thus in particular, if let x ρ = e ρ~ in e σ'~ is a subexpression of d ~, with induced typing,
  then the generic type variables in ρ may not occur in e σ'~ (though they must of course
  occur in e ρ~).

  We now define the notion of a well - typed (wt) pe as follows :

    (i) p ~ | xτ, is wt iff it is standard, and either
      (a) λxτ, or fix xτ, is active in p ~, or
      (b) let xσ, is active in p ~, and τ is a generic instance of σ.
    (ii) p ~ | (e ρ~ e σ'~)_ τ is wt iff p ~ | e ~ and p ~ | e '~ are both wt, and ρ = σ ➙ τ.
    (iii) p ~ | (if e ρ~ then e ρ'~ else e ρ”~)_ τ' is wt iff p ~ | e ~, p ~ | e ’~ and p ~ | e ”~ are all wt, ρ = ι0 and σ = τ = τ’.
    (iv) p ~ | (λxρ. e ρ~)_ τ is wt iff p ~.λx ρ | e ~ is wt and 　τ = ρ ➙ σ.
    (v) p ~ | (fix x ρ e ρ~)_ τ is wt iff p ~.fix x ρ | e ~ is wt and ρ = σ = τ.
    (vi) p ~ | (let x ρ = e ρ~ in e σ'~)_ τ is wt iff p ~ | e ~ and p ~ . let x ρ | e '~ are both wt, and σ = τ.

  Although this recursive definition is useful for some proofs, an alternative characterization
  of wt is sometimes useful. The proof of the next proposition is fairly straightforward,
  and we omit it. Note that a wt p ~ | d ~ is necessarily standard, by an easy structural
  induction.

  PROPOSITION 3. p ~ | d ~ a is wt iff the following conditions hold :

    (A) It is standard.

    (B) For every (bound) occurrence xσ, the corresponding binding occurmtce is either
  λxσ, OY fix xσ, or let xσ, where σ is a generic instance of τ.

    (C) The following conditions hold for all subexpressions (with induced typing) of d ~

      (e ρ~ e σ'~)_ τ                       ρ = a ➙ τ,
      (if e ρ~ then e σ'~ else e τ"~)_ τ'    ρ = τ0 and σ = τ = τ’,
      (λxρ. e σ~)_ τ                      τ = ρ ➙ σ,
      (fix xρ. e σ~)_ τ                   ρ = σ = τ,
      (let x ρ = e ρ~ in e σ'~)_ τ           σ = τ.

<!-- 363 16/28 -->

  The typing which we illustrated above therefore fails to be wt for only one reason :
  The subexpression` (f_ ((α➙γ) ➙γ) yα) _γ `violates the first of conditions (C) in Proposition 3.
  Consider another example. The following (with p ~ empty) is a well typing :

    let I_ (α➙α) = (λxα. xα) _ (α➙α) in
      (I_ ((ι➙ι) ➙(ι➙ι) ) I_ (ι➙ι) )_ (ι➙ι) .

  Note that α is generic in the type α ➙ α of the declaration of I, so may be instantiated
    (possibly differently) in the types of bound occurrences of I.

  To illustrate the need to instantiate only generic type variables, for variables declared
  by let, notice first that in λxα. xβ, we must have α = β, by condition (B) of Proposition 3.
  Indeed, we can argue intuitively for this as follows : if we declare

    let I = λx. x in. ..,

  then we wish to have that any expression (Ie) in the scope of this declaration receives the
  same type as the subexpression e. But now suppose we write (with assigned types)

    let I_ (α➙β) = (λxα. (let y α = x α in yβ) _β) _ (α➙β) in. ..

  then - since this is semantically equivalent to the simpler declaration - we should again
  demand that α = β. But this is imposed in our definition of well typing, just because α
  is not generic for the binding let yα, so may not be instantiated in a bound occurrence
  of y.

## 3. 6. Substitutions

  A substitution S is a map from type variables to types. S may be extended in a natural
  way to yield a map from types to types, from typed pe’s to typed pe’s, etc.
  We say that S involves a type variable α if either S α ≠ α, or for some β ≠ α, α ∈ Sβ.
    (α ∈ τ means α occurs in τ. )
  We need substitutions extensively in the second part of this paper, but for the present
  we need only one property relating substitutions and wt.

  PROPOSITION 　 4. If S involves no generic variables of a wt p ~ | d ~, then S (p ~ | d ~) is also a wt.

  Proof. We use Proposition 3. First, observe that the assumption on S yields that
  the generic variables for each binding in S (p ~ | d ~) are exactly those for the corresponding
  binding in p ~ | d ~. Since S β contains no generic variable when β is not generic, S (p ~ | d ~) is
  standard.

  Second, if xσ, is bound by λx σ or fix x σ in p ~ | d ~, then xs σ is bound by λxs σ or fix xs σ in
  S (p ~ | d ~). If x σ is bound by let xτ, and σ = [ρ1/α 1,..., αn/α n] _τ, where αi are the generic
  variables of τ, then in S (p ~ | d ~) xs σ is bound by let xsτ, and `S σ = [Sρ1/α 1,..., Sρn/α n] (Sτ) `
  is a generic instance of Sτ.

  Third, conditions (C) of Proposition 3 are easily verified for S (p ~ | d ~), using identities
  like S (u ➙ τ) = S σ ➙ Sτ. ■

<!-- 364 17/28 -->

## 3. 7. Well - Typed Expressions Do Not Go Wrong

  First we need a simple relation between semantic environments η and our type environments - which
  are typed prefixed p ~. We say

    η respects p ~ iff, whenever let x ρ or λx ρ or
    fix xρ, is active in p ~, η[|x |] : ρ.

  THEOREM 1 (Semantic Soundness). If η respects p ~ and p ~ | d τ~ is well typed then
  ε[| d |]η : τ.

  Proof. A fairly simple structural induction. Take the six cases for d τ~.

    (i) xτ. Then either λx τ or fix x τ is active in p ~, and η[|x |] : τ, so ε[|x |]η : τ, or let x σ
    is active in p ~, and η[|x |] : σ; but then T ⩽ σ, so ε[|x |]η = η[|x |] : τ, by Proposition I.

    (ii) `(e_ (σ➙τ) e σ~)_τ` . Then p ~ | e_ (σ➙τ) ~ is wt, so ε[|x |]η : σ ➙ τ, and similarly ε[|e '|]η : σ. Then
    from the semantic equation (remembering that wrong has no type) and by Proposition 2
    we get ε[|d |]η : τ.

    (iii) (if eι0 ~ then e σ'~ else e σ"~). Straightforward; the only extra detail needed here is that
    ⊥V has every type.

    (iv) (λxρ. e σ~)_ (ρ➙σ) . Then p ~ . λx ρ | e σ~, is wt. Now we require (λv. ε[|e |]η{v /x }) in V
    : ρ ➙ σ. Denote this function by f in V. The inverse of Proposition 2 does not hold,
    that is, to show f in V : ρ ➙ σ it is not sufficient (though it is necessary) that whenever
    v :ρ, fv : σ. What is required is that for every η ➙ ν ⩽ ρ ➙ σ, f in V : μ ➙ ν.


  Suppose then that μ ➙ ν ⩽ ρ ➙ σ. Then there is a substitution S, involving only the
  type variables in ρ and σ, such that μ ➙ ν = S (ρ ➙ σ). Then, since none of these type
  variables is generic in p ~ ・ λx ρ | e σ~, it follows that S (p ~) ・ λx μ | S (e ~) _ ν” is wt by Proposition 4.
  Moreover η respects S (p ~) (since by Proposition 1 whenever η[| x |] : σ’ and τ’ ⩽ σ’, η[| x |] : τ’)
  so for any v : μ we also have η{ v/x } respects S (p ~). λxμ.

  It then follows by induction that ε[| e |]η{ v/x } : ν, so we have shown that v : μ implies
  fv : ν, and this yields f in V : μ ➙ ν as required.

    (v) (fix xρ. e ρ~) _ρ. Then p ~. fix x ρ | e ρ~ is wt. Now we require that v : ρ, where

    v = Y (λv'. ε[|e |] η{v ’/x }).

  Now v0 = ∐ i, vi, where v0 = ⊥ V, v_ (i+1) = ε[| e |] η{ vi/x }, and by the directed completeness
  of types we only have to show vi : ρ for each i.

  Clearly v0 : ρ. Assume vi : ρ. Since η respect p ~, we have that η{ vi/x } respects p ~ ・ fix xρ,
  so by the main induction hypothesis v_ (i+1) : ρ also, and we are done.

    (vi) (let x = e ρ~ in e σ'~) _σ. Then p ~ | e ρ~ is wt, so we immediately have v : ρ, where
  v = ε[| e |]η. We require ε[| e '|]η (v/x) : σ.

  Now p ~ ・ let x ρ | e σ'~ is also wt, and because v : ρ we have that η{σ/x } respects p ~ ・ let xρ;
  the rest follows by the induction hypothesis. 1

<!-- 365 18/28 -->

  As a corollary, under the conditions of the theorem we have

    ε[|d |]η ≠ wrong,

  since wrong has no type.
