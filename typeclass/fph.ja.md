# FPH: First-class Polymorphism for Haskell

  Declarative, Constraint-free Type Inference for Impredicative Polymorphism

  Dimitrios Vytiniotis Stephanie Weirich

  University of Pennsylvania

  {dimitriv,sweirich}@cis.upenn.edu

  Simon Peyton Jones

  Microsoft Research

  simonpj@microsoft.com

  ----

  1 我々は Haskell の構文を使用し、フラグメントで使用されている関数の型シグネチャを例に付け加えます。

  2 この例は、 `(runST (foo 4))` と等価です。

   個人的または教室での使用のために、この作品の全部または一部をデジタルまたはハードコピーで作成することは、利益または商業的利益のためにコピーを作成または配布せず、コピーにはこの通知と最初のページ 。
   それ以外の方法でコピー、再発行、サーバーへの投稿、リストへの再配布を行うには、事前に特定の許可および/または料金が必要です。

   ICFP'08, September 22-24, 2008, Victoria, BC, Canada。

   Copyright °c 2008 ACM 978-1-59593-919-7/08/09. . . $5.00

  ----

## 抽象

  多相性をサポートする言語は、通常、多型の発生場所にアドホックな制限があります。
  これらの制限を解除することで、 "firstclass"多型をサポートすることは明らかに望ましいことですが、型推論を犠牲にすることなくこれを達成することは難しいです。
  私たちは、より早期の提案を改善する、より高ランクかつ忠実な多型の新しいタイプのシステムを提示します。これは、Damas-Milnerの拡張です。 システムF型のみに依存します。 それは単純で宣言的な仕様を持っています。 プログラムの変換には堅牢です。 完全かつ決定可能な型推論アルゴリズムを利用しています。


  カテゴリとサブジェクト記述子D.3.3 [プログラミング言語]：言語構成と特徴 - 抽象データ型、多型一般用語言語、理論

  キーワード impredicativity、上位ランク型、型推論

## はじめに

   このプログラムの断片 `1` を考えてみましょう：

      ($) :: forall a b. (a -> b) -> a -> b
    runST :: forall r. (forall s. ST s r) -> r
      foo :: forall s. Int -> ST s Int

    ...(runST $ foo 4)...

  ここで型が与えられた `($)` は適用コンビネータであり、 Haskell のプログラマが括弧を書くのを避けるためによく使われます 2。
  プログラマーの視点からは、このプログラムについて非常に複雑なものは何もありませんが、第一級多相型の2つの異なる形式を使用した、伝統的な DamasMilner 型システム（Damas and Milner 1982）をはるかに超えています。

  - `runST` は多相型の引数をとります。 `runST` は上位型です。
  
  - `($)` 型の定量化された型変数aは多相型 `∀s.ST` にインスタンス化されます。

  多相型で量化された型変数のインスタンス化を可能にすることを証拠的多相型と呼びます。


  他の著者（Le Botan and Remy 2003; Leijen 2008a）と共有する私たちの目標は、 Damas-Milner 型システムによって課せられた制限を解除することによって、そのようなプログラムを "正当な仕事" (just work) にすることです。

  同じ一般的な目標を持ついくつかの競合するデザインがありますが、デザインスペースは現在明確になっています。したがって、このペーパーは単に "批判的多相型に関するもう1つの不可解な論文" ではありません。
  第7章で詳細な比較を行いますが、表現力を最大化するか、実装の複雑さを最小限に抑えるのではなく、仕様の複雑さを最小限に抑えてプログラマのアクセシビリティに重点を置いています。具体的には、以下のように貢献します。

  - 我々は、犯行多型を表現することができる新しいタイプのシステムFPH（システムFに基づく）を記述し、公式化する（第3章）。
  我々は、 FPH がすべてのシステムF（3.4節）を表現できることを示す。

   - FPH は表現力が非常に小さく、シンプルです。
  これは、いくつかのパラグラフ（第2節）で非形式的に説明することができ、特に型注釈が必要なときには、次のようなきわめて単純なルールがあります。
  型の注釈は、 Damas-Milner 型ではない let バインディングまたはλ抽象化にのみ必要となる（セクション2.2）。
  例えば、 `(f (g x) (h (t y)))` のようなネストされた関数呼び出しは、事実上の多くのインスタンス化を必要とするかもしれませんが、型注釈を必要としません。

  - 型システムの構文主導バリアントを提供し（第4節）、これまでの宣言規則に関しては、それが健全かつ完全であることを証明します。
  
  - 我々はFPHのための健全かつ完全な推論アルゴリズムを持っています。これはセクション5で説明します。
  内部的には、この実装では、MLF(Le Botlan and Remy 2003)のスタイルで有界の量化を持つ型スキームを使用していますが、この内部的な洗練は決してプログラマーには表示されません。単純な宣言的な仕様をサポートするために実装によって使用されるメカニズムです。

  Googleのシステムは、いわゆる双方向型システムを介して注釈を伝播するという標準的な考え方と完全に互換性があります。
  第6章では、これと他のデザインのバリエーションについて説明します。
  最後に、足場が整ったところで、第7章では、現在の様々なデザインが互いにどのように関係しているかを詳細に示して、冒頭の挨拶を増幅する。

  補助資料および証明書は、最初の著者の論文（Vytiniotis 2008）に記載されています。

## 2. 1級多相型の型推論

  一級多型の主な難しさを説明するために、最初にDamas-Milner型（最上位の定量化のみを許す型）と豊富な型（型構築子の下に `∀`限定子を持つ型）を区別します。
  例えば、Int→Int`と `∀a.a→a`はDamas-Milner型です。 `Int→[∀a.a→a]`と `∀a。（∀b.b）→[a]`は豊富な型です。

  両方の形式のファーストクラスの多型（高ランクとインプレッショナル）は、式のプリンシパルタイプが不足します。単一の式は2つ以上の比類のない型で型指定可能であり、どちらも他よりも一般的ではありません。
  結果として、型推論は常に単一の型を選択することはできず、 `let`バウンド定義の範囲全体でそれを使用することはできません。
  
  1.上位の多型では、多型引数を受け入れる関数は、2つ以上の比較できないSystem F型で型指定されることがあります。たとえば、以下の関数 `f？`を考えてみましょう：

    f get = (get 3, get True)

  getを環境で多態型に割り当てる必要があることは明らかです。なぜなら、それを `3`とTrueの両方に適用できる必要があるからです。
  （∀aa→a）→（Int、Bool） `と`（∀aa→Int）→（Int、Int） `の両方の型は` f 'の主体型は存在せず、他のすべてのインスタンス化は一連のインスタンス化と一般化によってそれに従う。
  これまでの研究では、プログラマは、多型でなければならない関数引数の型注釈を指定しなければならないことを示唆しています。つまり、 `f`の型はもはやあいまいではありません。上記のコードは型チェックに失敗しますが、以下の注釈問題を解決します：

    f (get :: forall a. a->a) = (get 3, get True)

  2.型変数の事実上のインスタンス化の存在は、比類のない型の2番目のケースにつながります。例えば：

      choose :: forall a. a -> a -> a
      id :: forall b. b -> b
      g = choose id


    伝統的なDamas-Milner型のシステムでは、 `g`は`∀b。（b→b）→（b→b） `型になります。
    しかし、chooseが多態型でインスタンス化される場合、gは類似しない型 `（∀b.b→b）→（∀b.b→b）`で型付け可能である。
    この問題はMLFの研究で確認され、タイプ言語を拡張してインスタンス化制約を含むことを回避しました。
    この拡張型言語は `g 'の主型、すなわち`∀（a≧∀b.b→b）.a→a`を表すことができる。
    しかし、システムFの型言語の中にとどまることを望むなら、型システムは、これらの比較できない型のどれが `g`に割り当てられるのかを指定しなければなりません。
    FPHでは、 ``∀b。（b→b）→（b→b） `型の中で、` `∀bb→b）→（∀bb→b）明示的な型シグニチャを使用すると、次のようになります。

      g = choose id :: (forall b.b->b) -> (forall b.b->b)

  この論文の焦点は、以前の研究が本質的に高ランク型​​の問題を本質的に解決してきたため（Peyton Jones et al。2007）、impredicativity（上記（2））に焦点を当てている。
  したがって、セクション3で提示したコアタイプのシステムは、より高いランクタイプのλ抽象化を支持しています。
  実用的なシステムでは上位のタイプにも対応しなければならず、前の作業をセクション3.4と6.1の設定にどのように適用できるかを説明します。

## 2.1 批判的なインスタンス化のマーキング

  このセクションではFPHのフレーバーを提示し、いくつかの例を使用してデザイン原則を動機づけます。このプログラムの断片を考えてみましょう。

    str :: [Char]
    ids :: [forall a. a->a]
    length :: forall b. [b] -> Int
    l1 = length str
    l2 = length ids

  まず、 `l1`の型推論を考えてみましょう。
  多形の長さは引数リストの `length`を返します。型` [b] `は" bのリスト "を意味します。
  標準的なDamas-Milner型システムでは、 `length`の型は` Char`でインスタンス化されます。 `length`の型は` `Char``→Int`型です。これは` `length``と正しく結びつきます引数、 `str`
  Damas-Milnerでは、ポリモーフィック関数はモノタイプでしかインスタンス化できません。モノタイプτは定量化されていないタイプです（リストには[・] `を使います）。

    τ ::= a | τ1 → τ2 | [τ]

  このDamas-Milnerの制限は、 `l2`はuntypeableであることを意味します。なぜなら、` length`を `∀a.a→a`でインスタンス化しなければならないからです。
  Damas-Milnerの制限を単純に上げることはできません。これは、このセクションの始めに示された問題に直接つながります。異なる選択は、比類のないタイプにつながります。
  しかし、 `l2`はまた、批判的なインスタンス化の良好な使用があることを示しています。
  `l2`型のチェックを行うためには、実際的なインスタンス化が必要ですが、` l2`型は常に `Int`です。
  レットバインディングに2つ以上の比類のない型を割り当てることができます。

  私たちの考えは、驚異的なインスタンシエーションをマークすることで、式が異なる種類の型でいつ入力されるのかを知ることです。
  技術的には、これは単なる単体型よりも表現力が高いが、任意の多型よりも表現力が低い型の型を持つ多型関数をインスタンス化することを意味する。

    τ′ ::= a | τ1′ → τ2′ | [τ′] | ~[σ]
    σ  ::= ∀a.σ | a | σ → σ | [σ]

  モノタイプ「τ」とは異なり、ボックス型のモノタイプ「τ」は、定量化を含むことができますが、ボックス内でのみ、「〜[σ]」です。
  アイデア1はこれです：ポリモーフィック関数はboxyモノタイプでインスタンス化されます。
  boxy型は、型推論の残りの部分を通過させる型を埋めるために "推測"が必要な型の場所をマークします。

  さて、 `l2`とタイプすると`〜[∀a.a→a] `で長さをインスタンス化できます。
  そして、アプリケーションの長さのidsは `[〜[∀a.a→a]]`型の引数を期待する関数を持ち、 `[〜[∀a.a→a]] '型の引数に適用されます。
  これらのタイプは結婚しますか？
  そうです、Idea 2のおかげで、タイプを比較するときにすべてのボックスを破棄します。
  ボックスの唯一の目的は、批判的なインスタンス化から生じるポリタイプをマークすることです。
  これで `l2`の入力が完了しました。

  ボックスはアプリケーションの入力時に無視されますが、 `let`の多形性において重要な役割を果たします。
  アイデア3はこれです：推測されたポリタイプについてあいまい性がないことを確認するために、タイプ環境にはボックスが含まれていません。
  上記の `g = choose id`の例に戻りましょう。
  私たちがboxyモノタイプ `〜[∀aa→a]`でインスタンス化した場合、アプリケーション `（choose id）`は結婚しますが、その結果の型は `〜[∀aa→a]→〜[∀aa →a]。
  しかし、Idea 3は、その型が `g 'の型として環境に入るのを防ぐので、` choose`のこのインスタンス化は拒否されます。
  代わりに `c→c`を使って選択をインスタンス化すると、アプリケーションは再び（` id`の型を `c`でインスタンス化して）結びつくので、アプリケーションは`（c→c）→c→c`型ですこれは一般化され、次に `g 'の型として環境に入ることができます。
  このタイプはDamasMilnerの主要なタイプであり、 `g`のDamas-Milnerタイプは注釈なしでも利用できます。
  私たちが効果的に達成したことは、 `g 'に2つ以上の類のない型を持たせる代わりに、プリンシパル型を認める` g`の可能なSystem F型の導出の部分集合だけを許可したことです。
  しかし、プログラマが実際に `g 'のために他の豊富な型を必要とするならば、型アノテーションを使うことができます：

    g = choose id :: (forall b.b->b) -> (forall b.b->b)

  このようなタイプの注釈は、アイデア2を使用します。注釈付きの式「e ::σ」をタイプするときは、eタイプのボックスを無視します。
  `σ`（ボックスフリーでプログラマのアノテーションです）。
  型アノテーションが `（choose id）`、 `〜[∀aa→a]→〜[∀aa→a]`の型と互換性があるので、 `〜[∀aa→a]`で選択をインスタンス化することができます。 。

## 2.2 表現力

  これまで見てきたように、型付き注釈は `let`-bound式で必要になるかもしれませんが、ネストされ高次であるか、またはimpredicativityを含んでいても、関数アプリケーションでは注釈は必要ありません。
  はじめに、いくつかの亜種があります：

    runST :: forall a. (forall s. ST s a) -> a
    app :: forall a b. (a -> b) -> a -> b
    revapp :: forall a b. a -> (a -> b) -> b
    arg :: forall s. ST s Int
    h0 = runST arg
    h1 = app runST arg
    h2 = revapp arg runST

  すべての定義h0、h1、h2は注釈なしで型付き可能です。いずれの場合も戻り型は（モノボックスではない）モノタイプの「Int」です。

  実際には、プログラマーにとっては、箱について考える必要がなくても、はるかに強力なガイドラインがあります。

    注釈ガイドライン。
    タイプ注釈なしであなたの好きなようにあなたのプログラムを書いてください。
    次に、豊富な型を使用して入力するlet-bindingsとλ-abstractionだけをアノテーションする必要があります。

  例えば、アプリケーションと変数からなる項のために、（タイプ注釈なしで）「let」バインドされる場合、結果の型が通常のDamas-Milner型であれば、どのような擬似的なインスタンス化が起こるかは問題ではありません！
  例えば、以下の関数fの引数 `choose id`は、事実上（` f`と `choose`の両方に対して）事実上のインスタンス化を伴いますが、注釈は必要ありません。

    f :: forall a. (a -> a) -> [a] -> a
    g = f (choose id) ids

  特に `choose id`はタイプ`〜[∀a.a→a]→〜[∀a.a→a] `を取得します。
  しかし、 `f`の引数の型はIdea 2を使って結婚することができ、その結果の型（ボックスを無視する）はDamas-Milner型です
  （ `∀a.a→a`）なので、` g`のアノテーションは必要ありません。

  Annotation Guidelineはプログラマにボックスをまったく考える必要がないので、仕様ではボックスを使用するのはなぜですか？
  注釈ガイドラインは控えめであるため、プログラムを型指定可能にすることが保証されますが、必要以上に注釈が追加されます。
  例えば：

    f ':: forall a。 [a] - > [forall b。 b→b]
    g '= f' ids

  リッチな結果の型 `[forall b。 b - > b] `は非boxyなので、` g 'のアノテーションは必要ありません。
  一般的に、そのタイプは、（一般的なケースである）impredicativeインスタンス化から生じていない場合 `let`結合式の型は、リッチであっても、その後、何の注釈が必要とされません。ボックスは、「そのようなタイプが事実上のインスタンス化の結果ではない」ということを正確に指定します。
  それにもかかわらず、セクション6.3で議論しているように、ボックスフリー仕様は魅力的な代替設計です。

    Types
      σ ::= ∀a.ρ
      ρ ::= τ | σ → σ
      τ ::= a | τ → τ
    Boxy Types
      σ′ ::= ∀a.ρ′
      ρ′ ::= τ′ | σ′ → σ′
      τ′ ::= a | σ | τ′ → τ′
    Environments
      Γ ::= Γ,(x :σ) | ·

  図1：構文

## 2.3 FPH の限界

  これまで説明したように、FPHシステムは表現力豊かですが、いくぶん保守的です。
  次の例で示すように、let-bindingに割り当てることのできる型が1つしかない場合でも、いくつかのインスタンスで注釈が必要です。

    f :: forall a. a -> [a] -> [a]
    ids :: [forall a. a -> a]
    h1 = f (\x -> x) ids -- Not typeable
    h2 = f (\x -> x) ids :: [forall a. a->a] -- OK

  ここで `f`は要素とリストを受け取り、リストを返す関数です（例えば、` f`は `cons`とすることができます）。
  定義 `h1`はFPHでは型指定できません。
  `〜[∀a.a→a]`で `f`をインスタンス化しようとすると、` h1`の右辺に `[〜[∀a.a→a]]`型があり、その型
  環境に入ることができません。
  `h2`が示すように、型の注釈を追加することで問題を解決することはもちろん可能です。

  `h2`で型名を要求するのは馬鹿だと思うかもしれません。結局のところ、 `h1`は明白に1つの可能なタイプしか持っていません！
  しかし、 `f`の型が`∀ab.a→b→[a] `であるとします。これは上記の型よりも一般的なDamasMilner型です。この型の `f`では、今の例の` h1`には、以前と同様に `[∀a.a→a]`と `∀a。[a→a]`の2つのタイプがあります。
  注釈がなければ、おそらくDamas-Milner型システムと同じ型を選択しなければならないでしょう。それは `h1`の型が不正なものになる可能性があります。
  要するに、 `f`の型をより一般的なもの（Damas-Milnerの意味で）にすることは、` h1`の範囲の定義に悪用されるようになりました！
  これは悪いです;それが `h2`のように注釈を必要とする` h1`を拒否する理由です。

  `h2`の注釈を必要とすることはプログラマには迷惑に思えるかもしれませんが、単純で宣言的な高水準の仕様をもたらすのはFPHのこの保守性です。
  FPHは、Damas-Milner型システムの場合のように、let-bound定義が多くの異なる型を持つ環境に入ることを可能にします。

## 3. 型システムの宣言的な仕様

  図1のタイプと環境の基本的な構文から始めて、FPHの体系的な扱いに注目します。
  型は、 ``σ ``、 `` `` `` `` `` `` `` `` `` `` ``型の箱型で、 ``σ '`、` `ρ'
  多相型 ``σ``と ``σ``は最上位に量子を含むことができますが、 `ρ`と`ρ``型は入れ子になった量子のみを含みます。
  box-freeとboxyの間の重要な違いは、モノタイプレベルで発生します。
  Remyらの以前の研究に続いて、 （Garrigue and Remy 1999; Le Botlan and Remy 2003）、「τ」は、（ボックスフリーの）ポリタイプを含むボックスを含むことができる。
  セクション2.1で議論したように、これらのボックスは、「推測されたインスタンス化」が行われる場所を表します。
  `→`以外の型コンストラクタの構文は含まれていないことに注意してください。それらの処理は `→`の処理に非常に似ています。
  タイプ環境の構文、 `Γ`は、ボックスフリーの型`σ`だけを許すことによってセクション2.1のアイデア3を直接表現します。

## 3.1 型付け規則

  FPHの宣言的な（すなわち、構文指向ではない）仕様が図2に示されている。通常、「Γ⊢e：σ」という判定フォームは、入力環境「Γ」において式「σ」を式「e」に割り当てる`。
  タイピング関係の非構文的不変量は、「Γ⊢e：∀〜（a）.ρ」という判定では、ρ内部で数量化された変数とその変数の出現との間に介入することはできません。
  したがって、例えば、ρは、数量化された変数bが箱の中に現れるので、（∀b。〜[b]）→Int`の形をとることはできません。
  しかし、トップレベルの定量化された変数はボックスの中に現れることがあります。

  図2の規則は、従来のDamas-Milner規則の（慎重に選択されていますが）適度な変形です。
  事実、ルールVARはまったく同じように、変数の型を環境から戻すだけです。

  ルールAPPは、e1に対して関数型「σ1→σ2」を推論し、引数「e2」に対して型「σ'3」を推論し、引数型が関数型モジュロboxy構造の領域と一致するかどうかをチェックし、Ideaを実装するセクション2.1の2。
  この互換性チェックは、ボックスを「σ1」および「σ3」からはずし、同等かどうかを比較することによって実行されます。
  表記「⌊σ'⌋」は、ボックスを「σ」で破棄して得た非箱形を表す。

  **定義3.1（ストリッピング）** stripy関数 `∧⌋`をboxy
  次のようにタイプします。

    ⌊a⌋ = a
    ⌊~[σ]⌋ = σ
    ⌊σ′1 → σ′2⌋ = ⌊σ′1⌋ → ⌊σ′2⌋
    ⌊∀~(a).ρ′⌋ = ∀ ~(a) ~(b).ρ where ⌊ρ′⌋ = ∀ ~(b).ρ

  ストリップは、ルールANNでも使用されます。これは、明示的なプログラマー提供型注釈で式を処理します。
  これは、式のboxy型を推定し、boxy構造体を法とし、それが注釈 'σ`によって要求される型に等しいことをチェックします。
  事実上、このルールは、式のために推論されたボックスタイプ `σ'1 'をボックスフリータイプ`σ`に変換します。注釈付きの項がレットバインディング `x = e ::σ`の右辺である場合、このボックスフリー型のσは環境の中に` x`の型として入ることができます（ `σ 'はできませんでしたが、アイディア3）。

  ルールABSは、λ抽象の型を推定します。
  これは最初に環境をmonomorphic、box-free型の `x：τ`で拡張し、関数の本体に` `ρ``型を推論します。
  結果の型 `ρ`は両方とも（a）に最上位の量指定子がなく、（b）はボックスフリーであることを（構文的に）主張することに注意してください。
  Damas-Milnerがタイプ可能なプログラムについては、Damas-Milnerと同じタイプの属性を使用することを希望しているため、最上位の量指定子を除外します（Peyton Jones et al。2007）。
  選択肢（b）は、λ抽象化はボックスフリーの型を返さなければならないが、より多くのプログラマー注釈を必要とするかもしれないが、はるかに単純な型推論アルゴリズムを可能にすることが分かる。
  6.3節でこの問題に戻ります。

  ルールABSは、図2のタイプシステムがタイプ注釈を追加してもシステムFのすべてをタイプできない主な理由です。
  ABSはタイプτ→ρの抽象化のみを許容し、システムFはタイプσ1→σ2のλ抽象化を有する。
  しかし、以前の研究（Peyton Jones et al。2007）がこの限界に対処する方法を示していたのに対し、規則ABSは、事実上の事例への我々のアプローチ（この論文の貢献）を実証するのに十分である。
  セクション3.4に示すように、2つを組み合わせるのは簡単です。

  セクション2.1のアイデア3に続いて、ルールLETは、まず、右辺の式uの箱のないタイプ「σ」を推論し、次いで、バインダー「x」をタイプ「σ」で環境内で押すことをボディをチェックする。
  一般化（GEN）は従来の形式をとる。ここで `〜（a）＃Γ 'は`〜（a） `が`Γ`の自由型変数から離れていることを意味する。このルールでは、一般化された変数aが `ρ 'のボックスの中に現れることがあるので、例えば`Γ⊢e：∀a。 〜[a]→a`。

  インスタンス化（INST）は従来のものですが、アイデア1の後にはボックス型のモノタイプ「τ」でインスタンス化できます。
  しかし、INSTの置換には少し注意する必要があります。 `ρ 'は`〜（a） `を箱の中に入れているかもしれないので、素朴な代入は構文的に不正な入れ子の箱を残すかもしれません。
  したがって、我々はその議論の箱型構造を保存する置換形式を定義する。

  **定義3.2（単形置換）**単形置換には文字「φ」を使用します。つまり、「φ」は `[〜（a |→τ '）]`の形式の有限マップを表します。
  我々は `ftv（φ）`を `φ`の範囲と領域の自由変数の集合とします。
  我々は、以下のように、「σ」型に「φ」を適用する操作を定義する。

    ϕ(a)         = τ′ where [a |→ τ′] ∈ ϕ
    ϕ(~[σ])      = ~[⌊ϕ(σ)⌋]
    ϕ(σ′1 → σ′2) = ϕ(σ′1) → ϕ(σ′2)
    ϕ(∀~(a).ρ′)  = ∀~(a).ϕ(ρ′) where ~(a)#ftv(ϕ)

  `[〜（a |→τ '）]`を `σ'に適用するために` [〜（a |→τ '）]σ' `と書く。

## 3.2 包含ルール

  最後のルールであるSUBSは扱いにくいですが重要です。以下を考慮する：

  **例3.1（Boxyインスタンス化）**

    head :: forall a. [a] -> a
    h = head ids 3

  図2のルールSUBSを一時的に無視すると、 `head ids`はタイプ`〜[∀a.a→a] `を得ることができ、そのタイプだけが得られます。
  したがって、アプリケーション `（head ids）3`は型付けできません。
  多態性データ構造から多型表現を抽出するためには、型アノテーションを使用しなければならないので、この状況はむしろ不幸になります。
  たとえば、プログラマは次のように書く必要があります。

    h = (head ids :: forall b. b -> b) 3

  このような状況は、閉鎖された用語のアプリケーションのみで構成され、システムFで型指定可能な式はFPHに入力できないことを意味します。

  ルールSUBSはこれらの制限を解決します。ルールSUBSは、2つの関係の構成である `⪯⊑`と`⊑`の関係である `⪯⊑`という関係で、式のタイプを2つの方法で変更します。 Boxyインスタンス化と呼ばれる関係「⪯」は、ボックス内の多態型を単にインスタンス化します。
  保護されたunboxingと呼ばれる ``⊑`という関係は、単形型の周囲の箱を取り除き、箱を型の構造の下に合同的に押します。
  この関係の最も重要なルールはTBOXとREFLです。
  最初のものは単形型の周りのボックスを単に取り除きますが、2番目のものは反射性を保証します。 `aρ '`型が単形情報を持つ箱だけを含んでいるならば、これらの箱は `` ``関係に沿って完全に落として、箱のない型にすることができます。
  最後に、任意のコンストラクタの追加は、関数型の規則の直接的な適応であることを認識してください。

  SUBSは `⊑`の代わりに`⪯⊑`を使用するので、Example 3.1のhはタイプ可能です。
  `head ids`の型を推論するとき、次のような導出を行うことができます：

    Γ ⊢ head ids : ~[∀a.a → a]
    ~[∀a.a → a] ⪯ ~[a → a] ⊑ a → a
    ---------------------------------- SUBS
    Γ ⊢ head ids : a → a
    --------------------------- GEN
    Γ ⊢ head ids : ∀a.a → a

  ----

  Γ ⊢ e : σ′

    (x:σ) ∈ Γ
    ---------- VAR
    Γ ⊢ x : σ

    Γ ⊢ e1 : σ′1 → σ2′    Γ ⊢ e2 : σ3′   ⌊σ3′⌋ = ⌊σ1′⌋
    -------------------------------------------------- APP
    Γ ⊢ e1 e2 : σ2′

    Γ, (x:τ) ⊢ e : ρ
    ----------------- ABS
    Γ ⊢ λx.e : τ → ρ

    Γ ⊢ u : σ Γ, (x:σ) ⊢ e : ρ′
    ---------------------------- LET
    Γ ⊢ let x = u in e : ρ′

    Γ ⊢ e : ∀~(a).ρ′
    ----------------------- INST
    Γ ⊢ e : [~(a |→ τ′)]ρ′

    Γ ⊢ e : ρ′    ~(a)#Γ
    ----------------------- GEN
    Γ ⊢ e : ∀~(a).ρ′

    Γ ⊢ e : σ1′   ⌊σ1′⌋ = σ
    ----------------------- ANN
    Γ ⊢ (e::σ) : σ

    Γ ⊢ e : ρ1′    ρ1′ ⪯⊑ ρ2′
    --------------------------  SUBS
    Γ ⊢ e : ρ2′
  
  Figure 2: The FPH system

    σ1′ ⊑ σ2′
    
      ---------- TBOX
      ~[τ] ⊑ τ

      ---------- REFL
      σ′ ⊑ σ′

      σ1′ ⊑ σ1′′   σ2′ ⊑ σ2′′
      ------------------------- CONG
      σ1′ → σ2′ ⊑ σ1′′ → σ2′′

      ρ′ ⊑ ρ′′
      ~(a) unboxed in ρ′, ρ′′
      ------------------------- POLY
      ∀~(a).ρ′ ⊑ ∀~(a).ρ′′

      ~[σ1] ⊑ σ1′    ~[σ2] ⊑ σ2′
      ---------------------------  CONBOX
      ~[σ1 → σ2] ⊑ σ1′ → σ2′

    σ1′ ⪯ σ2′

      ----------------------- BI
      ~[∀~(a).ρ] ⪯ ~[[~(a |→ σ)]ρ]

      ------------------ BR
      σ′ ⪯ σ′

図3：保護されていないボックス化とboxyインスタンス化の関係

したがって、「h」に注釈は必要ありません。
   ちなみに、 `⊑`関係は単形型周辺の箱を取り除くことができるので、定義

    f = head ids

   タイプ可能です。
   より一般的には、以下の補題がある。

  **補題3.2** `Γ⊢e：〜[∀〜（a）τ]`ならば `Γ⊢e：∀〜（a）τ`。

  証明：ルールBIによって、（孤立した）∀〜（a）.τをインスタンス化することができます。
  新しく `〜（a）`を実行し、ルールTBOXを使用してボックスを取り除き、最後にルールGENを使用します。

## 3.3 プロパティ

  FPH システムは、システムFのセマンティクスに関してタイプセーフです。
  次の補題は、 `σ1′ ⪯⊑ σ2′` を常に観測すると容易に誘導され、 `⊢F ⌊σ1′⌋ ≤ ⌊σ2′⌋` であり、ここで `⊢F` はシステム F 型のインスタンス関係。
  関係 `⊢F` は、一連のインスタンス化と一般化を通じたある型の式の型別性を別の型と指定し、以下の規則によって与えられる:

  ~(b)#ftv(∀~(a).ρ)
  --------------------------------- FSUBS
  ⊢F ∀~(a).ρ ≤ ∀~(b).[~(a |→ σ)]ρ

#### 補題 3.3

   `Γ⊢e：σ'`なら` `⊢⊢Fe♭：⌊σ'⌋`で、` e♭ `は` e`から型名を単に取り除き、 `⊢F`は暗黙的に型付けされた型の関係です システムF.

   さらに、FPHはDamas-Milner型システムの拡張版です。
   以下の補題の考え方は、 `τ '型へのインスタンス化は常にインスタンス化をτ型に包含しているということです。

#### 補題3.4（ダマス・ミルナーの拡張）

   `Γ`は Damas-Milner タイプのみを含み、 `e` は注釈フリーであると仮定します。
   それで `Γ⊢DMe：σ`は`Γ⊢e：σ`を意味します。

   私たちは、逆方向も真実であると推測します。つまり、Damas-Milner型のみを使用するコンテキストでの注釈なしプログラムは、FPHで型指定可能な場合はDamas-Milnerで型指定可能ですが、将来の作業として残します。

## 3.4 ランクの高いタイプとシステムF

  3.1節のルールABSの議論で述べたように、今まで説明したシステムは、上位ランクのλ抽象化を意図的にサポートしていないため、システムFのすべてをまだ表現できません。
   例えば：

#### 例 3.5

    f :: forall a. a -> [a] -> Int
    foo :: [Int -> forall b.b->b]
    bog = f (\x y ->y) foo

  ここで、fooは `Int \∀bb→b`型でλ抽象化` \ xy-> y`をタイプする必要がありますが、λ-抽象化のための型は ` τ→ρ 'となる。
  我々は、新しい構文形式である注釈付きλ抽象を追加することでこの問題を解決することができる。したがって、（λx.e：：：σ1→σ2）。
  この構成は、引数（モノタイプ「τ」ではなく「σ1」）と結果（「ρ」ではなく「σ2」）の両方の注釈を提供します。
  その入力規則は単純です：

    Γ,(x :σ1) ⊢ e : σ2′ ⌊σ2′⌋ = σ2
    --------------------------------------- ABS-ANN
    Γ ⊢ (λx.e ::: σ1 → σ2) : σ1 → σ2

  この余分な構成を使用すると、図4の変換を使用して、暗黙的に型指定されたSystem FタームをFPHのよく型付けされたタームに変換できます。
  暗黙的に型付きされたシステムFのこのタイプ指向の変換は、「Γ⊢F eF：σ↝e`の判定として指定されます。ここで、「e」は、我々の言語で型チェックする項です。
  翻訳では、豊富なタイプ3を含むλ抽象のみでアノテーションが必要であることに注意してください。
  微妙な点は、変換によって開いたタイプの注釈が生成されることです。
  たとえば、暗黙的に型指定されたSystem F用語を以下に示します。

    ⊢ λx.e : ∀a.(∀b.b → a) → a

  図4を使用してこの用語を翻訳すると、

    ⊢ (λx.e ::: (∀b.b → a) → a)

   型の注釈にはどこにも束縛されていないものがあることに注意してください。
   この点については強調していませんが、FPHはすでにそのようなアノテーションに対応しています。

   ----

   もちろん、すべてのλ抽象化に注釈を付けるのは良いでしょうが、私たちが与える翻訳は、より小さな用語を生成します。

   ----

  Γ ⊢F eF : σ ↝ e

    (x:σ) ∈ Γ
    --------------- VAR
    Γ ⊢F x : σ ↝ x

    Γ ⊢F e1 : σ1 → σ2 ↝ e3    Γ ⊢F e2 : σ1 ↝ e4
    --------------------------------------------- APP
    Γ ⊢F e1 e2 : σ2 ↝ e3 e4

    Γ ⊢F e : ∀a.ρ ↝ e1
    ------------------------ INST
    Γ ⊢F e : [a |→ σ]ρ ↝ e1

    Γ ⊢F e : ρ ↝ e1 a#Γ
    -------------------- GEN
    Γ ⊢F e : ∀a.ρ ↝ e1

    Γ, (x:τ1) ⊢F e : τ2 ↝ e1
    ---------------------------- ABS0
    Γ ⊢F λx.e : τ1 → τ2 ↝ λx.e1

    Γ, (x:σ1) ⊢F e : σ2 ↝ e1
    ------------------------------------------ ABS1
    Γ ⊢ F λx.e : σ1 → σ2 ↝ (λx.e1 ::: σ1 → σ2)

  図4：システムFのタイプ指示翻訳

  次の定理は型指向翻訳の本質を捉えている。

  定理3.6 `Γ⊢Fe：σ↝e1`ならば、`Гσ'⌋=σ`となるような ``σ``に対しては `Γ⊢e1：σ'`となります。

  しかし実際には、アノテートされたλ抽象を新しい構文構造として追加することはお勧めしません。
  代わりに、双方向型システムでは、6.1節で概説するように、通常の型アノテーション「e ::σ」と同じ利点を得ることができます。

## 3.5 予測可能性と堅牢性

   FPHの重要な特徴は、プログラマがタイプ注釈がいつ必要なのかを簡単に把握できることです。
   私たちは第2節でいくつかの直感を示しましたが、今では具体的な結果を得る立場にあります。
   システムFからセクション3.4のFPHへの変換は、豊富な型で型指定されなければならないlet-bindingsまたはλ-抽象注釈だけを注記する必要があることを示しています。 これは、定理3.6と補題3.2を組み合わせた結果です。

   たとえば、システムFで型指定可能なすべての式（変数、定数、およびアプリケーションのみで構成される式）は、注釈のないFPHで型指定可能です。
   私たちはrunSTを含むこのような例でこの文書を始めました。そして、 `$`の代わりに逆アプリケーションを使用した場合も同様に動作します。

#### 定理 3.7

  `e`が適用式で`Γ⊢Fe：σ`ならば、 ``σ'⌋=σ`である ``σ``に対して ``Γe：σ``を返します。
  図2のルールを調べることで、この結果を確認するのは簡単です。
  関数は、任意のboxy型でインスタンス化することができますが、ルールAPPはボックスを無視します。
  さらに、 `let`バインディングは常にその出現場所でインライン化することができます。
  より正確には、Γ⊢がe：σ'でx = uとすると、Γ⊢[x |→u] e：σ'`となる。これは、次の補助定式に従います。
  補題3.8「Γ⊢u：σ」と「Γ、（x：σ）⊢e：σ」の場合、「Γ⊢[x |→u] e：σ」。
  2章で簡単に議論したように、システムF型の表現力が限られているため、逆方向は一般的に真ではありません（MLやMLFには当てはまります）。
  σ1=（∀bb→b）→（∀bb→b）、σ2=∀b。（b→b）→b→b、f1：σ1→Int、f2：σ2→Int 。次の形式のプログラムを想像することができます：

    ...(f1 (choose id))...(f2 (choose id))...

  これは型指定可能かもしれませんが、 `let x = id in ...（f1 x）...（f2 x）...`をタイプ可能にすることはできません。 `x`は（実際には `∀b。（b→b）→b→b）`のみである。

  しかし、文脈の中で出現するたびに式がボックスフリーの型で型付けされている場合、それは文脈の中で `let`-boundであるかもしれないことに注意してください。
  例えば、λ抽象化はboxfree型で行われるため、C [λx.e]が型付け可能である場合、Cがマルチホールコンテキストである場合、常にlet f =（λx.e） C [f] `は型指定可能です。

## 4.構文指向仕様

  FPHの実装方法を示します。
  アルゴリズム実装を確立するための第一歩は、非構文指向規則（SUBS、INST、およびGEN）を使用する場合には ``Γsde：ρ ''という判定を用いて型システムの構文指示型を指定することです。構文木の中の適切なノードにプッシュされました。
  その後、構文指向システムの低レベル実装を進めてもよい（セクション5）。私たちの構文指向のプレゼンテーションは図5に示されています。

  ルールSDVARは、補助判定「⊢instσ '≤ρ'`を使用して、環境にバインドされた変数のタイプをインスタンス化します。後者は `σ 'の最上位の量指定子をインスタンス化して'ρ '型を生成します。
  しかし、ボックスは新しいタイプの統一変数に対応するので、実際のアルゴリズムに近い「τ」タイプの代わりにボックスでインスタンス化します。

  ルールSDAPPはアプリケーションを扱います。関数の型 `ρ 'を推論し、矢印コンストラクタを公開するために`⪯`（図3）と `⊑→`（ `⊑`のサブセット）を使います。
  後者のステップは矢印統合と呼ばれます。
  次に、SDAPPはアプリケーションの引数に ``ρ3``型を推論し、環境に現れない空き変数を一般化し、その結果が必要な型よりも多相（System F型のインスタンスに沿って）であることを確認します。最後に、SDAPPは戻り値の型をインスタンス化します。

  規則SDABSは、λ抽象化の引数にτ型を使用し、 `ρ 'ρρ`を使用して、返される型がρ型にアンボックスされるように強制します。最後に、環境に出現しない抽象型の自由変数をすべて考慮し、任意のボックスに置き換えます。 λ抽象化のために返される型は `[a |→σ]（τ→ρ）`です。

  一般化とインスタンス化のこの最後のステップは、おそらく不可解です。
  すべてのルールABS（図2の宣言的仕様）は、λ抽象にボックスフリーのタイプしか持たないように思われます。
  それが必要な理由を示す例を次に示します。

#### Example 4.1（λ抽象におけるインプリメンテーションのインスタンス化）

   次の導出が成り立ちます： `Γ⊢（λx.x）ids：〜[[∀a.a→a]]`。

  Γ ⊢sd e : ρ′

    (x:σ) ∈ Γ ⊢inst σ ≤ ρ′
    ------------------------- SDVAR
    Γ ⊢sd x : ρ′

    Γ ⊢sd e1 : ρ′    ρ′(⪯⊑→)σ1′ → σ2′
    Γ ⊢sd e2 : ρ3′    ~(a) = ftv(ρ3′) − ftv(Γ)
    ⊢F ⌊∀~(a).ρ3′⌋ ≤ ⌊σ1′⌋    ⊢inst σ2′ ≤ ρ2′
    ------------------------------------------  SDAPP
    Γ ⊢sd e1 e2 : ρ2′
    
    Γ, (x:τ) ⊢sd e : ρ′
    ρ′(⪯⊑)ρ    ~(a) = ftv(τ → ρ) − ftv(Γ)
    --------------------------------------------------- SDABS
    Γ ⊢sd λx.e : [~(a |→ ~[σ])](τ → ρ)

    Γ ⊢sd u : ρ′   ρ′(⪯⊑)ρ
    a = ftv(ρ) − ftv(Γ)    Γ, (x:∀~(a).ρ) ⊢sd e : ρ1′
    ----------------------------------------------- SDLET
    Γ ⊢sd let x = u in e : ρ1′
    
    Γ ⊢sd e : ρ1′    a = ftv(ρ1′) − ftv(Γ)
    ⊢F ⌊∀a.ρ1′⌋ ≤ σ ⊢inst σ ≤ ρ′
    ----------------------------------------------- SDANN
    Γ ⊢sd (e::σ) : ρ′

  ⊢inst σ′ ≤ ρ′

    -------------------------- SDINST
    ⊢inst ∀a.ρ′ ≤ [~(a |→ ~[σ])]ρ′

  σ′ ⊑→ σ1′ → σ2′

    ------------------- BOXUF
    ~[σ1 → σ2] ⊑→ ~[σ1] → ~[σ2]

    --------- NBOXUF
    σ′ ⊑→ σ′

  図5：構文指向制約付きBoxy型システム

  例4.1の派生を構築するには、次のように、多態的な引数型を使って `λx.x`をインスタンス化できることを観察してください：

    Γ,(x :a) ⊢ x : a
    ----------------- ABS
    Γ ⊢ λx.x : a → a
    --------------------- GEN
    Γ ⊢ λx.x : ∀a.a → a
    ------------------------------------- INST
    Γ ⊢ λx.x : ~[[∀a.a → a]] → ~[[∀a.a → a]]

  GENとINSTの使用は、ids：[∀a.a→a]に適用される用語を作る上で不可欠です。
   SDABSの一般化とインスタンス化により、各λ抽象化でGENとINSTが実行されます。これは、SDLETが各「let」バインディングでGENを確実に実行するのと同じくらいです。

   ルールSDLETは簡単です。 ボックスを含む可能性のあるuの型を推論した後、 `ρ`型を得るためにボックスを`⪯⊑`で削除できることを確認します。

   最後に、ルールSDANNは、式「e」に対して型「ρ1」を推論し、環境にない自由変数に対して一般化し、この型が注釈よりも多型であることをチェックする。 最後のステップとして、注釈タイプがインスタンス化されます。

   現在、宣言的なシステムに関して、構文指向システムの健全性を確立することができます。

####定理4.2（ `⊢sd`の健全性）

  `Γ⊢sde：ρ'`ならば`Γ⊢e：ρ'`となります。

  この証明は、導出ツリーに対する直接的な誘導である。
  最も興味深いのは、補題補題4.3を使用し、 `⊑→`が `⊑`の部分集合であるという事実と共に、次に与えられるアプリケーションです。

####補題4.3もしΓe：σ1 'と⊢F

  `` `` = `` `` `` `となるよう` `` `` `` `` `` `` `` `` `` `::` `` `` ``

  逆に、構文指向システムは、次の定理に示すように、宣言システムに関して完全です。

####定理4.4（⊢sdの完全性）

  `Γ⊢e：ρ'`ならば`Γ⊢sde：ρ0'`となり、 `ρ0 '⪯⊑ρ'`となる。
  この定理を証明することは健全性よりも難しい。
  我々は、実際に、以下のように、「⊢F」関係の叙述的制限を用いて、定理4.4のステートメントを一般化する必要がある。

    b＃ftv（∀a.ρ）
    ----------------------------シャツ
    ⊢DM∀a.ρ≤∀b。[a |→τ]ρ

  （x：σ1）∈Γ1ならば、（x：σ2）∈Γ2、⊢DMσ2≤σ1となるようなσ2が存在するならば、⊢DMΓ2≤Γ1と書く。
  今、もっと一般的な完全性ステートメントを述べることができます。

####補題4.5

  `Γ1⊢e：∀a.ρ'`とする。そして、すべてのσについて、Γ2⊢sde：ρ0 'とρ0'⪯⊑[a |→σ]ρが存在するようなρ0が存在する''。

  さらに、結果は、さらに低レベルのアルゴリズム（セクション5で説明する）によって構文指向システムの実装性を示すための重要な要素です。

####推論4.6（強化）

  「Γ1⊢sde：ρ1」と「⊢DMΓ2≤Γ1」の場合、Γ2⊢sde：ρ2'`となり、ρ2 '⪯⊑ρ1'`となる。

  証明は、定理4.2と補題4.5の組み合わせである。

####推論4.6
  
  「⊢DM」という叙述にしたがって、環境内の表現のタイプを最も一般的なものに変更すると、型の可用性に影響を与えないことを意味します。
  このプロパティは型推論の完全性のために重要です。環境内でプッシュされるすべての型はボックスフリーであり、したがって `⊢DM`関係によって異なるだけです。それらの多型部分は注釈によって決まります。
  実際には、アルゴリズムは `` ``に基づいてそれらの中で最も一般的なものを選択します。
  したがって、最も一般的な型を持たない環境でバインディングを持つ宣言型システムで式を型指定できる場合、これらのバインディングに最も一般的な型が割り当てられている場合、式も型指定可能であることがわかります。アルゴリズムが推論する型。

## 5.アルゴリズムの実装

  図5の構文指向仕様は、MLFのアルゴリズムに似ている低レベル制約ベースのアルゴリズムによって実装できます。
  概念実証の実装、アルゴリズムの不変量とプロパティの記述は

    www.cis.upenn.edu/~dimitriv/fph/

  Hindley-Damas-Milner型推論のように（Damas and Milner 1982; Milner 1978）、我々のアルゴリズムは、多態型をインスタンス化し、抽象化の引数型として使用するための新しい統合変数を作成する。
  Hindley-Damas-Milner型の推論では、これらの変数は他の型と統一されています。
  したがって、HindleyDamas-Milner型推論エンジンは、各統一変数を​​ある種の型にマップする等式制約のセットを保持し、型推論が進むにつれて制約を更新します。

  我々のアルゴリズムは、Hindley-Damas-Milner型推論に類似の構造を使用するが、型推論の間に等価とインスタンスの両方の制約を維持するので、統一変数の代わりに制約付き変数という用語を使用する。
  アルゴリズムの制約付き変数は、高水準仕様のボックスに対応します。
  制約付き変数と（厳密な）定量化された変数を区別するために、前者にはギリシャ文字「α」、「β」を使用します。
  したがって、このアルゴリズムでは、次の構文で型を操作します。

    τ** :: = a | τ□→τ* | α
    ρ*：=τ* | σ*→σ*
    σ** :: =∀a.⋆*

  インスタンスの制約の必要性は、導入から `choose ids 'をタイプすることによって動機づけることができます。
  第1に、 `choose`は`∀a.a→a→a`型であるので、新たな制約付き変数αを用いて数量化された変数aをインスタンス化することができる。
  しかし、引数 `id`を満たすとき、αが` `β``と等しくなければならないか（` `id``の型をインスタンス化することによって生じる）、` `∀bb→b`` `id`をインスタンス化しないでください）。高水準仕様では、私たちは、私たちに合った（潜在的にボックス化された）選択肢を明快に作ることができます。
  このアルゴリズムは、透視感の贅沢を持っていないので、選択肢を作るのではなく、単純にインスタンス制約を記録する必要があります。
  この場合、インスタンス制約は、「α」が「∀b.b→b」の任意のシステムFインスタンスであることを指定する。
  これを表現するために、最初の近似では、「α≥σ*」という形の制約が必要です。

  しかし、この制約の形式を少し超えていく必要があります。
  プログラム `f（choose id）`を考えてみましょう。 `f`は`∀c.c→c`型です。
  定量化された変数cを新しい変数γでインスタンス化した後、 `γ`を` choose id`の型で制約する必要があります。

    γ≧（主要なタイプの選択id）

  しかし、 `choose id`の主な型は、同時に定量化され、制約される型でなければなりません：` [α≧∀b.b→b]⇒α→α`。
  MLF（Le Botlan and Remy 2003）に従うと、このスキームは、 `∀d。（d→d）→（d→d）`や `（∀bb→b）→ ∀bb→b） `。
  したがって、拘束変数の境界を `γ≥σ`を含むように拡張します。ここで、`σ`はスキームです。

    Schemes              ς ::= [c1, ..., cn ]⇒ρ⋆
    Constraints          c ::= α = σ⋆ | α ≥ ς | α ⊥
    Constraint sets  C,D,E ::= {c1, ..., cn} (n ≥ 0)

  拘束「α⊥」は、「α」が拘束されていないことを意味する。
  通常のシステムF型は、量的変数が拘束されていないスキームとして見ることができるので、 `∀b.b→b '型は` [β⊥]⇒β→β`と書くことができます。
   制約「γ≧σ」の意味は、「γ」がσを表すシステムF型の集合に属し、[[σ]]と書くということである。
   例えば、 `Ã=α（α≥β⇒β→β）]⇒（α→α）`ならば、

     （∀b.b→b）→（∀b.b→b）∈[[σ]]
     ∀c。（c→c）→c→c∈[[σ]]
     ∀c。（[c]→[c]）→[c]→[c]∈[[σ]]

   ----

   実際の制約の形式は、環境に入る変数が量指定子を持つ型に決して等しくないことを保証する必要があるため、少し複雑ですが、説明を簡潔にするためにここでは示しません。

  ----

## 5.1 推論の実装

   関数推論は、図5の構文指示型の提示に従って、タイプ推論アルゴリズムを実装します。
   この関数には次のシグネチャがあります

     推論：Constraint * Env * Term→Constraint * Type

   制約「C1」、環境「Γ」、および用語「e」を受け入れる。
   `infer（C1、Γ、e）`への呼び出しは `fail`で失敗するか、更新された制約C2と型`ρ* `を返します。
   スキームの力を示す最も興味深いケースは、アプリケーションの実装です。

    infer(C, Γ, e1 e2) = E1, ρ1⋆ = infer(C, Γ, e1)              (1)
                        E2, σ1⋆ → σ2⋆ = instFun(E1, Γ, ρ1⋆)    (2)
                        E3, ρ3⋆ = infer(E2, Γ, e2)             (3)
                        E4, ς3 = generalize(Γ, E3, ρ3⋆)        (4)
                        E5 = subsCheck(E4, ς3, σ1⋆)            (5)
                        inst(E5, σ2⋆)                          (6)

`infer（C、Γ、e1 e2） 'の呼び出しでは、以下のステップを実行します。

  （1）まず、「推論（C、Γ、e1）」を呼び出すことによって、「e1」の型「ρ1***」と更新された制約「E1」を推論する。

  （2）しかし、 'ρ1**'型は、それ自身が制約型変数であってもよい。つまり、構文指向型仕様の1つのボックスに対応していてもよい。関数 `instFun（E1、Γ、ρ1**）`は ``→ ``の関係の低レベル実装です。

  （3）次に、引数 `e2`の型と更新された制約を` E3、ρ3⋆= infer（E2、Γ、e2） `と推論する。

  （4）この時点で、関数の引数型 `σ1** 'を、引数について推論した型と比較する必要があります。
  しかし、我々はまだ引数の正確な型を知らないので、新しい制約「E4」とスキーム「σ3」を得るために `generalize（Γ、E3、ρ3**） 'と呼ぶ。
  スキーム `σ3`は、引数` e2`のすべての可能な型の集合を表します。
  関数generalizeは、ヒンドレー・ダマス・ミルナーの通常の一般化の適切な一般化であり、我々の設定に適合している。

  （5）引数 `e2`のすべての型を表現するスキーム`σ3 'があるので、 `σ3`が表す集合に所要の型`σ1**`が含まれていることを確認する必要があります。
  これは `subsCheck（E4、σ3、σ1**） 'を呼び出すことで実現されます。これは、`σ3`がセットに含まれているときに更新された制約E5を返します。
  「E5」という制約の下で。

  （6）最後に、タイプσ2は、いくつかの型 `∀a.ρ2*`に等しくてもよい。これは新鮮な `α`に対して` [〜（a |→α）]ρ2⋆`にインスタンス化する。
  これは、 `inst（E5、σ2**） 'を呼び出すことで実現され、構文指向のプレゼンテーションの`⊢inst`判定を実装します。

アプリケーション `e1 e2`では、引数` e2`が一般化されていることがわかります。
  実際には、e2が必要とする予想される型に対して引数 `e2`をチェックできる双方向実装では、この手順は必要ありません。
  6.1節でこの点に戻ります。

  スキームが推論にローカルな出現をすることに注意してください。generalizeはscheme（4）を計算し、subsCheckはそれを消費します（5）。
  したがって、私たちのアルゴリズムでは内部的にMLF型（私たちの体系である）が使われますが、プログラマには公開されません。
  第7章では、対応についてさらに詳しく説明します。

  「推論」の別の注目すべき部分は、レット・バインドされた表現またはλ抽象体の制約付き変数の単相性を強制することに関連する。
  直感的には、レットバインド式の型を推論した後、 `⪯⊑`に沿ってインスタンス化をボックスフリー型に実装する必要があります。
  これは、レット・バインド式のタイプ内のすべての柔軟な境界がインスタンス化されることを必要とし、そのタイプのすべての制約付き変数が実際には単一型にマップされるというチェックが実行されます。
  一般化されたHindley-Damas-Milnerの場合と同様に一般化が進められる。

## 5.2アルゴリズム実装のプロパティ

  アルゴリズムの実装の終了、健全性、完全性を示しました（Vytiniotis 2008）。
  健全性と完全性の特性を述べるためにboxy置換を定義する。
  制約付き変数から制約付き可変自由型への置換θが与えられたとき、ボックス内の「θ」の範囲を代入する、「θ[σ≦]」と表される、「σ* `σ*`の内側にキャプチャを避ける方法。
  例えば、「θ」が置換「[α|→σ]」である場合、「θ[α→α] =σ→σ」である。
  すべての制約付き変数が置換のドメインに現れる場合、ボックス型置換を使用してアルゴリズム型から仕様型を復元します。
  我々は、通常の「θ」の「σ*」への置き換えのために「θσ*」と書く。

  また、置換と制約を接続する必要があります。
  制約付き変数からシステムF型への置換「θ」は、以下のスキームの解釈を尊重するときは常に制約「C」を満たすと言われている。
  `C`。
  特に `（α=σ*）∈C`ならば、それは`θα=θσ`でなければならず、 `（α≧σ）∈C`のときは常に`θα∈[[θσ]]でなければならない。

  これらの2つの定義では、構文指向の仕様をアルゴリズムと結びつけて、健全性と完全性を述べることができます
  実装。

####命題5.1（推論の健全性）

  もし `` infer（∅、・、e）= C、ρ* `ならば、` C 'を満たす全てのθに対して `・⊢sde：θ[ρ*]`が成り立つ。

####命題5.2（推論の完全性）

  もし、（∅、ε、ε）= C、ρ*を仮定すると、Cを満たす置換θが存在し、θ[ρ*]ρρ ' `。

  命題5.1と5.2は、図2の宣言的仕様の実装を保証します。
  プログラムは一般的にモジュロボックスの主要な型を持っていませんが、健全性と完全性の結果は、ボックスフリー型のプログラムは基本的なボックスフリー型であることに注意してください。

## 6.ディスカッション

  このセクションではFPHへのいくつかの拡張を提示し、代替設計について議論する。
  Vytiniotis（2008）は、より多くの詳細といくつかの追加の設計選択肢を提示している。

## 6.1双方向性

  型注釈の双方向伝播は、FPH内の必要な型注釈の量をさらに減らすことができる。
  FPHの仕様に双方向アノテーションの伝播を追加することは比較的簡単です（例えば、（Peyton Jones et al。2007）を参照）。
  この双方向アノテーション手順は、別々の前処理パスとして実装できます。ただし、オープン型の注釈をサポートしていれば、
  および注釈付きλ-抽象化。あるいは、この手順は、「Γ⊢sde：↑ρ」という形式の推論判定とチェック判定「Γ⊢sde：⇓ρ」とを組み合わせることによって実現することができる。
  必然的に、この双方向システムは構文指向です。特殊なレベルの判定「Γ⊢sd ** e：⇓σ」は、以下のように多型との比較を行います。

    Γ⊢sde：⇓ρ '〜（a）＃Γ
    -------------------------- SKOL
    Γ⊢dde：⇓∀〜（a）.ρ '

    Γ⊢sde：⇑ρ 'a＃Γ
    ⊢F⌊∀〜（a）.ρ'⌋≤σ
    -------------------------- CBOX
    Γ⊢sde e：⇓〜[σ]

  ルールSKOLは単にトップレベルの量指定子を削除し、その型の本体に対して式をチェックします。
  規則CBOXは、単一のボックスに対して式をチェックします。
  この場合、その内容を使用することができないので、式の型を推測する必要があります。
  アノテーションはもはや局所的に多形性を明らかにするのではなく、アノテーションを用語構造の中に伝播する。
  以下のルールANNINFは、最初にアノテーションσに対してeをチェックすることによってアノテーション付き式e ::σの型を推論します。

    Γ⊢sd** e：⇓σ⊢instσ≤ρ '
    ---------------------------- ANN-INF
    Γ⊢sd（e ::σ）：↑ρ '

  λ抽象化の型を推論する規則はSDABS規則に似ていますが、λ抽象性を検査する規則では、今度は `σ1 '→σ2'型の型に対して関数を検査することができます。

    σ1 '⊑σ1Γ、（x：σ1）⊢sde e：⇓σ2'
    -------------------------------------- ABS-CHECK
    Γ⊢sdλx.e：⇓σ1 '→σ2'
  
  「σ1」は環境に入力する前にボックスフリーでなければならないことに注意してください。

  これらの追加によって、公開型アノテーションのサポートがあると仮定すると、FPHオリジナルシステムのように、単に「τ→ρ」型よりも複雑な型を持つ関数をタイプすることができます。例えば3.4節の例3.5を思い出してください。

    f :: forall a。 a - > [a] - > Int
    foo :: [Int - > forall b.b-> b]

    bog = f（\ x y - > y）foo

  ボグは（双方向システムであっても）型を決めることはできませんが、（通常の）アノテーションで回復できます：

    bog = f（\ x y - > y> Int - > forall b。b - > b）foo

  注釈付けされたλ抽象化（3.4節）のための特殊な形式は、双方向システムでは必要ありません。実際、私たちの実装は、基本的な構文指向型システムの双方向バージョンです。

## 6.2η変換と深いインスタンス関係

  FPHシステムは、システムFおよびMLFに反して、η拡張下では安定ではない。特に、環境内で `f：σ→Int`がある場合、` x`は `τ`型にしか割り当てられないので、必ずしも`λx.fx`が型付け可能であるとは限りません。

  当然のことながら、FPHはシステムFに基づいているため、η削減の下では安定していません。
  式 `λx.ex`が文脈` C [（λx.ex）] `をタイプ可能にするならば、` C [e] `が型指定可能であるとは限りません。
  以下のコードを考えてみましょう：

    f :: Int - > forall a。 a - > a
    g :: forall a。 a - > [a] - > a
    lst :: [forall a。 Int - > a - > a]

    g1 = g（\ x - > f x）lst - OK
    g2 = gf lst - 失敗！

  lst`は→のA`→∀a.Int `タイプG``のインスタンス化を必要とするので `F`は`のInt→∀aa型を持つ `一方g2`（暗黙に型付けされたシステムFでuntypeable）`内のアプリケーションは、失敗します→a。システムFに基づいたFPHシステムは、これらの2つのタイプが同形であることを理解するのに十分強力ではありません。

  このような変換は、ミッチェルのFη（ミッチェル1988）（例えば（ペイトン・ジョーンズら。2007））の叙述変種にサポートするのが容易であるものの、impredicativityの存在は、それらをサポートする当社の能力を複雑にします。実際、今日まで提案されている批判的なインスタンス化を持つ型推論システムは、すべてのη変換の下でプログラムの型性を維持していません。
  我々は現在、彼らはトップレベルだったかのように矢印の右側に数量詞を扱ういくつかの「深い」バージョンに私たちのインスタンスの関係を拡張する方法を模索したが、impredicativeインスタンス化して、将来の仕事の主題のままであることを組み合わせています。

## 6.3代替デザインの選択肢

  私たちの設計選択肢は、シンプルさと表現力の間の妥協点です。
  このセクションでは、2つの選択肢を簡単に示します。

####より表現力豊かな型の抽象化の入力

  λ抽象はボックスフリータイプのみでタイプされていることを思い出してください。
  これは、サンクなどの特定の変換によって型性が損なわれる可能性があることを意味します。
  たとえば、次のコードを考えます。

    f1 :: forall a. (a -> a) -> [a] -> Int
    g1 = f (choose id) ids -- OK

    f2 :: forall a b. (b -> a -> a) -> [a] -> Int
    g2 = f (\ _ -> choose id) ids -- fails!

  この例では、g1型チェックの間、サンクは型の能力を壊します。型 `〜[∀a.a→a]→〜[∀a.a→a]`はunboxできません。
  明白な選択肢は、λ抽象の結果として任意の `ρ '型を許可し、抽象化の引数として`τ'型を許可するために環境がボックスフリーであるという不変量を上げることです。
  このような変更により、より少ないタイプの注釈が可能になりました（抽象的なボディは批判的なインスタンス化を使用する可能性があり、注釈は必要ありません）。それを実装できる健全かつ完全なアルゴリズムは認識していません。
  Vytiniotis（2008）は、合併症の詳細な説明を提供します。

#### ボックスフリー仕様

  タイプ注釈が必要な場所を安全に近似することは、リッチタイプの `let`-bindingsまたはλ-abstractionにあります。
  おそらく驚くべきことに、このガイドラインをさらに進歩させると、豊富な種類のバインディングで注釈が常に必要な場合、仕様にボックスは必要なくなります。
  図2の型システムを考えてみましょう。

  1.すべての入力規則からすべてのboxy構造体を削除します。つまり、すべての `ρ '、σ'`型を`ρ`型と `σ`型に置き換え、SUBSと`⪯⊑`を完全に削除します。規則INST内の任意の `σ`型でインスタンス化します。

  2.ルールLETとABSをDamas-Milnerタイプの対応するバージョンに置き換えます。

    Γ⊢u：∀〜（a）τ
    Γ、（x：∀〜（a）τ）⊢e：ρ
    -------------------------- LET
    Γ⊢e =ρでx = uとする。

    Γ、（x：τ1）⊢e：τ2
    -------------------- ABS
    Γ⊢λx.e：τ1→τ2

  3.注釈付きのレットバインディングとλ-抽象化のための規定を追加する：


    Γ⊢u：σΓ、（x：σ）⊢e：ρ
    --------------------------------- LET-ANN
    Γe e：ρにおいてx ::σ= uとする。

    Γ、（x：σ1）⊢e：σ2
    --------------------------------- ABS-ANN
    Γ⊢（λx.e:::σ1→σ2）：σ1→σ2

  得られる型システムは、FPH型システムと本質的に同じアルゴリズムを使用することによって、健全かつ完全な型推論を楽しむ。
  しかしながら、この変形は、ボックスベースのFPHよりもタイプ注釈においてより厳しいものである。たとえば、豊富な型を使用するすべてのレットバインディングに注釈を付ける必要があります。たとえその型が致命的なインスタンス化を伴わなかったとしてもです。
  例えば：

    f :: Int - >（for a a a - > a） - >（for a a a - > a）
    h = f 42 - 失敗する！

  hの束縛は豊富な型を持っているため、注釈を付ける必要がありますが、批判的なインスタンス化は行われません。型の注釈でこの単純化がより厳しくなっていることを考えると、実際の実装にはあまり適していないと考えられます。

## 7.関連する仕事

  最近の提案では、ファーストクラスの多型のためのアノテーション駆動型の推論が提案されていますが、これは仕様の簡素化、実装、型名の配置、表現力が異なります。
  下記の広範な比較と表6の簡単な概要を示します。
  MLF、Rigid MLF、およびHML Le BotlanとRemy（Le Botlan and Remy 2003; Le Botlan 2004）のMLF言語は、この作品に部分的に影響を与えました。
  この言語と他のアプローチの最大の違いは、すべての式の主型を復元するために、 `∀（Q）τ`という形式の制約でシステムF型を拡張することです。
  したがって、let-expansionは、System Fタイプのみを使用するシステムとは異なり、MLFで型性を保持します。タイプ言語はより表現力豊かであるため、MLFでは厳密に少ないアノテーションしか必要としません。
  MLFでは、いくつかの変数が2つ以上の多型で使用されている場合にのみ注釈が必要です。対照的に、言語では、豊富な型で定義された変数に注釈を付ける必要があります。
  例えば、以下のプログラム

    f = \ x - > x ids

  xは一度しか使用されないため、MLFでアノテーションを必要としません。
  FPHでは、xに対してアノテーションが必要です。
  それゆえ、我々はより制限的である。

  MLFの欠点は、その仕様の複雑さです。拘束型は宣言型システムに現れ、MLFのインスタンス関係にはそれらを含める必要があります。
  FPH仕様には制約に基づくインスタンス関係は必要ありませんが、低レベル実装はMLF実装のバリエーションです。仕様には制約ベースのインスタンス関係が公開されていないため、アルゴリズムをSystem Fタイプのセットを直接操作するように公式化することができます。
  対照的に、MLFは、構文的インスタンス関係としてシステムF型のセット間のサブセット関係を内部化し、このやや複雑な関係に関して型推論を形式化する。
  Le BotlanとRemy（2007）は、MLFのセットベースの解釈を最近の報告書で研究しており、これは計画の集合論的解釈に影響を与えた。

  FPHとMLFの間には技術的な相違点があります。
  MLFの背後にある重要なアイデアの1つは、すべてのポリモフィックインスタンシエーションが制約型変数の背後に隠されていることです。当社のタイプシステムは、同じ目的のために匿名ボックスを使用します。
  FPHの匿名ボックスは、厳格に制約されたMLF変数に対応します。実際、FPHタイプのシステムは、柔軟な境界を持たないMLFのバリエーションとして記述することができます（Vytiniotis 2008）。
  さらに、FPH型の導出における箱型インスタンス化 `⪯`と保護されたunboxing`⊑`の使用法は、MLF等価物の使用法に対応しています
  `∀（α=σ）.α≡σ`と`∀（α=τ） `である。 σ≡[α|→τ]σとする。

  最後に、MLFはソース言語であり、明示的に型指定されたSystem Fなどの明示的に型指定された中間言語に変換されます（LeijenとLoh 2005）。
  コンパイラに適しており、用語レベルの強制を必要としないMLF用の型付き中間言語を考え出すことは、依然として研究の対象です。
  対照的に、FPHはシステムFに基づいているため、FPHをシステムFに精緻化するのは簡単です。

  表現力においてFPHに類似するMLFの変形は、Leijenの剛性MLF（Leijen 2007）である。
  FPHと同様、リジッドMLFには制約付きタイプは含まれていません。
  代わりに、let-nodeで柔軟な境界をインスタンス化することによって制約を解決します。
  ただし、リジッドMLFはMLFインスタンスの関係を使用して指定されます。
  したがって、環境内の型はSystem F型であるにもかかわらず、型定義性を理由にMLF機械を使用する理由があります。
  さらに、リジッドMLFのルールでは、

| |仕様|実装|注釈/タイプ可能なプログラムの配置|
| HMF |シンプルな「最小限度」の制限|シンプル|豊富な型を持つλ抽象、および多態性を保たなければならない引数にアノテーションが必要な場合があります。
| MLF |ヘビー級、宣言的|ヘビー級| 2つ以上の型で引数を使用する場合にのみ必要な正確な注釈|
| Boxyタイプ|複雑な構文指向の暗いコーナー|シンプル|明確なガイドラインがなく、注釈なしでタイプされたシステムFの断片が明確ではない|
| HML |制約に基づく宣言型|ヘビー級|多型関数の引数に関する正確なアノテーション
| FPH |単純な宣言的な|ヘビー級|豊富な種類のlet-bindingsとλ-abstractionの正確な注釈、注釈のないすべての適用可能なSystem Fの用語など|

  図6：関連性の高い関連作品の概要

  レットバインド式の場合、レットバインド式の入力派生に使用される型が最も一般的です。
  プログラマーに最も一般的なMLF制約ベースのタイプの考え方を要求することは、元のMLF提案のようにMLF制約を理由に考える必要がある場合よりも複雑な場合もあります。

  有望なMLFのバリエーションはLeijenのHMLシステムです（Leijen 2008b）。
  特に、HMLは柔軟な境界を保持しているため、プリンシパルタイプをMLFとして使用していますが、厳密な境界を完全にインラインしています。
  MLFとは対照的に、アノテーションはFPHのように多態的なすべての関数引数に置く必要がありますが、（FPHとは逆に）レットバインド定義には注釈を必要としません。
  HMLシステムには依然として制約のある推論が含まれていますが、厳格な境界がない場合、MLF抽象関係の導入は必要ありません。

####ボクシータイプ
  
  Boxy Types（Vytiniotis et al。2006）は、ファーストクラスの多型の型推論に対処するための著者の初期の提案である。
  この論文のように、Boxy Typesはボックス型System F型を使用して多態性を隠します。ボックスはimpredicativityをマークするエレガントな方法を提供するので、我々はこの作業でその構文を再利用しました。

  しかし、以前の研究では、ボックスは異なる役割を果たしました。
  Boxy Typesでは、ボックスは、型推論と双方向アノテーション伝播を組み合わせた、ある型アノテーションの結果であるものから推定された型の部分を単に区別します。
  「Γ⊢e：ρ」の形式のBoxy Types判定では、ρ型の入力を型チェッカーへの入力とみなし、ρのボックスに記入する必要があります。
  この作品では、 ``ρ``型は出力であり、箱は単純に叙述的なインスタンス化が行われた場所をマークします。

  Boxy型は、ヒントレー・ダマス・ミルナー統一を局所的な注釈伝播で適度に拡張する比較的簡単なアルゴリズムを使用して実装されました。
  アルゴリズムはインスタンス制約を操作しないため、インスタンス化を遅延させることはできません。
  したがって、タイプシステムはローカル決定を下す必要があります。
  特に、Boxy Typesでは、ボックスの内容をあまりに早くunboxするプログラムが必要になることがよくあります。
  タイプ推論の完全性のために、ボックスの内容に関する情報がローカルで利用可能でない場合、それは単相型を含む必要があります。
  その結果、基本的なBoxy Typesシステムには多くのタイプの注釈が必要です。 N-aryアプリケーションのようなアドホックヒューリスティックおよび精巧な型包含方法は、注釈負担を軽減するが、システムの仕様および予測可能性をさらに複雑にする。

  いくつかのプログラムはBoxy型で型指定可能であり、FPHでは（注釈のない）型指定ができませんが、FPHのより簡単な仕様は劇的な改善であると考えています。

  HMF LeijenのHMFシステム（Leijen 2008a）は、この手続きの仲間の論文でもあり、デザインスペースのもう一つの興味深いポイントです。
  HMFシステムは、特に単純な推論アルゴリズム（アルゴリズムWの変形）と、FPHよりも単純な推論アルゴリズムとを享受する。
  代わりに、型定義ルールは形式的に多少異なりますが、タイプ注釈が必要な場所と必要がない場所を正確に予測することはやや難しくなります。

  HMFの重要な特徴は、巧妙なアプリケーションルールであり、ここでは批判的なインスタンス化はローカルマッチ手順によって決定される。
  タイプ・システムでは、このアプローチは、（i）環境に入るすべてのタイプがプログラムに割り当てることができる最も一般的なタイプであること、（ii）許可されているすべての機能の認定インスタンシエーションが、返されたアプリケーションの多態性を「最小化」します。

  ローカルマッチプロシージャは、HMFが賢明な決定を下すことを意味します。一般に、プログラマが特に指定しない限り、多態関数はデフォルトでインスタンス化されます。
  たとえば、プログラムの単一ID（singleは `∀a.a→[a]`型）は `[∀a.a→a]`型では入力できません。
  idのトップレベルの量指定子は、ローカルマッチプロシージャの前に、早すぎるインスタンス化されます。
  FPHは制約を使用してインスタンス化を遅らせるので、この式に `[〜[∀a.a→a]]`を入力することができます（ただし、let-bindにはまだ注釈が必要です）。
  HMFでは、関数singleに注釈をつけたり、idの型がインスタンス化されてはならないという厳格な型の注釈を指定することができます： `（single（id :: forall a。a - > a）` .5 HMF注釈は見つかったアノテーションとは異なる、例えば、Haskell-eg （id :: forall a。a - > a）42は拒否されます。

  Leijenは、ローカルマッチプロシージャは、一般に、プログラム変換には堅牢ではないことを認識している。 `（revcons ids）`が（ `revcons`の型が`∀a。[a]→a→であれば）、 `（revcons ids）id`は` [a] `）。
  したがって、これらの問題は、HMFにおいて、アプリケーション内のすべての引数からの型情報を使用する「N」型アプリケーション型付け規則を使用することによって回避される。

  一般に、HMFでは、豊富な型を持つλ抽象と多型を保つ必要のある引数についてアノテーションが必要です。
  たとえば、 `f：∀aa→...`と `arg：∀b.τ`の場合、アノテーションが必要になります。` f（arg ::∀b.τ） `は、`∀b τ 'である。
  しかし、場合によっては、アノテーション伝播および「N」アプリケーションがそのような注釈を冗長にすることがある。

  HMFは派生の中で最も一般的な型を必要とするため、HMFではタイプ可能なプログラムがありますが、FPHではプログラムがありません。たとえば、 `let g = append ids in ...`はFPHのアノテーションを必要としますが、HMFではシームレスに型チェックを行います。
  一方、柔軟なインスタンス化により、FPHは

  ----

  最終的な可能性は、「∀a.a→a」という注釈が何らかの形で「id」に伝播されたことになります。

  ----

    f :: forall a. [a] -> [a] -> a
    g = f (single id) ids

そこではHMF（注釈の伝播があっても）が失敗します。
   全体として、FPHに必要なアノテーションの配置は、HMFよりも記述がやや簡単だと考えています。 しかし一方で、HMFは非常に簡単な実装とメタデータを持っています。

#### その他の研究

  完成のために、私たちはもっと遠くにつながっている作品のいくつかを概説します。
  システムFの（暗黙的に型付けされた）完全型再構成は決めることができない（Wells 1999）。
  KfouryとWellsは、システムF型をランク別に階層化し（関数型の左にあるポリモズム）、システムFの型再構成の決定不可能性を示します
  ランク3以上のタイプ。一方、システムFのランク2フラグメントは決定可能である（Kfoury and Wells 1994）。

  Pfenning（1988）は、タイプ抽象化とタイプアプリケーションの位置はわかっているが、関数の引数のタイプは知られていないn次多形λ-計算の部分タイプ推論でさえ、n次統一と同等であることを示している決めることはできません。
  最近の研究（Le BotlanとRemy 2007）は、System Fのすべてを埋め込むために、多型関数の引数注釈（型抽象と型アプリケーションではない）だけが必要であることを示しています。
  一方、Pfenningの提案には、（i）型推論アルゴリズムがFωにシームレスに拡張され、（ii）高次の統一が一般的なケースで終了し、（iii）注釈型の抽象化が適している可能性がある効果のある言語の場合
  一方、Pfenningの本来の実装は、let-bound定義を効果的に扱い、型推論のモジュール性を脅かす定義の本体にインライン展開します。

  別の作業ラインは、予測的な上位ランクの多型に関する型推論を探索する（Odersky and Laufer 1996; Peyton Jones et al。2007; Remy 2005）。
  OderskyとLauferは、すべての多型関数の引数に注釈を付けると、 let-bound 式が存在する場合でも、予測的な上位ランクの多型の型推論が決定可能になるという観察を行った。
  Peyton Jones ら型アノテーションの双方向伝播をサポートする Odersky-Laufer 型システムのバリエーションを探る。
  最後に Remy は、型推論の前に実行された型推論と呼ばれる段階を通して、型注釈の双方向伝播を明確に分離することを提案した。

## 7.1将来の仕事と結論

   我々は、忠実な多型の型推論のための単純で表現力豊かな宣言的な仕様を提示した。
   システムをプロトタイプ形式で実装しました。 次に、実装を本格的なコンパイラにレトロフィットする予定です。
   我々は、正確で有益な型エラー報告の問題に対処するつもりである。アルゴリズムの種類が
   仕様。
   また、型クラス制約との相互作用についても検討する予定です。
   Leijen and Loh（2005）の予備的な研究では、MLFスタイルの統一と適格型をどのように組み合わせるかが示されており、大きな困難は生じないと予想している。

##謝辞

   著者は、Didier Remy氏、Daan Leijen氏、ICFP 2008審査員、そしてPenn PLClubに多くの有益な提案をしてくれたことに感謝したいと思います。
   この作業は、NSFグラント0347289、0702545、0716469、およびDARPA CSSG2によって部分的にサポートされました。

##参考文献

  Luis Damas and Robin Milner. Principal type-schemes for functional programs. In Conference Record of the 9th Annual ACM Symposium on Principles of Programming Languages, pages 207–12, New York, 1982. ACM Press.

  Jacques Garrigue and Didier Remy. Semi-explicit first-class polymorphism for ML. Journal of Information and Computation, 155:134–169, 1999.

  AJ Kfoury and JB Wells. A direct algorithm for type inference in the rank-2 fragment of the second-order lambda calculus. In ACM Symposium on Lisp and Functional Programming, pages 196–207. ACM, Orlando, Florida, June 1994.

  D Le Botlan and D Remy. MLF: raising ML to the power of System F. In ACM SIGPLAN International Conference on Functional Programming (ICFP’03), pages 27–38, Uppsala, Sweden, September 2003. ACM.

  Didier Le Botlan. MLF : Une extension de ML avec polymorphisme de second ordre et instanciation implicite. PhD thesis, Ecole Polytechnique, May 2004. 326 pages, also available in english.

  Didier Le Botlan and Didier Remy. Recasting MLF. Research Report 6228, INRIA, Rocquencourt, BP 105, 78 153 Le Chesnay Cedex, France, June 2007.

  Daan Leijen. HMF: simple type inference for first-class polymorphism. In ACM SIGPLAN International Conference on Functional Programming (ICFP’08). ACM, 2008a.

  Daan Leijen. Flexible types: robust type inference for first-class polymorphism. Technical Report MSR-TR-2008-55, Microsoft Research, March 2008b.

  Daan Leijen. A type directed translation of MLF to SystemF. In ACM SIGPLAN International Conference on Functional Programming (ICFP’07), Freiburg, Germany, 2007. ACM.

  Daan Leijen and Andres Loh. Qualified types for MLF. In ¨ ACM SIGPLAN International Conference on Functional Programming (ICFP’06), pages 144–155. ACM Press, 2005.

  R Milner. A theory of type polymorphism in programming. JCSS, 13(3), December 1978.

  John C. Mitchell. Polymorphic type inference and containment. Inf. Comput., 76(2-3):211–249, 1988. ISSN 0890-5401.

  M Odersky and K Laufer. Putting type annotations to work. In 23rd ACM Symposium on Principles of Programming Languages (POPL’96), pages 54–67. ACM, St Petersburg Beach, Florida, January 1996.

  Simon Peyton Jones, Dimitrios Vytiniotis, Stephanie Weirich, and Mark Shields. Practical type inference for arbitrary-rank types. J. Funct. Program., 17(1):1–82, 2007. ISSN 0956-7968.

  Frank Pfenning. Partial polymorphic type inference and higherorder unification. In LFP ’88: Proceedings of the 1988 ACM conference on LISP and functional programming, pages 153–163, New York, NY, USA, 1988. ACM. ISBN 0-89791-273-X.

  Didier Remy. Simple, partial type inference for System F, based on type containment. In ACM SIGPLAN International Conference on Functional Programming (ICFP’05), pages 130–143, Tallinn, Estonia, September 2005. ACM.

  Dimitrios Vytiniotis. Practical type inference for first-class polymorphism. PhD thesis, University of Pennsylvania, 2008. URL www.cis.upenn.edu/~dimitriv/fph. In submission.

  Dimitrios Vytiniotis, Stephanie Weirich, and Simon Peyton Jones. Boxy types: Inference for higher-rank types and impredicativity. In ACM SIGPLAN International Conference on Functional Programming (ICFP’06), Portland, Oregon, 2006. ACM Press.

  JB Wells. Typability and type checking in system F are equivalent and undecidable. Ann. Pure Appl. Logic, 98:111–156, 1999.
