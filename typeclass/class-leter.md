    From: Philip Lee Wadler <plw@cs.glasgow.ac.uk>
    Date: Sat, 27 Feb 88 15:33:30 GMT
    To: bob@lfcs.ed.ac.uk, fplangc@cs.ucl.ac.uk, mads@lfcs.ed.ac.uk,
            plw@cs.glasgow.ac.uk
    Subject: Overloading in Haskell Haskellのオーバーロード
    Sender: fplangc-request@cs.ucl.ac.uk


    提案：ハスケルのオーバーロード
      フィルワドラー
    1988年2月24日


  オーバーロードは、イェール会議で多くの議論を巻き起こした話題でした。
  言語が使えるようになったら、少なくとも「+」や「*」などの操作のオーバーロードが必要であることは明らかでした。
  言語の全体的な考え方は、少数のオペレータの特殊なケースではなく、できるだけ一般的な方法でこれを行うべきだと示唆していました。
  私たちが利用できる簡単な「既製品」のソリューションは存在しないようです。

  心配する点は、定義

    square x  =  x * x

  "*" は "int" 型とfloat型の両方の値に適用されるので、両方に "square" を適用しないでください。
  明らかにこれは望ましいことでしたが、達成するための簡単な方法はありませんでした。
  （最も簡単な方法は、オーバーロードを伴う元のソースがオーバーロードが除去された状態でコア言語に変換されると、潜在的なブローアップにつながります。）

  議論のもう一つの源は、 "多態性平等"演算子でした。
  標準的なMLとミランダに見られる "多態的な平等"操作は、いくつかの観点から、奇妙な獣です。
  標準MLは、例えば、2つの関数が等しいかどうか比較されないことを保証するために、型システム「等価型」への拡張を必要とします。
  さらに、多態性の等価性は「ラムダ定義可能」ではなく、新しいプリミティブとして定義する必要があります。
  これは、TIMなどの一部の実装では問題を引き起こします（ただし、実現不可能なものではありません）。
  抽象型に対してユーザー定義の等価操作を使用して多態性等価演算子を拡張できるかどうかは不明でした。

  この提案は、オーバーロードを扱うための新しいアプローチを示唆しています。
  これは「正方形」問題の解決法を提供します。
  コンパイル時には、オーバーロードを伴うプログラムをオーバーロードなしでプログラムに変換し、ブローアップを回避するようにプログラムを変換することができます。
  私の驚きには多少なりとも、それは多態性の平等問題の解決法を提供します！

  私はこのペーパーを整理して、熟成したアイデアが冒頭の近くに現れ、アイデアが終わりに近づくにつれてアイデアが貧弱になるようにしました。

  パート1は、限定された形式のオーバーロードを示しています。それは、イェール会議で議論された過負荷の考え方を具体的にする一つの方法と見ることができます。
  私はまずJonからそのアイデアを聞いたが、Standard MLのエジンバラ実装で使用されているものと正確に同じであることが分かった（言語標準には含まれていないが）。

  （興味深いのは、Kevin Mitchell は Appel/MacQueen の S​​tandard ML でのオーバーロードの実装が Edinburgh の実装よりも制限的であると主張しています。
  問題は、標準のドキュメントでは、オーバーロードがコンパイル時に解決可能でなければならないと言われていますが、解決方法については何も言いません！）

  第2部では、一般化されたオーバーロードについて説明します。
  私は非公式にアイデアを発表しました。

  正式な理論はまだ開発中です。
  私はエジンバラのBob HarperとMads Tofteとのアイデアについて議論しました。まだ明らかなバグは見つかっておらず、これらの新しいアイデアとタイプ理論のいくつかのよく発達した部分との間に強い関係があるようです。

  もう一つの奨励策は、Kevin Mitchell（前述のEdinburgh Standard MLの実装されていない拡張機能）とNick Rothwell（これも拡張機能として実装したEdinburghプロローグへ）。
  残念ながら、彼らは対応する理論を開発していないので、重要な作業はまだ残っています。これらのアイディアに基づいて実行中の実装が存在することは安心です。

  謝辞は通常、論文の終わりに来ますが、これはジョー・ファッセルの正式な承認を必要とします。
  多態的な方法で数値型のオーバーロードを処理し、これを型スキームに反映させる元の考えは、Joeによるものです。
  彼は最初、イェール会議の直後にサンディエゴのPOPL会合で私にそれを提案しました。
  それ以来、アイデアは大きく変化しました。 Joe、Luca Cardelli、John Hughes、Bob Harper、Mads Tofte、Kevin Mitchell、Nick Rothwellに感謝しています。

  本論文は以下のように構成されている。
  パート0には表記練習が含まれています。
  第1部では、単純な形式のオーバーロードを示しています。
  この論文のはるかに大きな部分であるパー​​ト2は、オーバーロードの一般化された形式を示しています。
  第3部は結論を出します。



## 0. 予選

  Standard MLやMirandaとは異なり、型指定子は明示的に記述されます。
  例えば：

    k : \a b. a -> b -> a
    k = \x y. x

  型の "for every"と式の "lambda"の両方に "\"を具体的な構文として使用することに注意してください。
  これは、文脈から常に明確であるべきであることを意味する。
  明示的な型の定量化の利点の1つは、型変数を字句的に区別する必要がなくなることです。したがって、我々はミランダの標準MLまたは***のような醜い人物を避ける。

  Hindley / Milnerタイプのシステムでは、量子はあるタイプの外部レベルにしか現れません。
  例えば、 "k"のための上記の型は合法ですが、 "\ a。a - >（\ b。b - > a）"型は合法です。

  私は "has type"の具体的な構文として "："を、 "cons"の具体的な構文として "::"を使用します。

  私は、標準的な演奏会で定義されている "int"と "float"という2つのタイプの存在が、

    intadd   : int -> int -> int
    intmul   : int -> int -> int
    intneg   : int -> int

  「フロート」についても同様です。
  定数のオーバーロードはありません。 "1"は "int"型で、 "1.0"は "float"型です。

  私は計算可能な平等のために "=="を書いて、 "="と書かれた記号的な平等と区別します。
  違いは、 "bottom == bottom"はbottomを意味し、 "bottom = bottom"はTrueを意味します。
  計算可能な等価は、実行時に実行されるテスト、定義のための指数平等で使用されます。


## 1. 単純なオーバーロード

  識別子は、1つのOVERLOAD宣言といくつかのINSTANCE宣言を与えることによってオーバーロードされるように定義されています。

    OVERLOAD
      (+)        : \a. a -> a -> a
      (*)        : \a. a -> a -> a
      (PREFIX -) : \a. a -> a

    INSTANCE
      (+)        = intadd
      (*)        = intmul
      (PREFIX -) = intneg

    INSTANCE
      (+)        = floatadd
      (*)        = floatmul
      (PREFIX -) = floatneg

  OVERLOAD宣言では、オーバーロードされた各識別子の型を指定します。
  各INSTANCEデクレーションは、識別子のバインディングを指定します。バインドされた値の型は、OVERLOAD宣言の対応する型のインスタンスでなければなりません。
  オーバーロードされた識別子のすべてのインスタンスは、他のすべてのインスタンスと別の型を持たなければなりません。
  （統一されていない場合、2つのタイプが分かれています。）

  任意の識別子がオーバーロードされる可能性があります。
  その識別子が演算子（接尾辞+や接頭辞 - など）であるかどうかは、独立した問題です。

  オーバーロードは、次のようにコンパイル時に解決されます。
  まず、型推論が実行されます。ここで、オーバーロードされた識別子の型は、OVERLOAD宣言で指定された型とみなされます。
  第2に、型推論の後、オーバーロードされた識別子の各出現が検査される。
  型がインスタンスの型と一致する場合、識別子は対応するインスタンス値に置き換えられます。
  その型がインスタンスに一致しない場合、オーバーロードは解決されず、エラーが宣言されます。

  たとえば、標準的なプレリュードも宣言しているとします

    sqrt : float -> float

  私たちが書くなら

    distance (x,y)  =  sqrt ((x*x) + (y*y))

  推定推論をタイプしてください

    distance : (float,float) -> float

  "+" と "*" に割り当てられた型は "float -> float -> float" であり、 "+" と "*" はインスタンス宣言の1つに一致し、 "floatadd" と "floatmul" としてインスタンス化されます。

  一方、我々が書いた場合

    square x  =  x * x

  型推論が導出される

    square : \a. a -> a

  "*" に割り当てられた型は "\a. a -> a -> a" であり、インスタンスには一致しないので、この定義は不正です。

  これを回避する方法の1つは、「正方形」にさらに負担をかけることです。
  たとえば、

    OVERLOAD
      square : \a. a -> a

    INSTANCE
      square = squareint

    INSTANCE
      square = squarefloat

    squareint : int -> int
    squareint x  =  x * x

    squarefloat : float -> float
    squarefloat x  =  x * x

  これは、コア言語への翻訳に暗黙のうちではなく、ソースコードにおいて明白であるが、以前に言及された潜在的なブローアップの同じ問題を示している。


## 2. 一般的なオーバーロード

  この部分では、今説明した単純なオーバーロードの一般化を紹介します。
  これは、 "正方形"が真の多形関数であることを可能にする。
  さらに、MirandaおよびStandard MLで行われているような特別な多態性等価操作を導入することなく、等価性を過負荷演算子として扱うことができます。

  この部分は次のように構成されています。
  第2.1節では基本的なアイデアを提示する。
  2.2節では、過負荷のプログラムを過負荷なしで同等のプログラムに変換する方法を示します。
  2.3節では、等価の定義を拡張例として提示する。
  セクション2.4の提示は、第2の例によるさらなるポイントを示す。
  セクション2.5では、この形式のオーバーロード、オブジェクト指向プログラミング、および抽象データ型の関係について説明します。


## 2.1 一般的なオーバーロードの概要

  重要なアイデアは、型の上に述語を導入し、過負荷の識別子の関連グループをまとめてそれらを述語に関連付けることです。
  これは、前のオーバーロード宣言のわずかな変形で行われます。

    CLASS  num a
      (+)        : a -> a -> a
      (*)        : a -> a -> a
      (PREFIX -) : a -> a

  これは型述語 "num"を導入し、適切な型の（+）、（*）、（PREFIX - ）という名前の関数が定義されている場合、 "a"は数値型です。
  以前とほぼ同じ方法でインスタンスを宣言します。

    INSTANCE  num int
      (+)        = intadd
      (*)        = intmul
      (PREFIX -) = intneg

    INSTANCE  num float
      (+)        = floatadd
      (*)        = floatmul
      (PREFIX -) = floatneg

  最初の宣言では、 "int"は数値型であると主張し、関連する演算子に適切なバインディングを与えることによってこのアサーションを正当化します。
  2番目の宣言は "float"と同じことをします。

  これらの宣言が与えられると、前に与えられた「距離」の定義は依然として有効であり、過負荷は同じように解決されます。
  しかし、 "square："の多形的な定義を書くことも可能になりました。

    square x  =  x * x

  クラスと型述語で動作する型推論アルゴリズムの一般化されたバージョンが存在します。
  タイプを導出する

    double : \a. num a. a -> a

  フレーズ "\ a。
  num a。 "は" aが数値型であるように、すべてのaに対して "読み込まれます。
  "double 1"や "double 2.0"などのアプリケーションを書くことができ、それぞれに適した型が導出されます。
  一方、 "[int]"（型の "list of int"）が（インスタンス宣言を介して）アサートされていないため、実行時に "double [3]"を書くと型エラーが発生しますタイプ。

  すべての型指定子は型の先頭に来なければならないのと同様に、すべての型述語もそうでなければなりません。
  したがって、一般に、型は常に次の形式をとります：ゼロ以上の型の量指定子、0以上の型述語、その後に型の項が続きます。


## 2.2 一般的なオーバーロードの翻訳

  この形式のオーバーロードの1つの特徴は、コンパイル時に、オーバーロードを含むプログラムをそうでないプログラムに変換することが可能であることです。

  「距離」の「+」と「*」のように）発生した時点で解決できる演算子の過負荷と、「*」が「正方形」のようにはできない演算子を区別します。
  前者は「解決可能」と呼ばれ、後者は「多型」と呼ばれます。

  解決可能なオーバーロードの場合、変換は簡単です。オーバーロードされた識別子の各オカレンスは、関連するインスタンス宣言で対応する値に置き換えられます。
  例えば、「距離」の定義は、

    distance (x,y)  =  sqrt (floatadd (floatmul x x) (floatmul y y))


  多態的なオーバーロードのためには、もう少し作業が必要です。
  まず、クラス宣言ごとに、新しい型シノニムを導入します。

    TYPE  num' a  =  (a -> a -> a, a -> a -> a, a -> a)

  各インスタンスについて、対応する型のオブジェクトも宣言します。

    numint' : num' int
    numint' = (intadd, intmul, intneg)

    numfloat' : num' float
    numfloat'= (floatadd, floatmul, floatneg)

  型述語は、対応するクラス型のパラメータに対応する。
  たとえば、次のような型の "square"の定義があります。

    square    :  \a. num a. a -> a
    square x=  x * x

  これは

    square' :  \a. num' a -> a -> a
    square' pkg x  =  mul x x
      WHERE
      (add, mul, neg) = pkg

  適切な余分なパラメータを渡すには、 "square"の各アプリケーションを変換する必要があります。

    square 1      -->    square' numint 1
    square 2.0    -->    square' numfloat 2.0

  Squareは完全に有効な関数であり、完全に有効なHindley / Milner型を持っていることに注意してください。
  したがって、多態的な多重定義と型を持つ型を関数に変換し、述語を持たない型と型を持たない関数に変換しました。


## 2.3 例：等価

  このセクションでは、オーバーロード機構を使用して等価性を定義する方法の拡張例を示します。
  オーバーロードされた等価性は、多態性の等価性よりもいくつかの利点があります。システムに等価型などの特殊なメカニズムを導入するのではなく、一般的なオーバーロードメカニズムに依存します。それは「ラムダ定義可能」です。ユーザーは抽象型に対して同等性を定義することができます。

  まず、単純なインスタンスとして "int"と "char"を使って、オーバーロードされた等価演算のクラスを定義します。

    CLASS  eq a
      (==) : a -> a -> bool

    INSTANCE eq int
      (==)  =  intequal

    INSTANCE eq char
      (==)  =  charequal

  ここで、通常の方法で「メンバ」操作を定義できます。

    member :  \a. eq a. [a] -> a -> bool
    member [] y=  False
    member (x :: xs) y=  (x == y) \/ (member xs y)

  「メンバー」のタイプは、推論することができるので、明示的に指定する必要はありません。
  ここでは、

    member [1,2,3] 2
    member "Haskell" 'k'

  どちらもTrueと評価されます。

  "メンバ"と同じスタイルで、リストの上に平等を定義することができます：

    listequal   :  \a. eq a. [a] -> [a] -> bool
    listequal [] []   =  True
    listequal (x::xs) (y::ys)  =  (x == y) & (listequal xs ys)
    ELSE
    listequal xs ys   =  False

  ここでも、タイプは定義から推論できます。
  インスタンス・メカニズムの自然な拡張を使用して、オーバーロード（==）してリストに等しいことを含めることができます。

    INSTANCE  \a. eq a. eq [a]
      (==)  =  listequal

  この宣言は、 "a"が等価型であるすべての型 "a"に対して "aのリスト"も等価型であると述べています。
  ここでは、

    "hello" == "goodbye"
    [[1,2,3],[4,5,6]]  ==  []
    member ["Haskell", "Alonzo"] "Moses"

  これらはすべてFalseと評価されます。

  同様に、 "gorp a b"がユーザ定義の抽象型で、型 "a"と "b"にパラメータ化されていて、その上に操作

    gorpequal : \a b. eq a. eq b. gorp a b -> gorp a b -> bool

  それから我々は書くかもしれない

    INSTANCE  \a b. eq a. eq b. eq (gorp a b)
      (==)  =  gorpequal

  したがって、これを達成するために言語に特別な仕組みを追加する必要はなく、抽象型に対するユーザー定義の等価操作でオーバーロード（==）することがあります。

  ここでは、この例にどのように変換メカニズムを適用するかを検討します。
  まず、新しい型の同義語を取得します。

    TYPE  eq' a  =  a -> a -> bool

  この場合、関数のタプルは単一の関数に縮退しています。
  前と同じようにクラスをバインドすることができます：

    inteq' : eq' int
    inteq' = intequal

    chareq' : eq' char
    chareq' = charequal

  メンバーの操作は次のように解釈されます。

    member':  \a. eq' a -> [a] -> a -> bool
    member' eql [] y=  False
    member' eql (x::xs) y=  (eql x y) \/ (member eql xs y)

  ここには2つの用語とその翻訳があります：

    member [1,2,3] 2--> member' inteq' [1,2,3] 2
    member "Haskell" 'k'-->member' chareq' "Haskell" 'k'


  同様に、 "listequal"は次のように解釈されます。

    listequal':  \a. eq' a -> [a] -> [a] -> bool
    listequal' eql [] []=  True
    listequal' eql (x::xs) (y::ys)=  (eql x y) & (listequal' eql xs ys)
    ELSE
    listequal' eql xs ys=  False

  リストの平等のためのインスタンス宣言の翻訳は少し難解です。
  それが読まれることを思い出してください：

    INSTANCE  \a. eq a. eq [a]
      (==)  =  listequal

  前と同じ変換メソッドを適用すると、型述語を含む型が残っています。

    listeq' : \a. eq a. eq' [a]
    listeq' = listequal

  ただし、2番目の変換ステップでは、型述語が削除されます。

    listeq' : eq' a -> eq' [a]
    listeq' = listequal'

  ここに3つの用語とその翻訳があります：

    "hello" == "goodbye"
      -->  listequal' (listeq' chareq') "hello" "goodbye"

    [[1,2,3],[4,5,6]]  ==  []
      -->  listequal' (listeq' (listeq' inteq'))
      [[1,2,3],[4,5,6]]
      []

    member ["Haskell", "Alonzo"] "Moses"
      -->  member' (listeq' chareq')
          ["Haskell", "Alonzo"]
          "Moses"


  最後に、

    gorpequal : \a b. eq a. eq b. gorp a b -> gorp a b -> bool

  2つの追加パラメータを取る関数に変換されます.1つは型 "a"に対して等価を提供し、もう1つは型 "b"に対して等価を提供します。

  多重定義された等価性の相対効率を比較することは有益です。
  引数の型は事前に分かっているので、 "intequal"などの個々の演算は多態性の等価性よりも若干効率的です。
  一方、 "member"や "listequal"のような操作では、多態性平等が回避するオーバーヘッドを明示的に等価演算に渡す必要があります。

  これで拡張例が終わります。
  これが、このオーバーロードメカニズムの力を説明し、過負荷の定義を体系的な方法でコア言語に翻訳することが可能であることを示すために役立つことが期待されます。


## 2.4 例：コレクション

  一般に、型述語は複数の引数を持つことができます。
  例として、リストやセットなどのコレクションの操作をオーバーロードする方法を示します。
  （例は純粋に説明のためのものであり、標準的な演奏会にこれを含めるべきではありません。

    CLASS  collection a b
      (.in)     : a -> b -> bool
      (.union)  : b -> b -> b
      singleton : a -> b

  述語 "コレクションa b"は、 "b"がタイプ "a"の要素を持つコレクションであることを主張します。
  コレクションの実装の1つはリストです。

    INSTANCE  \a. eq a. collection a [a]
      x .in xs=  member xs x
      xs .union ys  =  xs ++ ys
      singleton x   =  [x]

  関数で抽象型 "set a"を定義したとします

    setmember    : \a. eq a. set a -> a -> bool
    setunion     : \a. set a -> set a -> set a
    setsingleton : \a. a -> set a

  次に、2番目のインスタンスは

    INSTANCE \a. eq a. collection a (set a)
      x .in xs=  setmember xs x
      (.union)=  setunion
      singleton=  setsingleton

  最後に、Godelナンバリングを使用して整数のコレクションを実装する操作を定義したとします。

  godelmember    : int -> int -> bool
  godelunion     : int -> int -> int
  godelsingleton : int -> int

  （例えば、 "godelsingleton n"は2をn乗して返します。）
  次に、3番目のインスタンスは次のように与えられます。

    INSTANCE  collection int int
      m .in n=  godelmember m n
      (.union)=  godelunion
      singleton=  godelsingleton

  この最後の例は、少し考案されていますが、「コレクション」述部に2つのパラメーターが必要な理由を示しています。
  "set a"のようなパラメータ化された型は、コレクションを実装するすべての可能なメソッドを取得するのに十分一般的ではありません。

  コレクションに定義された関数の2つの例を次に示します。

    doublet : \a b. collection a b. a -> a -> b
    doublet x y  =  (singleton x) .union (singleton y)

    squarein : \a b. num a. collection a b. a -> b -> bool
    squarein x s  =  (square x) .in s

  2番目の例は、さまざまなオーバーロードをどのように組み合わせるかを示しています。
  両方の例では、型を推論できるので、型を明示的に指定する必要はありません。


  ## 2.5 サブクラス

  前の例では、 "num" と "eq" は完全に別のクラスとみなされていました。
  数値演算と等価演算の両方を使用する場合、これらはそれぞれ型に別々に現れます：

    squaremember : \a. eq a. num a. [a] -> a -> bool
    squaremember xs x  =  member xs (square a)

  現実的には、これはちょっと奇妙に思えます。（+）、（*）、（PREFIX - ）が定義されているすべてのデータ型に（==）同様に定義されていると期待します。逆ではない。
  したがって、 "num"を "eq"のサブクラスにすることは賢明です。

  これを可能にするために、表記法が拡張され、クラス宣言の署名部分にクラス名が含まれるようになります。

    CLASS  num a
      eq a
      (+)     : a -> a -> a
      (*)     : a -> a -> a
      (PREFIX -) : a -> a

  これは、述語 "num a"を満たすすべての型 "a"も述語 "eq a"を満たさなければならないと主張する。
  言い換えれば、 "num"は "eq"のサブクラスであり、等価的に "eq"は "num"のスーパークラスです。
  インスタンス宣言は以前と同じままですが、インスタンス宣言 "num int"は、同じスコープ内でインスタンス宣言 "eq int"がアクティブな場合にのみ有効です。

  前述の「squaremember」の定義では、

    squaremember : \a. num a. [a] -> a -> bool

  型述語 "eq a"は、 "num a"によって暗示されるので、もはや言及する必要はない。

  変換用語では、 "eq"の対応するインスタンスを表す "num"のインスタンスを表すタプルにコンポーネントを追加するだけです。
  したがって、我々は今翻訳を持っている：

    TYPE  eq' a   =  a -> a -> bool
    TYPE  num' a  =  (eq' a, a -> a -> a, a -> a -> a, a -> a)

    eqint':  eq' int
    eqint'=  (intequal)

    numint':  num' int
    numint'=  (eqint', intadd, intmul, intneg)

    squaremember' : \a. num' a -> [a] -> a -> bool
    squaremember' numpkg x=  member eqpkg xs (square numpkg x)
      WHERE
      (eqpkg, add, mul, neg) = numpkg

    square' :  \a. num' a -> a -> a
    square' numpkgx=  mul x x
      WHERE
      (eqpkg, add, mul, neg) = numpkg

  そして "メンバー"の翻訳は以前と同じです。

  一般に、各クラスは任意の数のサブクラスまたはスーパークラスを有することができる。
  ここには工夫した例があります：

    CLASS top a
      fun1 : a -> a

    CLASS left a
      top a
      fun2 : a -> a

    CLASS right a
      top a
      fun3 : a -> a

    CLASS bottom a
      top a
      left a
      right a
      fun4 : a -> a

  これらのタイプ間の関係は、次のように図式化することができます。

            top
           /   \
          /     \
        left   right
          \     /
           \   /
           bottom

  複数のスーパークラスは、オブジェクト指向言語を実装する通常の手段にいくつかの問題を提起しますが、ここで概説する変換スキームには問題はありません。

  一見すると、サブクラスはサブタイプと非常によく似ているように見えるかもしれませんが、重要な違いがあります。
  サブタイプは、関数型コンストラクタに関して「反単調」です。
  つまり、 "aがaのサブタイプである"のためにa = bを書くと、

    (a -> b) <= (a' -> b')   iff  a' <= a  and  b <= b'

  私たちが書いたので、これは反単調です

  一方、サブクラス化は反単調ではありません。
  たとえば、型述語「num」は型述語「eq」よりも具体的であり、型

    \a. num a. a -> a

  型よりも具体的です

    \a. eq a. a -> a

  つまり、最初のものと一致するものはどちらも2番目のものと一致しますが、逆のものは一致しません。
  型の述語は型の先頭に来るだけであり、関数型のコンストラクタで構築された型の中には現れないので、反単調性は問題ではありません。


  オブジェクト指向プログラミング、抽象型の複数の実装、およびアサーション

  「CLASS」という名前が示すように、オブジェクト指向プログラミングとここで説明されているアイデアとの間にはいくつかの類似点があります。
  オブジェクト指向言語では、クラスはデータ型に関する関連する一連の操作をグループ化します。
  オブジェクトは実行時に、これらの操作、つまり「メソッド」を持ちます。
  ここでのアイデアは少し一般化されています。クラス宣言は、1つ以上の関連型の操作をグループ化し、その操作はオブジェクトではなく別々に渡されます。

  ある意味では、クラスメカニズムは抽象型の複数の実装を提供します。
  関数の型が、型述語が型変数にのみ適用されるようなものであるときはいつでも、そのクラスの任意のインスタンスが関数への適切な引数です。
  セクション2.4の "コレクション"の例では、このように "ダブレット"と "スクエアイン"の両方が多様である。
  セットに ".in"、 ".union"、 "singleton"の演算しか必要としない関数も同様に定義できます。
  事実上、クラスは抽象型のシグネチャを指定し、インスタンスはこの型の異なる実装を提供します。
  setの可能な実装は3つあり、リストのような具象型、抽象型に基づくもの、言語が定義する抽象化メカニズムを使用したものなど、いくつもの追加実装が可能です。

  リストのように具体的な型であっても、型がクラス操作のみを適用できることと、リストに対して他の操作を適用しないことを保証するので、 "doublet"や ".squarein"のような関数に渡すと安全です。
  さらに、タイピングは、実装が適切に一致することを保証します。
  たとえば、引数がリストで表されている場合、または両方がGodelの数値で表されていて、リストが1つの場合はGododの番号ではない場合は、doubletが呼び出されます。

  各インスタンスが満たさなければならないプロパティを指定して、クラス宣言にアサーションを追加することも当然考えられます。

    CLASS  collection a b
      (.in)     : a -> b -> bool
      (.union)  : b -> b -> b
      singleton : a -> b
      ;; for all x : a and s, t : b
      ;;   x .in (singleton x)
      ;;   x .in (s .union t)  <=>  x .in s \/ x .in t

  どのインスタンスが各インスタンス宣言のために保持しているかを証明する限り、これらのプロパティに依存する任意の証明に対して有効です。
  そのようなプロパティの証明を主張したり検証したりすることは、Haskellの範囲外です（それを含む拡張を検討するのは面白いでしょう）ので、私はその主張をコメントとして書いています。


## 3. 結論

  セクション1で提案されたメカニズムは単純であるように思えます。私はオーバーロードのアプローチとしてこれを採用することをお勧めします。

  これをセクション2の仕組みに拡張する必要がありますか？利点は、より強力な言語です： "正方形"の問題が解決されます。
  また、より小さな言語：新しい意味論的プリミティブとして多態性の等価性を定義する代わりに、オーバーロード機構を使用して等価性を定義することができます。
  （等式をサポートするためには、言語に少し追加する必要があります。新しい代数型定義のそれぞれは、その型に対する等価性のインスタンス宣言も含める必要があります。
  しかし、これは単なる構文的な砂糖です。）
  さらに、ユーザが抽象データ型に対して同等性を定義することは容易である。

  もう1つの利点は、以下のようなオーバーロードされた操作を定義できることです。

    show : a -> string
    read : string -> a

  これは便利なことです。
  Mirandaは "show" を（等価のような）多相演算として定義しますが、 "read" を多相演算として定義すると型のセキュリティの問題が発生します。
  オーバーロードは、両方を型保証された方法で定義することができます。

  負の面では、このアイデアはまだまだ新しいものであり、その意味は不明です。
  適切な推論アルゴリズムがあるようですが、これは正式に指定され、健全であることが証明される必要があります。
  （私は4月の会議の前にこれを行うことを望んでいる; Bob Harperは彼がこれを手助けしようとしているかもしれないと述べている）実際に推論された型が多数の型述語で詰まっているかどうかは不明である。
  オーバーロードを実装する自然な方法では、ある型の各述語が、実行時に渡される操作のタプルに対応する必要があります。
  このオーバーヘッドは受け入れられますか？

  コメントは大歓迎です！

