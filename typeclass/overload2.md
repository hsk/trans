# オーバーロードの第2の見方 - A Second Look at Overloading <a name="r*"></a>[*](#*)

  Martin Odersky

  Universitat Karlsruhe <a name="rd"></a>[†](#d)

  (odersky@ira.uka.de)

  Philip Wadler

  University of Glasgow <a name="rdd"></a>[‡](#dd)

  (wadler@dcs.glasgow.ac.uk)

  Martin Wehr

  Universitat Karlsruhe
  (wehr@ira.uka.de)

## 要約

  我々は、オーバーロードと多相レコードをサポートする Hindley/Milner システムの最小限の拡張を研究します。
  型システムは、標準の型なしの構成的セマンティクスに関しては健全であることを示します。
  また、このシステムのすべての型付け可能な項には主要型があり、その型を再構築するアルゴリズムが示されています。

## 1 はじめに

  算術、等価、文字列としての値を示す:3つの演算は、言語デザイナーの悪夢を与えることを保証します。
  通常、何らかの形でオーバーロードされますが、どの形式が最良なのでしょうか？

  成功した Hindley/Milner 型システムに基づいて言語に注意を限定したとしても、さまざまなオーバーロードの処理があります。
  同じ言語では、異なる演算子を別々に扱うことがあります。異なる言語は同じ演算子を異なる方法で扱うことがあります。同じ言語が時間の経過とともに同じ演算子を異なる方法で扱うことがあります。
  たとえば、 Miranda の算術演算は、単一の数値型でのみ定義されます。等価は、抽象バリアを破る抽象型を含む、すべての型で定義された多相関数です。ユーザが新しい型についてshow関数を定義することができます。
  SML の最初のバージョンでは、平等はすべての単相型で単純にオーバーロードされました。
  2番目のバージョンでは特殊な等価型変数が導入されました。

  オーバーロード [<a name="rWB89"></a>[WB89](#WB89)] のための統一されたフレームワークを提供するために、 Haskell に型クラスが導入されました。
  それは Kaes [<a name="rKae88"></a>[Kae88](#Kae88)] によって独自に記述されていたので、その時はまさにピッタリのアイデアであったに違いありません。
  それ以来、型クラスはかなりの注目を集めており、多くの洗練されたバリエーションがあります [<a name="rNS91"></a>[NS91](#NS91),<a name="rNP93"></a>[NP93](#NP93),<a name="rHHPW94"></a>[HHPW94](#HHPW94),<a name="rAug93"></a>[Aug93](#Aug93),<a name="rPJ93"></a>[PJ93](#PJ93),<a name="rJon92b"></a>[Jon92b](#Jon92b),<a name="rCHO92"></a>[CHO92](#CHO92),<a name="rJon93"></a>[Jon93](#Jon93)]。
  彼らはまた、いくつかの問題も指摘されています [<a name="rApp93"></a>[App93](#App93)]。

  我々の見解では、型クラスの最も深刻な問題の1つは、プログラムにその型に依存しない意味を割り当てることができないということです。

  ---

  <a name="*"></a>[*](#r*) 1995年6月、カリフォルニア州サンディエゴの機能プログラミングとコンピュータアーキテクチャに関する第7回国際会議に出席します。

  <a name="d"></a>[†](#rd)
  Institut fur Programmstrukturen、76128カールスルーエ、ドイツ。

  <a name="dd"></a>[‡](#rdd)
  スコットランドグラスゴーG12 8QQコンピューティングサイエンス学科。

  ---

  その結果、 Hindley/Milner 型システムの最も有名な性質のうちの2つは、型クラスの存在下では満足できません:意味的な健全性の結果はなく、主要な型の結果は弱い形でしか保持されません。

  意味的健全性の結果は、プログラムの型付き静的セマンティクスと型なしの動的セマンティクスとの間の対応を示します。
  Milner のキャッチフレーズ 'well typed programs cannot go wrong - 正しく型付けされたプログラムは間違わない' にまとめられています。
  型指定されていない動的セマンティクスが存在しないので、型クラスに対してそのような結果を定式化することすらできません。

  主要型の結果は、すべての型付け可能なプログラムが単一の最も一般的な型であることを示しています。
  これは型クラスにも当てはまります。
  しかし、この結果の有用性の多くは、 Hindley/Milner システムの別の特性から生じます。
  型付け可能なすべてのプログラムは、すべての型宣言がそれから削除された場合でも型付け可能なままなので、型宣言は必要ありません。
  これは型クラスでは失敗します。プログラムによってはあいまいさがあり、曖昧さ回避のための型宣言が必要です。
  別の言い方をすると、 Hindley/Milner の下では、プログラムは意味が決定できない場合、型を決めることができません。
  型クラスの下では、プログラムの意味が多すぎるため、プログラムは型付けできない可能性があります。

  これらの特性が欠如しているのは、技術的な面が欠落しているだけではなく、プログラムの意味をその型と分けて理解できないために発生します。
  これにより、プログラマが利用できるプログラムの理解方法の範囲が狭くなり、コンパイラが利用できるプログラムを実装する方法の範囲が狭くなります。

#### 制限型クラス

  型クラスの単純な制限によって、プログラムがその型とは無関係に決定できる意味を持つことを保証することができます。

  型クラスは、オーバーロード演算子が定義されている型だけを範囲とするような型変数、例えば `a` を限定することを思い出してください。オーバーロードされた演算子は、 `a` を含む任意の型を有することができます。
  ここでは、 Haskell の standard prelude の簡略化された部分を表すいくつかの例を示します。

    class (Num a) where
      (+) :: a -> a -> a
      (*) :: a -> a -> a
      neg :: a -> a
      fromInteger :: Integer -> a

    class (Eq a) where
      (==) :: (Eq a) => a -> a -> Bool

    class (Text a) where
      show :: a -> String
      showList :: [a] -> String
      read :: String -> a

  たとえば、 `a` に定義された指定された型の演算子 `（*）`、 `neg`、 `fromInteger` がある場合にのみ、型 `a` はクラス `Num` に属します。

  制限は以下の通りです: 型変数 `a` に対する型クラスの場合、それぞれのオーバーロードされた演算子は、 `a -> t` 型の型を持たなければなりません。
  上の例では `（+）`、 `（*）`、 `neg`、 `（==）`、 `show` はこの制限を満たしていますが、 `fromInteger`、 `showList`、 ` read` はそうではありません。

  注目すべきことに、この単純な制限により、型なしの動的セマンティクスを構築することが可能になり、あいまいさが生じないことが保証されます。したがって、型の健全性と主要な型の強力な形式が保持されます。
  結果として得られるシステムは、算術、等価性のオーバーロードを処理して文字列として値を表示するのに十分強力ですが、数値定数のオーバーロードや文字列を値として読み取るほど強力ではありません。
  後者はおそらく前者よりも重要ではありません: Miranda も SML も後者のオーバーロードをサポートしておらず、 Kaes は元の論文 [<a name="rKae88"></a>[Kae88](#Kae88)] でこの制限されたオーバーロードの形態のみを考慮しました。

  この制限の値の例として、 `[] == []` というフレーズを考えてみましょう。
  Haskell では、このフレーズの意味はあいまいであり、無意味です。
  リスト要素の型を指定することで曖昧さを解消する必要があります。
  これは、プログラムの意味が変換 `eqList eqElt [] []` によって与えられるからです。
  ここで、 `eqList` はリストの等価であり、 `eqElt` はリスト要素の等価です。

  我々の制限されたシステムでは、 `[] == []` というフレーズが型に依存しない意味を持つことが保証されています;
  すべての有効な変換がこの意味をもたらすことを示しています。
  実装者は、3章の型のない動的セマンティクスに対応するランタイム分岐、または4章の型付き静的セマンティクスに対応するコンパイル時変換によってオーバーロードを実装することができます。
  後者の場合、プログラムの有効な変換は `eqList undef [] []` です。
  ここで、 `undef` はどこでも定義されていない関数です。
  一貫性は、プログラムが変換を強制しない場合、変換が実行することを保証するためです。
  無制限の Haskell の場合、コンパイラライターは動的セマンティクスがないので変換を選択しなければならず、適切な一貫性のある結果がないため、 `undef` ではなく `eqElt` を選択する必要があります。

  したがって、型クラスの制限により、保持する追加の有用なプロパティが保証されます。
  これらの付加的な特性は、型クラスの一般化を検討することを可能にします。

#### 一般化型クラス

  型クラスは、ある種のオーバーロードされた演算子が定義されている型の範囲になるように型変数を制約します。
  これは、有界多相と密接に関連しているように見えます。この多相型は、型変数が指定された型のサブ型である型を越えるように制約します [<a name="rCW85"></a>[CW85](#CW85),<a name="rBTCGS91"></a>[BTCGS91](#BTCGS91)]。
  実際、レコードの通常の部分型の関係では、束縛された多相型を模倣するために型クラスを使用することができます [<a name="rPet94"></a>[Pet94](#Pet94)]。
  しかし、厄介なことに、この模倣は単相レコードに対してのみ働きます。 型クラスは、多態性のレコードを処理するのに十分強力ではありません。

  たとえば、 `xcoord` と `ycoord` の操作は、これらのフィールドを含むレコード型に適用されると期待されます。
  (たとえば、2つのフィールドだけを含む型 `Point` と、色を加えた両方のフィールドを含む型 `CPoint`)
  Haskell でこのようなレコードを模倣する方法は次のとおりです。

    class (Pointed a) where
      xcoord :: a -> Float
      ycoord :: a -> Float

    data Point = MkPoint Float Float
    data CPoint = MkCPoint Float Float Colour

    instance Pointed Point where
      xcoord (MkPoint x y) = x
      ycoord (MkPoint x y) = y

    instance Pointed CPoint where
      xcoord (MkCPoint x y c) = x
      ycoord (MkCPoint x y c) = y

    distance :: (Pointed a) => a -> Float
    distance p = sqrt (sqr (xcoord p) + sqr (ycoord p))

  関数 `distance` は、与えられた点の原点からの距離を計算します。
  型シグニチャは、クラス宣言と関数本体だけが与えられていると推論されるので、オプショナルです。

  この模倣は、クラス宣言に現れることができる単相型を持つレコードの各フィールドに依存することに注意してください。
  上記の多相対応は、ペアまたは三つ組の対応するコンポーネントを返す操作を1番目と2番目に持つことです。これらのコンポーネントは、 `Float` に制限されるのではなく、任意の型を持つことができます。
  しかし、 Haskell でこれを行う方法はありません。

  この問題の原因はクラス宣言です。
  `xcoord` の場合、インスタンス

    xcoord :: Point -> Float
    xcoord :: CPoint -> Float

  は以下のクラス宣言のインスタンス化として発生することができます:

    xcoord :: a -> Float .

  しかし、 `first` のインスタンス

    first :: (a,b) -> a
    first :: (a,b,c) -> a

  には対応するクラス宣言がありません。

  この問題は、クラス宣言を取り除くことで解決します。
  演算子のグループがクラスに属し、型宣言を指定すると宣言するのではなく、演算子が多重定義され、型宣言を与えないように指定するだけです。

  ここでは、新しい表記法の前の例を示します。

    over xcoord
    over ycoord

    data Point = MkPoint Float Float
    data CPoint = MkCPoint Float Float Colour

    inst xcoord :: Point -> Float
         xcoord (MkPoint x y) = x

    inst ycoord :: Point -> Float
         ycoord (MkPoint x y) = y

    inst xcoord :: CPoint -> Float
         xcoord (MkCPoint x y c) = x

    inst ycoord :: CPoint -> Float
         ycoord (MkCPoint x y c) = y

    distance :: (xcoord,ycoord::a->Float) => a -> Float
    distance p = sqrt (sqr (xcoord p) + sqr (ycoord p))

  ここでも、 `distance` の型宣言は、その本体から推測されるかもしれません
  （単純に、 `sqrt`、 `sqr`、 `+` のオーバーロードを無視してください）。

  さらに、 `first` と `second` の多相的なペアおよび三つ組をオーバーロードすることが可能になりました。

    over first
    over second
    over third

    inst first :: (a,b) -> a
         first (x,y) = x

    inst second :: (a,b) -> b
         second (x,y) = x

    inst first :: (a,b,c) -> a
         first (x,y,z) = x

    inst second :: (a,b,c) -> b
         second (x,y,z) = y

    inst third :: (a,b,c) -> c
         third (x,y,z) = c

    demo :: (first::a->b,second::a->c) => a -> (c,b)
    demo r = (second r, first r)

  関数 `demo` はペアまたは三つ組をとり、 `second` と `first` の順序でコンポーネントを返します。
  ここでも、その型を推論できます。

  要するに、クラス宣言を削除すると、束縛された多態性をモデル化するのに十分強力な型クラスになります。

  クラス宣言を削除すると、クラス内でどの操作がどのクラスに属しているかを事前に決定する必要がなくなります。
  多くの状況で、これはプラスの利点になります。
  たとえば、ペアを扱う場合は、 `first` と `second` のペアをグループ化するだけですが、三つ組を処理する場合は、 `third` も必要になります。
  さらなる例として、 Haskell デザイナーが数値演算子をクラスにグループ化する方法を決定していたという困難を考慮してください。
  この設計はまだ議論されています: `+` と `*` は `ring` クラスにあるべきでしょうか?
  Haskell には、ユーザが与えられたクラスをより小さなクラスに分割するメカニズムがないので、この問題は悪化します。

  一方、クラス宣言を削除すると、推論された型はより冗長になります。すべてのオーバーロードされた演算子の型を記述する必要があります。
  レコードは、関連する操作をグループ化するために、共通のオーバーロードされた識別子を使用しているため、ここでいくつかの救済策が提供されています。
  これについては第5章で詳しく説明します。

#### この研究の貢献

  上記の制限と型クラスの一般化を組み合わせて、次のプロパティを持つオーバーロードの型システムであるシステムOを定義します。

  - システムOは、型指定されていない動的セマンティクスを持ち、対応する型健全性定理を満たします。
  - システムOは強力な主要型のプロパティを持っています。
    プログラムの曖昧さを解消するために型宣言を追加する必要はありません。
  - 型クラスと同様に、標準的な辞書変換があり、システムOの正しく型付けされたプログラムを Hindley/Milner システムの同等の型付きプログラムに変換します。
  - システムOは、多相型レコードを含む、レコードに対してF限定の多相の限定された形式をモデル化するのに十分強力です。

  ----

  これにより、システムOは型クラスの興味深い代替手段になると考えています。

#### 関連研究

  多想プログラミング言語のオーバーロードは、 Kaes [<a name="rKae88"></a>[Kae88](#Kae88)] と Wadler と Blott [<a name="rWB89"></a>[WB89](#WB89)] によって最初に研究されました。
  同様の概念は、記号代数 [<a name="rJT81"></a>[JT81](#JT81)] の初期の研究で見出すことができます。
  この論文は、オーバーロードが関数に限定されている点で、 Kaes の伝統に非常に似ています。
  これは、述語や型クラスのすべての構文的宣言を取り除く、彼のシステムの簡素化として見ることができます。
  型の健全性の証明と型付けレコードの関係によって、彼の仕事の範囲を広げます。

  オーバーロードに関する後の作業の大半は、 Haskell の型クラスの設計と実装によって駆動されます。 例えば、Nipkow et al。
  Haskell の型クラスの正式な定義については Halls、 Hammond、 Peyton Jones、 Wadler [<a name="rHHPW94"></a>[HHPW94](#HHPW94)] のように、型再構築のための [<a name="rNS91"></a>[NS91](#NS91),<a name="rNP93"></a>[NP93](#NP93)]、 Augsson [<a name="rAug93"></a>[Aug93](#Aug93)]、 Peterson と Jones [<a name="rPJ93"></a>[PJ93](#PJ93)] があります。
  我々はすでに、我々のシステムを Haskell のようなプログラムでは許されないと主張してきました。

  他の Haskell の型クラスの一般化が提案されています。
  Wadler と Blott、 Jones は、複数の型変数を持つ型クラスを考えます [<a name="rWB89"></a>[WB89](#WB89), <a name="rJon92b"></a>[Jon92b](#Jon92b)]。
  Chen、 Hudak および Odersky のパラメトリック型クラス [<a name="rCHO92"></a>[CHO92](#CHO92)] も複数の型変数を持ちますが、関数の依存関係は主クラス変数と従属変数の間に課されます。
  パラメトリック型クラスはコンテナクラスとレコードをモデル化できます。
  コンストラクタークラスは型クラスを一般化してコンストラクターを型付けします [<a name="rJon93"></a>[Jon93](#Jon93)]。
  コンストラクタークラスは、異なる要素型を持つ類似のコンテナー間を仲介する操作でコンテナをモデリングするのに非常に優れています。
  我々は、我々の型システムが型コンストラクタに一般化できるかどうかを決定する重要な問題と考えます。

  これまでに議論されたすべてのシステムは、オープン・ワールドのアプローチを実装しています。
  インスタンスをまったく持たない空のクラスでさえ、合法であると見なされます。
  このアプローチは、型検査器がインスタンス宣言の完全な情報を持っていない別々のコンパイルを持つシステムでうまく機能します。
  対照的に、例えば、 [<a name="rRou90"></a>[Rou90](#Rou90),<a name="rSmi91"></a>[Smi91](#Smi91),<a name="rKae92"></a>[Kae92](#Kae92)] は、空の型式を排除します。
  Duggan と Ophel [<a name="rDO94"></a>[DO94](#DO94)] は、開かれたものと閉じたものとを区別することによって、両方のアプローチをサポートしています。
  Volpano [<a name="rVol93"></a>[Vol93](#Vol93)] は、これまでに知られている多くのオープン・ワールド・システムが不健全であると主張しています。
  Volpano の負の結果は、型クラスを持つプログラムの型なしの動的セマンティクスで動作するために発生します。
  我々は、これが Haskell のようなプログラムでは許されないと主張してきました。
  また、システムOの型なしの動的セマンティクスに関して型の健全性を証明することによって、 Volpano の批判は一般的にオープン・ワールド・システムには適用されないことを示しています。

  typecase構造を使用して、オーバーロードされたバリアントを区別し、オーバーロードの代替の処理方法は、それを動的タイピングの特殊なケースとみなします [<a name="rDRW95"></a>[DRW95](#DRW95),<a name="rHM95"></a>[HM95](#HM95)]。
  これらと同様のセマンティクスは、 Thatte [<a name="rTha94"></a>[Tha94](#Tha94)] によって研究されました。
  Thatte のセマンティクスは、プログラムを XML [<a name="rMH88"></a>[MH88](#MH88)] と同様に明示的に型付けされた多態性言語にマップします。
  型クラスは、この言語の再帰型の集合を表します。
  これとは対照的に、我々のセマンティクスは、型と型式のスキームがイデアル(ideal)を示す型のない言語にマップされます。

#### アウトライン

  この論文の残りの部分は次のように構成されています。
  2章は、システムOの構文と型定義の規則を示しています。
  3章は、構成的セマンティクスを開発し、型健全性の定理を証明します。
  4章では、辞書パッシング変換について説明します。
  5章は、多相レコード計算の符号化を提示します。
  6章では、型の再構成と主要型のプロパティについて説明します。
  7章で結論付けます。

## 2 型システム

    Unique variables       u ∈ U
    Overloaded variables   o ∈ O
    Constructors           k ∈ K = ∪{K_D | D ∈ D}
    Variables              x = u | o | k
    Terms                  e = x | λu.e | e e' | let u = e in e'
    Programs               p = e | inst o : στ = e in p

    Type variables         α ∈ A
    Datatype constructors  D ∈ D
    Type constructors      T ∈ T = D ∪ {->}
    Types                  τ = α | τ -> τ' | D τ1 ... τn        where n = arity(D)
    Type schemes           σ = τ | ∀α.πα => σ
    Constraints on α       πα= o1 : α -> τ1, ..., on : α -> τn  (n ≧ 0, with o1, ..., on distinct)
    Typotheses             Γ = x1 : σ1, ..., xn : σn            (n ≧ 0)

  図1: システムOの抽象構文

    Γ ⊢ x : σ (x : σ ∈ Γ)              (TAUT)

    Γ, πα ⊢ e : σ     (α ∉ tv(Γ))
    ------------------------------------ (∀I)
    Γ ⊢ e : ∀α.πα => σ

    Γ, u : τ ⊢ e : τ'
    ------------------------------------ (->I)
    Γ ⊢ λu.e : τ -> τ'

    Γ ⊢ e : σ     Γ, u : σ ⊢ e' : τ
    ------------------------------------ (LET)
    Γ ⊢ let u = e in e' : τ

    Γ ⊢ x1 : σ1 ... Γ ⊢ xn : σn
    ------------------------------------ (SET)
    Γ ⊢ x1 : σ1, ..., xn : σn

    Γ ⊢ e : ∀α.πα => σ   Γ ⊢ [τ/α] πα
    ------------------------------------ (∀E)
    Γ ⊢ e : [τ/α] σ

    Γ ⊢ e : τ' -> τ      Γ ⊢ e' : τ'
    ------------------------------------ (->E)
    Γ ⊢ e e' : τ

    (o : σ_{T'} ∈ Γ => T ≠ T')
    Γ ⊢ e : στ    Γ, o : στ ⊢ p : σ'
    ------------------------------------ (INST)
    Γ ⊢ inst o : στ = e in p : σ'

  図2: システムOの型付け規則

  オーバーロードされた識別子を持つ単純な関数型言語の議論に基づいています。
  図1は、項と型の構文を示しています。
  変数のアルファベットをユニーク変数のサブアルファベット `U` に分割し、
  オーバーロードされた変数には `u`、 変数は `o`、 データコンストラクタには `k`、 データコンストラクタには `K` を使用しました。
  文字 `x` は、ユニーク変数とオーバーロードされた変数、およびコンストラクタの両方に渡ります。
  オーバーロードされていないすべての変数 `u` は、たかだか1回のプログラムで束縛されていると仮定します。

  項の構文は、[<a name="rMil78"></a>[Mil78](#Mil78)] の Exp 言語と同じです。
  プログラムは、一連のインスタンス宣言と項で構成されています。
  インスタンス宣言（`inst o:στ = e in p`）は、型コンストラクタ `T` から構築されたすべての引数に `e` によって与えられた関数で識別子 `o` の意味をオーバーロードします。

  型 `τ` は、型変数、関数型、またはデータ型です。
  データ型は、データ型コンストラクタ `D` から構築されます。
  簡潔にするために、データ型 `Dτ1...τn` のすべての値コンストラクタとセレクタが事前定義されており、いくつかの固定初期型拘束では拘束が `Γ0` であると仮定します。
  ユーザ定義の型宣言では、与えられたプログラムで実際に宣言されているすべてのセレクタとコンストラクタを `Γ0` で単に収集します。
  `K_D` は、いくつかの型 `τ1,...,τn` に対して `Dτ1,...,τn` の値を生成するすべての値コンストラクタの集合です。

  `K_⫫ = ∅` であるボトムデータ型 `⫫ ∈ D` が存在すると仮定します。
  この型は Miranda に存在し、 `（）` と書かれていますが、 `（）` に値コンストラクタがあり、 `（）` と書かれている Haskell では存在しません。
  `T` はデータ型コンストラクタと関数型コンストラクタ `（->）` の間にあり、 `（->） τ τ` は `τ -> τ` の同義語となります。

  型スキーム `σ` は、型 `τ` と、型変数のいくつかの `τ` の量化子からなります。
  Hindley/Milner 多相型とは異なり、定量化された変数 `α` には束縛のセット（おそらく空の）である `πα` という制約が付いています。
  オーバーロードされた変数 `o` は、せいぜい制約内に一度しか現れません。
  制約は、指定された型でオーバーロードされた識別子が定義されることを要求することによって、型スキームのインスタンス型を制限します。
  Hindley/Milner 型スキーム `∀α.σ` は `∀α.（）=>σ` の構文糖とみなされます。

  図2は、システムOの型付け規則を定義しています。
  型システムは、2つの変更を除いて、[<a name="rDM82"></a>[DM82](#DM82)] に示されている元の Hindley/Milner システムと同じです。

  - 規則（∀I）において、導入された束縛変数 `α` に対する制約 `πα` は、仮説と型式の間で交換されます。
    ルール（∀E）は、除去された制約のインスタンス化を前提としています。
    制約は、ルール（SET）を使用して導出されます。
    これはルール（∀I）と（∀E）をルール（->I）と（->E）に対称にすることに注意してください。

  - インスタンス宣言のための追加規則（INST）があります。
    オーバーロードされた変数 `o` が明示的な型スキーム `στ` を有し、変数 `o` の各インスタンス化において型コンストラクタ `T` が異なることを除いて、ルールは（LET）に類似しています。

  ----

  最も外側の引数型のコンストラクタとして `T` を持つ閉じた型のスキームに対して `στ` の範囲を与えます:

    στ  = T α1 ... αn -> τ    (tv(τ) ⊆ {α1, ..., αn})
        | ∀α.πα => στ'       (tv(πα) ⊆ tv(στ')) .

  規則（INST）における `στ` の明示的宣言は、主要型が常に存在することを保証するために必要です。
  それがなければ、次のようなインスタンス宣言を宣言するかもしれません:

    inst o = λx.x in p

  ここで `o` がオーバーロードされている型コンストラクタを一意に決定することはできません。

  型スキーム `στ` に対する構文上の制限は、3つの性質を強制します:
  第１に、オーバーロードされたインスタンスは、指定された型コンストラクタのすべての引数に対して一様に働く必要があります。
  第2に、引数型は結果型を一意に決定しなければなりません。
  最後に、すべての制約が引数のコンポーネント型に適用される必要があります。
  制限は、型再構築アルゴリズムの終了を確実にするために必要です。
  例は6章で与えられます。

  型スキーム `στ` の構文上の制限は、制約 `πα` のオーバーロード変数がペアをつくれなければならない理由も説明します。
  オーバーロードされた関数の単相の引数は、その関数のインスタンス型を完全に決定します。
  したがって、任意の引数型 `τ` およびオーバーロードされた変数 `o` の場合、 `τ` 型の引数に `o` というインスタンス型が1つしか存在しないことがあります。
  このルールを型制約の制約の形で具体化することで、可能な限り早くそれを実施します。

  **例 2.1** 以下のプログラムの断片は、等価関数 `（==）` のインスタンス宣言を示しています。
  我々は Haskell の規則に表記法を適合させるため、型定義に `:` の代わりに `::` と書き、
  `∀α.(o : α -> τ1) => τ2` ではなく `(o::a->t1)=>t2` と書き、
  `inst o : σ = e` の代わりに `inst o :: s; o = e` と書きます。

    inst (==) :: Int -> Int -> Bool
         (==) = primEqInt

    listEq :: ((==)::a->a->Bool) => [a]->[a]->Bool
    listEq [] []         = True
    listEq (x:xs) (y:ys) = x == y && listEq xs ys

    inst (==) :: ((==):: a->a->Bool) => [a]->[a]->Bool
         (==) = listEq

  インスタンス宣言は再帰的ではないので、2番目のインスタンス宣言で `（==）` を直接使用することはできません。
  再帰的なインスタンス宣言に対するシステムOの拡張は価値がありますが、ここでは簡略化のために省略されています。

  **例 2.2** 以下の例は、オブジェクト指向のプログラミングスタイルを示し、 Haskell の型クラスよりも表現力が高いところを示しています。
  メンバーテストと2つの集合の和集合、交差と差異を計算する演算を使って、多相クラス `Set` のインスタンスを記述します。
  Haskell では、固定要素の型集合しか表現できませんでした。
  この例では、5章のレコード拡張を使用しています。
  そこにレコード構文の説明があります。

    type Set a sa
      = (union, inters, diff :: sa -> sa,
         member :: a -> Bool)
    inst set :: ((==)::a->a->Bool) => [a] -> Set a [a]
        set xs =
          (union  = \ys -> xs ++ ys,
           inters = \ys -> [y | y <- ys | y `elem` xs],
           diff   = \ys -> xs \\ ys,
           member = \y  -> y `elem` xs)

    inst set :: ((==),(<):: a->a->Bool)
                          => Tree a -> Set a (Tree a)
        set = ...

        -- m Here are some functions that work with sets.
        -- ここでは、集合で動作する関数をいくつか紹介します。

    union :: (set: sa -> Set a sa) => sa -> sa -> sa
    union xs ys = #union (set xs) ys

    diff :: (set: sa -> Set a sa) => sa -> sa -> sa
    diff xs ys = #diff (set xs) ys

    simdiff :: (set: sa -> Set a sa) => sa -> sa -> sa
    simdiff xs ys = union (diff xs ys) (dif ys xs)

## 3 意味論

  ここで、システムOの構成的意味論を示し、型付けがそれを尊重して健全であることを示します。
  セマンティクスは、関数の遅延評価を指定しますが、オーバーロードされた関数を除いて、最初の引数は正格です。
  あるいは、我々の定義にほとんど変化がなく、結果に変化がなく、すべての関数に対して正格評価を一様に仮定することができました。

  項の意味は、 `CPO V` の値であり、ここで `V` は次の式の最小解です

    V = W_⊥ + V -> V + Σ(k ∈ K) (k V1 ... V_{arity(k)})_⊥.

  ここで `（+）` と `Σ` は 融和した(coalesced) 和 <a name="r1"></a>[1](#1) を表し、 `V - > V` は連続関数空間を表します。
  値 `W` は型エラーを示します - これはしばしば "間違っている" と言われます。
  正しく型付けされたプログラムの意味は常に "間違っている" のではないことを示しています。

  項内の関数 `〚・〛` の意味は図3に示されています。
  これは、項と環境 `η` を引数としてとり、 `V` の要素を生成します。
  環境 `η` は、一意の変数を `V` の任意の要素にマップし、オーバーロードされた変数を正格な関数にマップします:

    η : U -> V ∪ O -> (V o-> V).

  `η [x:= v]` という表記は、 `x` と `v` との結合による環境 `η` の拡張を表します。

  我々のセマンティクスは、 Milner のセマンティクス [<a name="rMil78"></a>[Mil78](#Mil78)] よりも間違った項を検出する上で、より "怠惰" であることに注意してください。
  Milner のセマンティクスは関数アプリケーション `f W` を常に `W` にマップしますが、 `f` が正格な場合にのみ `f W = W` というセマンティクスではマッピングします。
  我々のセマンティクスは、引数が評価されたときに実際に実行される動的型チェックによく似ています。
  Milner の厳しいエラーチェックが採用されれば、結果は変わらないと予想しています。

  今、我々は型に意味を与えます。
  最初に、型変数を含まない型（単相型とも呼ばれます）から始めます。
  我々は単項式の範囲を決めるのに `μ` を使います。

  ----

  <a name="1"></a>[1](#r1) 総和の射影関数と射影関数は、一般に、混乱を避けるために暗黙のうちに残されます。

  ----

    〚x〛                    η = η (x)

    〚λu.e〛                 η = λv.〚e〛 η [u := v]

    〚k M1 ... Mn〛          η = k(〚M1〛 η) ... (〚Mn〛 η),
                                 where n = arity(k)

    〚e e'〛                 η = if 〚e〛 η ∈ V -> V then (〚e〛 η)(〚e'〛 η)
                                 else W

    〚let u = e in e'〛      η = 〚e'〛 η [u := 〚e〛 η]

    〚inst o : στ = e in p〛 η =
            if 〚e〛 η ∈ V -> V then
                〚p〛 η [o := extend(T,〚e〛 η,η(o))]
            else W
    where
      extend((->), f, g) =
        λv.if v ∈ V -> V then f(v) else g(v)
      extend (D, f, g) =
        λv.if ∃k ∈ K_D.v ∈ k {V...V | arity(k)} then f(v) else g(v).

  図3: 項の意味論

  ----

  [<a name="rMil78"></a>[Mil78](#Mil78)] と [<a name="rMPS86"></a>[MPS86](#MPS86)] に続いて、単相型はイデアルを示すようにします。
  我々の目的のために、イデアル `I` は、 `W` を含まず、下向きに閉じられ、限定的に閉じられている `V` の値の集合です。
  すなわち、 `y ≦ x` および `x ∈ I` のときはいつでも `y ∈ I` であり、有向集合 `X` のすべての要素 `x` については `x ∈ I` です。

  意味関数 `〚・〛` は、イデアルに単相型 `μ` をとります。
  それは以下のように定義されます。

    〚D μ1 ... μm〛 =
      {⊥} ∪ ∪{k 〚μ1'〛 ... 〚μn'〛
                 | Γ0 ⊢ k : μ1' -> ... -> μn' -> D μ1 ... μm}
    〚μ1 -> μ2〛 =
      {f ∈ V -> V | v ∈ 〚μ1〛 => f v ∈ 〚μ2〛}.

  **命題 3.1** `μ` を単相型とします。 このとき、 `〚μ〛` はイデアル(ideal)です。

  証明: `μ` の構造に対する帰納法により自明です。 □

  意味関数を型スキームに拡張しようとすると、制約付き型スキーム `∀α.πα=>σ` のインスタンスが環境内のオーバーロードされたインスタンスに依存するという難点があります。
  これは、環境と型スキームのための意味関数を索引付けすることによって説明されます。

  **定義** 単相型 `μ` は、環境 `η` における型スキーム `σ` の意味論的事例であり、これは以下の2つの規則から導き出すことができるならば、 `η ⊨ μ ≼ σ` です。

  (a) `η ⊨ μ ≼ μ`.

  (b) `η ⊨ μ ≼ [μ'/α] σ` かつ `η(o) ∈ 〚 [μ'/α] τ〛` となるような単相型 `μ'` が存在する場合、 `η ⊨ μ ≼ (∀α.πα => σ)` を全ての `o : τ ∈ πα` に対して行います。

  **定義** 閉じた型スキーム `σ` の意味 `〚σ〛 η` は、以下の式で与えられます

    〚σ〛 η = ∩{〚μ〛 | η ⊨ μ ≼ σ}.

  **定義** `i = 1, ..., n` であるとき `〚ei〛 η ∈ 〚σi〛 η` ならば `η ⊨ e1 : σ1, ..., en : σn` です。

  型スキームの意味は、型の意味と互換性があります。

  **命題3.2** `μ` を単相型とし、 `η` を環境とします。 このとき、 `〚μ〛 η = 〚μ〛`。

  証明: `〚σ〛 η` と `≼` の定義から自明です。 □

  ここで、型スキームがイデアルを示すことを示します。
  この証明には、ボトム型 `⫫` について2つの事実が必要です。

  **補題3.3** `η` を環境とします。

  （a） 任意の変数 `o`、 単相型 `μ` で `η ⊨ o : ⫫ -> μ` です。

  （b） `σ = ∀α1 :πα1 => ... ∀αn :παn => τ` を型スキームとします。
    このとき、 `η ⊨ [⫫/α1, ..., ⫫/αn] τ ≼ σ` となります。

  証明: （a） `v∈ 〚⫫〛` とします。 `⫫` はコンストラクタを持たないので、 `〚⫫〛 = {⊥}`、 したがって `v = ⊥` です。
  `η（o）` は正格な関数なので、 `η（o）v = ⊥` は全ての単相型の要素です。

  （b） `≼` と（a）の定義に従います。 □

  **命題3.4** `σ` を型スキームとし、 `η` を環境とすると、 `〚σ〛 η` はイデアルです。

  証明:
  クロージャの特性は、 `σ` の構造上の直接的な誘導によって示されます。
  それは `W ∉ 〚σ〛` と示されたままです。
  補題3.3（b）では、 `η ⊨ μ ≼ σ` というような単相型 `μ` が存在します。
  したがって、 `〚σ〛 η ⊆ 〚μ〛` です。
  しかし、 `〚μ〛` はイデアルなので、 `W` を含んでいません。 □

  命題3.4は、我々のセマンティクスの重要な特性を表現しています。
  たとえそれが型変数制約 `o : α -> τ` を含んでいても、すべての型スキームはイデアルです。ここで `o` は明示的に宣言されたインスタンスをまったく持っていません。
  したがって、そのような型式を静的に排除する必要はありません。
  これは、 [<a name="rSmi91"></a>[Smi91](#Smi91)] などの "閉じた世界" のアプローチとは対照的に、型チェックに対する Haskell の "オープンワールド" アプローチに対応します。
  興味深いことに、型スキームのセマンティクスでこれらの2つのアプローチを区別する唯一のものは、ボトム型 `⫫` がないか存在していることです。

  ここでは、システムOが健全であること、すなわち、構文型判定 `Γ ⊢ p : σ` が意味型判定 `Γ ⊨ p : σ` に反映されることを示します。

  **定義** `e` を項とし、 `Γ` を閉じた型とし、 `σ` を閉じた型スキームとします。
  このとき、すべての環境 `η` において、 `η ⊨ Γ` が `η ⊨ e : σ` を意味するならば、 `Γ ⊨ e : σ` です。

  最初のステップとして、項の健全性定理を証明します。
  これには補題が必要です。その補題は簡単です。

  **補題3.5** `η ⊨ e : σ` かつ `η ⊨ μ ≼ σ` ならば `η ⊨ e : μ` です。

  **定理3.6** （項の健全性）
  `Γ ⊢ e : σ` を有効な型判定とし、 `S` を `SΓ` と `Sσ` を閉じるように置き換えると、 `SΓ ⊨ e : Sσ` となります。

  証明:
  `Γ ⊢ e : σ` かつ `η ⊨ SΓ` を仮定します。
  我々は `Γ ⊢ e : σ` の導出について誘導を行います。
  我々は、対応する推論規則が Hindley/Milner システムと異なるケース（∀I）、（∀E）のみを示します。
  他の規則の証明は [<a name="rMil78"></a>[Mil78](#Mil78)] の扱いに似ています。

    Γ ⊢ u : σ ≻ u          (u : σ ∈ Γ)                 (TAUT)
    Γ ⊢ k : σ ≻ u          (k : σ ∈ Γ)                 (TAUT)
    Γ ⊢ o : σ ≻ u_{o,σ}    (o : σ ∈ Γ)                 (TAUT)

    Γ, o1 : τ1, ..., on : τn ⊢ e : σ ≻ e*    α ∉ tv(Γ)
    ---------------------------------------------------- (∀I)
    Γ ⊢ e : ∀α.(o1 : τ1, ..., on : τn) => σ
      ≻ λu_{o1,τ1}....λu_{on,τn}.e*

    Γ ⊢ e : ∀α.(o1 : τ1 ,..., on : τn) => σ ≻ e*
    Γ ⊢ oi : [τ/α] τi ≻ ei*       (i = 1, ..., n)
    ---------------------------------------------------- (∀E)
    Γ ⊢ e: [τ/α] σ
      ≻ e* e1* ... en*

    Γ, u : τ ⊢ e : τ' ≻ e*
    ------------------------------------------------- (->I)
    Γ ⊢ λu.e : τ -> τ
      ≻ λu.e*

    Γ ⊢ e1 : τ' -> τ ≻ e1*       Γ ⊢ e2 : τ' ≻ e2* 
    ------------------------------------------------- (->E)
    Γ ⊢ e1 e2 : τ
      ≻ e1* e2*

    Γ ⊢ e1 : σ ≻ e1*     Γ, u : σ ⊢ e2 : τ ≻ e2* 
    ------------------------------------------------- (LET)
    Γ ⊢ let u = e1 in e2 : τ
      ≻ let u = e1* in e2* : τ

    o : στ' ∈ Γ => T ≠ T'
    Γ ⊢ e : στ ≻ e       Γ, o : στ ⊢ p : σ' ≻ p*
    ------------------------------------------------ (INST)
    Γ ⊢ inst o : στ = e in p : σ'
      ≻ let u_{o,στ} = e* in p*

  図4:辞書パッシング変換

  （∀I）のケース: 導出の最後のステップは、いくつかの `α`、 `πα`、 `σ` と `σ = ∀α.πα => σ'` の

    Γ, πα ⊢ e : σ'   α ∉ tv(Γ)
    --------------------------------
    Γ ⊢ e : ∀α.πα => σ'

  です。

  すべての `μ` に対して `η ⊨ η ≼ ∀α.S πα => S σ'` となるように `e ∈ 〚μ〛` を示さなければなりません。
  そのような `μ` を任意に選びます。
  `（≼）` の定義により、 `η ⊨ [μ'/α] (S πα)` かつ `η ⊨ μ ≼ [μ'/α] (Sσ')` であるのような `a μ'` が存在します。
  `S' = [μ'/α] o S` $すると、 `η ⊨ S'Γ` かつ `η ⊨ S'(Γ,πα)` となります。
  `α∉tv（Γ）`、 `η| =S'Γ` $あり、従って `η| = S '（Γ、πα） ` $す。
  次に、帰納仮説によって、 `η ⊨ e : S' σ'` となります。
  補題3.5により `η ⊨ e : μ` となります。

  （∀E）のケース: 導出の最後のステップは

    Γ ⊢ e : ∀α.πα => σ'    Γ ⊢ [τ / α] πα
    ------------------------------------------
    Γ ⊢ e : [τ / α] σ'

  `σ = [τ/α] σ'` であるいくつかの `α`、 `πα`、 `σ'`、 `τ` とします。

  すべての `μ` に対して `η ⊨ μ ≼ [Sτ/α] Sσ'` となるように `e ∈ 〚μ〛` を示さなければなりません。
  そのような `μ` を任意に選びます。 帰納仮説によって、 `η ⊨ e : ∀α:Sπα => Sσ'` かつ `η ⊨ [Sτ/α] (Sπα)` となります。
  それは `η ⊨ μ ≼ ∀α:Sπα => Sσ'` という `≼` の定義に従います。
  補題3.5により、 `η ⊨ e : μ` となります。 □

  今、型宣言を含むことができるプログラム全体に型健全性定理を拡張します。

  **定理3.7** （プログラムの型健全性）
  `Γ ⊢ p : σ` を有効な閉じた型判定とすると、 `Γ ⊨ p : σ` となります。

  証明:
  `p` の構造上の誘導によって証明します。
  `p` が項である場合、結果は定理3.6に従います。
  それ以外の場合、 `p` はトップレベルのインスタンス宣言です。
  次に、 `Γ ⊢ p : σ` の導出の最後のステップは、いくつかの型スキーム `στ` のため

      o : στ' ∈ Γ => T ≠ T'
      Γ ⊢ e : στ    Γ, o : στ ⊢ p : σ
      -----------------------------------
      Γ ⊢ inst o : στ = e in p' : σ
  です。
  我々は、 `η ⊨ inst o : στ = e in p' : σ` を示さなければなりません。
  定理3.6により、 `η ⊨ e : στ` となり、 `〚e〛 η` は関数であることを意味します。
  したがって、 `〚p〛 η = 〚p'〛 η [o := f]` ここで `f = extend(T,〚e〛 η,η(o))` です。

  次のステップは `f∈ 〚στ〛 η` を示すことです。
  `μ` は、 `η ⊨ μ ≼ στ` となるようにすると、いくつかの単相型 `μ1, ..., μn, μ'` に対して、 `μ = T μ1, ..., μn -> μ'` となります。
    

  ここで、 `v ∈ 〚Tμ1, ..., μn〛` と仮定します。
  `v = ⊥` ならば `f v = ⊥ ∈ 〚μ'〛` です。
  そうでなければ、 `extend` の定義によって、 `f v = 〚e〛 η v` かつ `〚e〛 η v ∈ 〚μ'〛` です。
  どちらの場合も `f v ∈ 〚μ'〛` です。
  `v ∈ 〚Tμ1, ..., μn〛` は任意だったので、 `f ∈ 〚μ〛` となります。
  `μ` は任意であるので、これは `f ∈ [στ] η` を意味します。

  それは `η [o := f] ⊨ o : στ` となります。
  さらに、 `η ⊨ Γ` であり、 `Γ` はルール（INST）の前提によって、 `o : στ` という束縛を含んでいないので、 `η [o := f] ⊨ Γ` です。
  まとめると、 `η [o := 0 f] ⊨ Γ,o : στ` です。
  帰納仮説によって、 `η [o := f] ⊨ p' : σ` が命題を意味します。 □

  この定理の結果は、"正しく型付けされたプログラムに間違いはない" というスローガンを支持しています。

  **系3.8**
  `Γ ⊢ p : σ` を有効な閉じた型判定とし、 `η` を環境とします。
  `η ⊨ Γ` ならば、 `〚p〛 η ≠ W` です。

  証明: 定理3.7と命題3.4から自明です。 □

## 4 変換

  この章では、システムOから Hindley/Milner システムへの"辞書パッシング"変換を研究します。
  その中心的なアイディアは、 `∀α.πα=>τ` 型の項を、 `πα` でオーバーロードされた変数の実装を引数とする関数に変換することです。
  これらの引数は"辞書"とも呼ばれます。

  変換のターゲット言語は、型スキームのオーバーロード変数 `o` 、インスタンス宣言、 および制約 `πα` を取り除くことによってシステム Oから得られる Hindley/Milner システムです。
  項の変換は図4に示されています。
  これは型導出の関数として定式化されます。ここでは、項またはプログラム `p` の変換を定義する追加の構成要素 `e*` を使用して型判定を補強します。(例`Γ ⊢ p : σ ≻ p*`)
  変換の一貫性を保証するために、型変数制約 `{o1 : α -> τ1, ..., on : α -> τn}` のオーバーロードされた識別子 `oi` は常に辞書順に並べられると仮定します。

  型と型スキームは次のように変換されます。

                            τ* = τ
                 (∀α.e => σ)* = ∀α.σ*
    (∀α.o : α -> τ, πα => σ)* = ∀α.(α -> τ) -> (∀πα => σ)*

  最後の句は、型スキームを矢印の結果部分として生成できる点で、型構文に違反します。
  これは、以下を定義することによって補償されます

    τ -> ∀α.σ def= ∀α.τ -> σ.

  バインディングとタイポは次のように変換されます。

                 (u : σ)* = u : σ* 
                 (o : σ)* = u_{o,σ} : σ*.
    o1 : σ1, ..., on : σn = (o1 : σ1)*, ..., (on : σn)*.

  これは、オーバーロードされた変数 `o` を、新しい固有変数 `u_{o,σ}` に変換し、その固有性は、名前 `o` とその型スキーム `σ` の両方に依存します。

  システムOの各派生ルール `Γ ⊢ p : σ` は、 Hindley/Milner システムの変換された仮説、項、型スキームの導出に対応します。
  したがって:

  **命題 4.1** `Γ ⊢ p : σ ≻ p*` が有効な場合、 `Γ* ⊢ p* : σ*` は Hindley/Milner システムで有効です。

  変換は、以下の意味でセマンティクスを満たしていると考えています。

  **推測** `p` をプログラム、 `η` を単相型、 `η` を環境とします。
  `Γ` をオーバーロード変数を含まない定理とします。
  `Γ ⊢ p : μ ≻ p*` かつ `η ⊨ Γ` の場合、 `〚p〛 η = 〚p*〛 η` です。

  上記のクレームは明らかに正しいようですが、その正式な証明は自明ではありません。
  変換の一貫性は、上記の推測から直ちに続くことに注意してください。
  一貫性は明白なように見えますが、 [<a name="rBlo91"></a>[Blo91](#Blo91), <a name="rJon92a"></a>[Jon92a](#Jon92a)] のデモンストレーションをするのは難しいことであるので、上記の推測がこのプロパティを共有することはおそらく驚くことではありません。

## 5 レコード型付けとの関系

  この章では、大堀の [<a name="rOho92"></a>[Oho92](#Oho92)] と同様の簡単な多相レコード計算法を用いて、型システムの拡張を研究します。
  図5は拡張計算を詳述しています。
  システムOに以下を追加します

  - レコード型 `{l1:τ1、...、ln:τn}`、
  - レコード式 `{l1 = e1、...、ln = en}`、 および
  - セレクタ関数 `＃l`。

  大堀の仕事のように、レコードの更新を追加するのは簡単だが、Wand [<a name="rWan87"></a>[Wan87](#Wan87)] や Remy [<a name="rRem89"></a>[Rem89](#Rem89)] の仕事のように、レコードの拡張を扱うのは難しいことです。
  Jones [<a name="rJon92a"></a>[Jon92a](#Jon92a)] は、レコードのAC理論への統合を拡張し、レコード内にフィールドがないことを示す（マルチパラメータ）型のクラスを使用することによって、Remy の拡張可能なシステムを埋め込む方法を示しました。
  ただし、ここでは簡単にするために更新と拡張の両方を省略しています。

  セレクタ関数の型を現時点で開いたままで、これまで提示されているシステムは、レコードが Standard ML で定義されている方法におおよそ対応しています。
  セレクタは Standard ML でオーバーロード関数として扱われます。
  すべてのオーバーロードされた関数と同様に、セレクタの引数の型は静的に知る必要があります。
  そうでない場合は、オーバーロードの解決エラーが発生します。

  我々のレコード拡張では、セレクタをオーバーロードされた関数として扱いますが、システムOのオーバーロードの概念を使用しています。
  セレクタ `＃l` の最も一般的な型式は以下の通りです

    ∀β.∀α.(α ≦ {l : β}) => α -> β.

  これは、フィールド `l : τ` を持つレコードに `#l` を適用できることを示しており、この場合、型 `τ` の値が得られます。
  型スキームは、部分型制約 `α ≦ ρ` を使用します。
  部分型の制約は、図5の部分型の規則を使用して検証されます。
  それ以外の点では、それらは、制約 `o : α -> τ` のオーバーロードのように動作します。

  **例 5.1** 以下のプログラムは、（便宜上、 `max` の型が追加されている）システムOで型付け可能です。

      let max : ∀β.((<) : β -> β -> bool) =>
                  ∀α. (α ≦ {key : β}) => α -> α -> α
              = λx.λy. if #key x < #key y then y else x
      in
          max {key = 1, data = a} {key = 2, data = b}

  Standard ML では、セレクタ `＃key` の引数型も、多重定義関数 `(<)` の引数型も静的に解決できないので、同じプログラムは型付けできません。

  部分型制約のバインドされた変数は、次のように制約レコード型にも現れることに注意してください。

    ∀α.(α ≦ {l : α -> bool}) => [α]

  したがって、我々の計算には束縛された多相型に関連した包摂および反変則が欠けているので、限られた形のF束縛多相型 [CCH + 89] が限定されて限られています [<a name="rCW85"></a>[CW85](#CW85)]。
  我々のシステムがオブジェクト指向プログラミングをモデル化するためにどれほど適しているかはまだ分かりません。
  オブジェクト指向プログラミング言語におけるいくつかの最近の進展は、部分型を抽象クラスに限定することによって、同じ方向に進むように見えます [<a name="rSOM93"></a>[SOM93](#SOM93)]。

  ここでは、レコードの拡張によって基本的に新しいことは何も追加されないことが示されています。
  これを行うには、システムOからシステムOへのレコードを含むエンコーディングを提示します。
  エンコーディングのソースはレコードを持つプログラムで、ソースプログラムのすべてのレコード式 `{l1 = e1, ..., ln = en}` のラベル `l1, ..., ln` は辞書順にソートされています（そうでない場合は、フィールドを並べ替えるだけです）。
  エンコーディングの詳細は次のとおりです。

  - 1 プログラム内のすべてのレコードフィールドラベル `l` は、 `l` と呼ばれるオーバーロードされた変数で表されます。

  - 2 プログラム内のすべてのレコード式 `{l1 = e1, ..., ln = en}` に対して、同じ名前のコンストラクタを使用して新しい `n-ary` データ型 `R_{l1...ln}` を追加します。 宣言によって与えられたセレクタは以下の通りです

      data R_{l1...ln} α1 ...αn = R_{l1...ln} α1 ...αn.

  - 3 ステップ2で作成したすべてのデータ型 `R_{l1...ln}` とすべてのラベル `li(i = 1, ...,n)` に対して、インスタンス宣言を追加します

        inst li : ∀_{α1...αn}.R_{l1...ln} α1 ...αn -> αi
              = λ (R_{l1...ln} x1 ... xn) :xi

    （仮パラメータのパターン記法が便宜のために使用される）。

  - 4 レコード式 `{l1 = e1, ..., ln = en}` は、 `R_{l1...ln} e1 ...en` と変換されます。
  - 5 セレクタ関数 `#l` は `l` に変換されます。
  - 6 レコード型 `{l1 : τ1, ..., ln : τn}` は、 `Rl1 ... lnτ1...τn` と変換されます。

  ---

    Additional Syntax
        Field labels        l  ∈ L
        Terms               e  = ... | #l | {l1 = e1, ..., ln = en}  (n ≧ 0)
        Record types        ρ  = {l1 : τ1, ..., ln : τn}             (n ≧ 0, with l1, ..., ln distinct)
        Types               τ  = ... | ρ
        Constraints on α    πα = ... | α ≦ ρ
        Typotheses          Γ  = ... | α ≦ ρ

    Subtyping Rules

        Γ, α ≦ ρ ⊢ α ≦ ρ                                            (Taut)

        Γ ⊢   {l1 : τ1, ..., ln : τn, ln+1 : τn+1, ..., ln+k : τn+k}
             ≦ {l1 : τ1, ..., ln : τn}                                (Rec)

    Additional Typing Rules

        Γ ⊢ e1 : τ1   ...   Γ ⊢ en : τn
        --------------------------------------------------------------({} I)
        Γ ⊢ {l1 = e1, ..., ln = en} : {l1 : τ1, ..., ln : τn}

        Γ ⊢ #l : ∀β: ∀α ≦ {l : β}.α -> β                            ({} E)

  図5: レコード型の拡張

  - 7 部分型制約 `α ≦ {l1 : τ1, ..., ln : τn}` は、オーバーロード制約 `l1 : α -> τ1, ..., ln : α -> τn` となります。

  `e†`、 `σ†`、 または `Γ†` を、この変換を、項 `e`、 型スキーム `σ`、 または仮説 `Γ` に適用した結果とします。
  次に、

  **命題5.2** `Γ† ⊢ e† : τ†` ならば `Γ ⊢ e : τ`。

  命題5.2は、システムOの型の健全性と主要型のプロパティをレコードの拡張に拡張することを可能にします。
  また、オーバーロードされた識別子の実装体系を考慮して、レコードの実装体系も指しています。

  **例 5.3** 例 5.1のプログラムは以下に変換されます

    inst data : ∀α∀β:R_{data,key} α β -> α
              = λR_{data,key} x y. x in
    inst key  : ∀α∀β:R_{data,key} α β -> β
              = λR_{data,key} x y. y in
    let max   : ∀β.((<) : β -> β -> bool) =>
                ∀α.(key : α -> β)=> α -> α -> α
              = λx.λy.if key x < key y then y else x
    in
          max (R_{data,key} 1 a) (R_{data,key} 2 b)

  レコードは、型シグネチャにオーバーロードされた識別子の数を含めるのに役立ちます。
  この考え方は、オーバーロードされた単一の識別子で構成されたレコードに関連する操作を入れることです。
  次の例は、このように単純化された `Num` クラスをモデル化する方法を示しています。
  Haskell のような構文では、レコードに対して中括弧 `{...}` のかわりに `(...)` を使用します。

    type Num a = (plus :: a -> a -> a,
                  minus:: a -> a -> a,
                  neg  :: a -> a)
    over num
    inst num :: Int -> Num Int
        num = ...

    (+), (-) :: (num :: a -> Num a) => a -> a -> a
    neg      :: (num :: a -> Num a) => a -> a
    (+) x y = #plus  (num x) x y
    (-) x y = #minus (num x) x y
    neg x   = #neg   (num x) x

  辞書の受け渡しとの類似点に注意してください。
  Haskell のクラス宣言に関するこのスキームの1つの欠点は、サブクラス化に関係します。
  例えば、 `(num :: a -> Num a) => a` 型の変数を型の関数に渡すことができませんでした

    (num :: a -> (plus  :: a -> a -> Bool,
                  minus :: a -> a -> Bool)) => a -> b

  レコードに完全な部分型を導入しなくても、この一般的なケースに対処するためにシステムを補うことは役に立ちます。
  これを決定するにはさらに経験が必要です。

## 6 型再構築

  図6と図7は、システムOの型再構築と単一化アルゴリズムを示しています。
  Milner のアルゴリズムW [<a name="rMil78"></a>[Mil78](#Mil78)] と比較すると、2つの拡張があります。

  - 単一化アルゴリズムにおいて型変数を束縛する場合が拡張されています。
    型変数 `α` を型 `τ` にバインドするには、 `Γα` の制約を満たす必要があります。
    関数 `mkinst` は、型 `τ` が制約 `Γα` を保証することを保証します。

   - 関数 `tp` は、インスタンス宣言 `o : στ = e in p` の分岐で拡張されます。
     この場合、オーバーロード項 `e` の推論された型 `στ'` は、与えられた型 `στ` より一般的ではないことをチェックしなければなりません。

  ここで、アルゴリズム `unify` と ` tp` の健全性と完全性の結果を述べます。
  これらの結果の証明は、[<a name="rChe94"></a>[Che94](#Che94)] と同様に行います。 ここでは省略されています。

  以下の略語を使用します:

    Γα = {o : α -> τ | o : α -> τ ∈ Γ}
    ΓA = ∪_{α ∈ A} Γα

  ここで `A` は型変数の集合です。

  **定義**
  構成は、すべての `α ∈ dom(S)` に対して、 `Γα = ∅` であるような仮説 `Γ` と置換 `S` の対です。

    unify : (τ,τ) -> (Γ,S) -> (Γ,S)
    unify (τ1,τ2) (Γ,S) = case (S τ1,S τ2) of
      (α,α) =>
        (Γ,S)
      (α,τ),(τ,α) where α ∉ tv(τ) =>
        foldr mkinst (Γ \ Γα,[τ / α] o S) Γα
      (T τ1s,T τ2s) =>
        foldr unify (Γ,S) (zip(τ1s,τ2s))

    mkinst : (o : α -> τ) -> (Γ,S) -> (Γ,S)
    mkinst (o : α -> τ) (Γ,S) = case S α of
      β =>
        if ∃o : β -> τ' ∈ Γ
        then unify (τ,τ') (Γ,S)
        else (Γ ∪ {o : β -> [β / α] τ},S)
      T τs =>
        case {newinst(στ,Γ,S) | o : στ ∈ Γ} of
          {(τ1,Γ1,S1)} => unify (α -> τ,τ1) (Γ1,S1)

  図6: 制約付き単一化アルゴリズム

  **定義** 以下では、置換と構成に関する前順序(preorder) `≼` と型スキームの前順序 `≼Γ` を定義しています。
  `X≼Y` なら `Y` は `X` より一般的です。

  - `S' = R o S` となるような置換 `R` が存在する場合、 `S' ≼ S` です。
  - `S' ≼ S`, `S'Γ' ⊢ S'Γdom(S')` かつ `Γ' ⊇ Γ \ Γdom(S')` ならば `(Γ',S') ≼ (Γ,S)` です。
  - すべての `u ∉ dom(Γ)` に対して、 `Γ ⊢ u : σ` が `Γ ⊢ u : σ'` を意味するならば、 `σ' ≼Γ σ` です。

  **定義** 制約付き単一化問題は、 `(τ1,τ2)(Γ,S)` の組で、 `τ1,τ2` は型であり、 `(Γ,S)` は構成です。

  構成 `(Γ',S')` は、 `(Γ',S') ≼ (Γ,S)` かつ `S' τ1 = S' τ2` の場合、 `(τ1,τ2)(Γ,S)` の単一化構成と呼ばれます。

  `(Γ'',S'') ≼ (Γ',S')` の場合は単一化構成 `(Γ',S')` は、他のすべての単一化構成 `(Γ'',S'')` で最も一般的です。

  **定義** 型付け問題は、 `(Γ,S)` が構成であり、 `p` が `fv(p) ⊆ dom(Γ)` を持つ項またはプログラムである三つ組 `(p,Γ,S)` です。

  型付け問題 `(p,Γ,S)` の型付け解決は3つ組 `(σ,Γ',S')` です。ここで `(Γ',S') ≼ (Γ,S)` かつ `S'Γ' ⊢  p : S'σ` です。

  他のすべての型付け解決 `(σ'',Γ'',S'')` は `(Γ'',S'') ≼ (Γ',S')` かつ `S'' σ'' ≼S''Γ'' S'' σ` が成り立つ場合、型付け解決 `(σ,Γ',S')` が最も一般的です。

  **定理6.1** `(τ1,τ2)(Γ,S)` を束縛された単一化問題とします。

  （a） `unify(τ1,τ2)(Γ,S) = (Γ',S')` の場合、 `(Γ',S')` は `(τ1,τ2)(Γ,S)` の最も一般的な単一化構成です。

  （b） `unify(τ1,τ2)(Γ,S)` が失敗した場合、 `(τ1,τ2)(Γ,S)` の単一化構成は存在しません。

  **定理6.2** `(p,Γ,S)` は型付け問題とします。

  （a） `tp (p,Γ,S) = (σ,Γ',S')` ならば、 `(σ,Γ',S')` は最も一般的な `(p,Γ,S)` の解です。

  （b） `tp (p,Γ,S)` が失敗した場合、 `(p,Γ,S)` は解決策を持ちません。

  定理6.2の結果として、すべての型付きプログラムは `tp` によって見つけられる主要な型を持つことが分かります。

  **結果6.3** (主要型) `(p,Γ, id)` が `tv(Γ) = ∅` となるような型付け問題とします。

  (a) `gen (tp (p,Γ,id)) = (σ',Γ',S)` かつ `let σ = Sσ'` と仮定すると、

      Γ ⊢ p : σ                かつ
      Γ ⊢ p : σ'' => σ'' ≼Γ σ, すべての型スキーム σ'' について.

  （b） `tp (p,Γ,id)` が失敗すると、 `Γ ⊢ p : σ` となる型スキーム `σ` はありません。

  `unify` と `mkinst` の終了は、オーバーロードされた型スキーム `στ` の形式に非常に依存します:

    στ = T α1 ... αn -> τ   (tv(τ) ⊆ {α1, ..., αn})
       | ∀α.πα => στ'      (tv(πα) ⊆ tv(στ')).

  我々は、 `στ` が `T` の引数でパラメトリックでなければならない例を示します。
  以下のプログラムを考えてみましょう。ここで `k ∈ KT` です。

    p = let (;) x y = y in
        inst o : ∀α.o : α -> α => T(Tα) -> α
            = λk (k x).o x
        in λx.λy.λf. o x; o y; f (k y); f x

  次に、 `tp (p,∅,id)` の計算は、 `x : α, y : β, f : Tβ -> δ ∈ Γ` を用いて `tp (f x,Γ,S)` と呼びます。
  これは、次の仮定が成り立つところで、 `unify (α,Tβ)(Γ,S)` を呼び出します。

  - `στ = ∀α.o : α -> α => T(Tα) -> α`
  - `Γ ⊇ {o : α -> α,o : β -> β,o : στ}`,
  - `S` は `α,β ∉ dom (S)` の置換です。

  ----

  `unify` を展開すると `mkinst (o : α -> α)(Γ \ Γα, S')` (ここで `S' = [Tβ/α] o S`) が得られ、次の2つの呼び出しにつながります:

  - 1 `newinst(στ, Γ \ Γα, S') = (T (T γ) -> γ, Γ', S')` ここで `Γ' ⊇ {o : β -> β, o : γ -> γ, o : στ}` であり、かつ `γ` は新鮮な型変数であり、

  - 2 `unify (α -> α, T (T γ) -> γ)(Γ', S')` です。

  ----

  `S' α = Tβ` 以降、 （2）を展開すると、 `unify (β, Tγ)(Γ,S)` を呼び出す `Tβ` と `T (Tγ))` を単一化しようとします。
  これは、元の呼び出し `unify (α, Tβ)(Γ,S)` を `α,β` から `β,γ` にモジュロ改名することと同等です。
  したがって、この状況では `unify` がループします。

  `στ` に対する他の制限の必要性は、同様の構成によって示されます。
  たとえば、単一化を通常のツリーに拡張することによって [<a name="rKae92"></a>[Kae92](#Kae92)]、これらの制限を解除する、より一般的なシステムが実現可能かどうかはまだ分かっていません。

## 7 結論

  我々は、 Hindley/Milner システムのやや控えめな拡張が、限定されたF境界型多相型を持つ多重定義と多相型レコードの両方をサポートするのに十分であることを示しました。
  得られたシステムは、 Hindley/Milner システムに完全に類似した型の健全性および主要型の特性を備えた、ML型の伝統にしっかりと留まります。

    newinst     : (σ,Γ,S)  ->  (τ,Γ,S)
    newinst(∀α.πα => σ,Γ,S)
                = let β a new type variable
                  in  newinst
                  ([β/α] σ,Γ ∪ [β/α] πα,S)
    newinst(τ,Γ,S)
                = (τ,Γ,S)

    skolemize   : (σ,Γ,S) -> (τ,Γ,S)
    skolemize (∀α.πα => σ,Γ,S)
                = let T a new 0-ary type constructor
                  in  skolemize
                      ([T/α] σ,Γ ∪ [T/α] πα,S)
    skolemize (τ,Γ,S)
                = (τ,Γ,S)

    gen         : (τ,Γ,S) -> (σ,Γ,S)
    gen (σ,Γ,S) = if ∃ α.α ∈ tv(Sσ) \ tv(S (Γ\Γα))
                  then gen (∀α.Γα => σ,Γ\Γα,S)
                  else (σ,Γ,S)

    tp          : (p,Γ,S) -> (τ,Γ,S)
    tp (u,Γ,S)  = if u : σ ∈ Γ
                  then newinst (σ,Γ,S)

    tp (o,Γ,S)  = newinst (∀β ∀α: (o : α -> β) => α -> β,Γ,S)

    tp (λu.e,Γ,S)
                = let α a new type variable
                    (τ,Γ1,S1) = tp (e, Γ ∪ {u : α},S)
                  in (α -> τ,Γ1,S1)

    tp (e e',Γ,S)
                = let (τ1,Γ1,S1) = tp (e,Γ,S)
                      (τ2,Γ2,S2) = tp (e,Γ1,S1)
                      α a new type variable
                      (Γ3,S3) = unify (τ1,τ2 -> α) (Γ2,S2)
                  in (α,Γ3,S3)

    tp (let u = e in e',Γ,S)
                = let (σ,Γ1,S1) = gen (tp (e,Γ,S))
                  in tp (e,Γ1 ∪ {u : σ},S1)

    tp (inst o : στ = e in p,Γ,S)
                = let (στ',Γ1,S1) = gen (tp (e,Γ,S))
                      (τ2,Γ2,S2) = skolemize (στ,Γ1,S1)
                      (τ3,Γ3,S3) = newinst (στ',Γ2,S2)
                  in if ∀o : στ' ∈ Γ . T ≠ T' ∧
                        unify (τ2,τ3)(Γ3,S3) defined then
                          tp (p, Γ1 ∪ {o : στ},S1)

  図7: システムOの型再構築アルゴリズム

  システムOの多相レコード計算の符号化は、F境界のある多相性とオーバーロードとの間により深い関係がある可能性があることを示しています。
  これは、型クラスのための辞書変換と有界多相のためのペン変換 [<a name="rBTCGS91"></a>[BTCGS91](#BTCGS91)] との間の類似点によっても示唆されます。
  これらの関係の研究は今後の課題として残されています。

## 謝辞

  本書のこれまでの草案に関する貴重なコメントをお寄せいただきました Kung Chen と John Maraist には感謝しています。
  レコードに関する章は、 Simon Peyton Jones、 Mark Jones、 および Haskell のメーリングリストの他の人が主催したディスカッションによって動機づけられました。
  多数の参加者との他の多くの議論もこの作業に貢献しています。

## 参考文献

  [<a name="App93"></a>[App93](#rApp93)] Andrew W. Appel. A critique of standard ML. Journal of Functional Programming, 3(4), 1993.

  [<a name="Aug93"></a>[Aug93](#rAug93)] Lennart Augustsson. Implementing Haskell overloading. In Proc. ACM Conf. on Functional Programming Languages and Computer Architecture, pages 65-73, June 1993.

  [<a name="Blo91"></a>[Blo91](#rBlo91)] Stephen Blott. An Approach to Overloading with Polymorphism. PhD thesis, Department of Computer Science, University of Glasgow, Sept 1991.

  [<a name="BTCGS91"></a>[BTCGS91](#rBTCGS91)] Val Breazu-Tannen, Thierry Coquand, Carl A. Gunter, and Andre Scedrov. Inheritance as implicit coercion. Information and Computation, 93:172-221, 1991.

  [<a name="CCH+89"></a>[CCH+89](#rCCH+89)] Peter Canning, William Cook, Walter Hill, Walter Olthoff, and John C. Mitchell. F-bounded polymorphism for object-oriented programming. In Functional Programming Lan-guages and Computer Architecture, pages 273-280, September 1989.

  [<a name="Che94"></a>[Che94](#rChe94)] Kung Chen. A Parametric Extension of Haskell's Type Classes. PhD thesis, Yale University, New Haven, Connecticut, December 1994. YALEU/DCS/RR-1057.

  [<a name="CHO92"></a>[CHO92](#rCHO92)] Kung Chen, Paul Hudak, and Martin Odersky. Parametric type classes. In Proc. ACM Conf. on Lisp and Functional Programming, pages 170-181, June 1992.

  [<a name="CW85"></a>[CW85](#rCW85)] Luca Cardelli and Peter Wegner. On under-standing types, data abstraction, and polymorphism. Computing Surveys, 17(4):471-522, De- cember 1985.

  [<a name="DM82"></a>[DM82](#rDM82)] Luis Damas and Robin Milner. Principal type schemes for functional programs. In Proc. 9th ACM Symposium on Principles of Program-ming Languages, January 1982.

  [<a name="DO94"></a>[DO94](#rDO94)] Dominic Duggan and John Ophel. Kinded parametric overloading. Technical Report CS-94-35, University of Waterloo, September 1994.

  [<a name="DRW95"></a>[DRW95](#rDRW95)] Catherine Dubois, Francois Rouaix, and Pierre Weis. Extensional polymorphism. In Proc. 22nd ACM Symposium on Principles of Pro-gramming Languages, pages 118-129, January 1995.

  [<a name="HHPW94"></a>[HHPW94](#rHHPW94)] Cordelia Hall, Kevin Hammond, Simon Pey-ton Jones, and Philip Wadler. Type classes in Haskell. In Proc. 5th European Symposium on Programming, pages 241-256, 1994. Springer LNCS 788.

  [<a name="HM95"></a>[HM95](#rHM95)] Robert Harper and Greg Morrisett. Compiling polymorphism using intensional type analysis. In Proc. 22nd ACM Symposium on Principles of Programming Languages, pages 130-141, January 1995.

  [<a name="Jon92a"></a>[Jon92a](#rJon92a)] Mark P. Jones. Qualified Types: Theory and Practice. D.phil. thesis, Oxford University, September 1992.

  [<a name="Jon92b"></a>[Jon92b](#rJon92b)] Mark P. Jones. A theory of qualified types. In Proc. 4th European Symposium on Programming, pages 287-306, February 1992. Springer LNCS 582.

  [<a name="Jon93"></a>[Jon93](#rJon93)] Mark P. Jones. A system of constructor classes: Overloading and implicit higher-order polymorphism. In Proc. ACM Conf. on Functional Programming Languages and Computer Architecture, pages 52-61, June 1993.

  [<a name="JT81"></a>[JT81](#rJT81)] R.D. Jenks and B.M. Trager. A language for computational algebra. In Proc. ACM Symposium on Symbolic and Algebraic Manipulation, pages 22-29, 1981.

  [<a name="Kae88"></a>[Kae88](#rKae88)] Stefan Kaes. Parametric overloading. In Proc. 2nd European Symposium on Programming. Springer-Verlag, 1988. Springer LNCS 300.

  [<a name="Kae92"></a>[Kae92](#rKae92)] Stefan Kaes. Type inference in the presence of overloading, subtyping, and recursive types. In Proc. ACM Conf. on Lisp and Functional Programming, pages 193-204, June 1992.

  [<a name="MH88"></a>[MH88](#rMH88)] John C. Mitchell and Robert Harper. The essence of ML. In Conference Record of the Fifteenth Annual ACM Symposium on Principles of Programming Languages, pages 28-46. ACM, ACM Press, January 1988.

  [<a name="Mil78"></a>[Mil78](#rMil78)] Robin Milner. A theory of type polymorphism in programming. Journal of Computer and System Sciences, 17:348-375, Dec 1978.

  [<a name="MPS86"></a>[MPS86](#rMPS86)] D. MacQueen, G. Plotkin, and R. Sethi. An ideal model for recursive polymorphic types. Information and Control, 71:95-130, 1986.

  [<a name="NP93"></a>[NP93](#rNP93)] Tobias Nipkow and Christian Prehofer. Type checking type classes. In Proc. 20th ACM Symposium on Principles of Programming Languages, pages 409-418, 1993.

  [<a name="NS91"></a>[NS91](#rNS91)] Tobias Nipkow and Gregor Snelting. Type classes and overloading resolution via order-sorted unification. In Proc. ACM Conf. on Functional Programming Languages and Computer Architecture, pages 1-14, August 1991. Springer LNCS 523.

  [<a name="Oho92"></a>[Oho92](#rOho92)] Atsushi Ohori. A compilation method for ML-style polymorphic record calculi. In Proc. 19th ACM Symposium on Principles of Programming Languages, pages 154-165, January 1992.

  [<a name="Pet94"></a>[Pet94](#rPet94)] John Peterson. Structures in Yale Haskell. draft paper, 1994.

  [<a name="PJ93"></a>[PJ93](#rPJ93)] John Peterson and Mark Jones. Implementing type classes. In Proc. ACM Conf. on Programming Language Design and Implementation, pages 227-236, June 1993. SIGPLAN Notices 28(6).

  [<a name="Rem89"></a>[Rem89](#rRem89)] D. Remy. Typechecking records and variants in a natural extension of ML. In Proc. 16th ACM Symposium on Principles of Programming Languages, pages 77-88. ACM, January 1989.

  [<a name="Rou90"></a>[Rou90](#rRou90)] François Rouaix. Safe run-time overloading. In Proc. 17th ACM Symposium on Principles of Programming Languages, pages 355-366, January 1990.

  [<a name="Smi91"></a>[Smi91](#rSmi91)] Geoffrey S. Smith. Polymorphic type inference for languages with overloading and subtyping. PhD thesis, Cornell University, Ithaca, NY, August 1991.

  [<a name="SOM93"></a>[SOM93](#rSOM93)] Clemens Szyperski, Stephen Omohundro, and Stephan Murer. Engineering a programming language: The type and class system of Sather. In Programming Languages and System Architectures, pages 208-227. Springer Verlag, Lecture Notes in Computer Science 782, November 1993.

  [<a name="Tha94"></a>[Tha94](#rTha94)] Satish R. Thatte. Semantics of type classes revisited. In Proc. Conference on Lisp and Functional Programming, pages 208-219, 1994.

  [<a name="Vol93"></a>[Vol93](#rVol93)] Dennis Volpano. A critique of type systems for global overloading. Computer Science Technical Report NPSCS-94-006, Naval Postgraduate School, October 1993.

  [<a name="Wan87"></a>[Wan87](#rWan87)] Mitchell Wand. Complete type inference for simple objects. In Proc.IEEE Symposium on Logic in Computer Science, pages 37-44, June 1987.

  [<a name="WB89"></a>[WB89](#rWB89)] Philip Wadler and Stephen Blott. How to make ad-hoc polymorphism less ad-hoc. In Proc. 16th ACM Symposium on Principles of Programming Languages, pages 60-76, January 1989.

