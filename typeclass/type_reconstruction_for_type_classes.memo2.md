## アジェンダ

  - 要約
  - 1 はじめに
  - **2 Mini-Haskell**
  - 3 型推論システム
  - ４ ソート制約付き単一化
  - 5 アルゴリズムW
  - 6 アルゴリズムI

---

## 2 Mini-Haskell

  - この論文の目的は簡単
    - 型クラスに関する Haskell の最も重要な機能だけを扱う
  - 結果として得られる言語
    - 基本的に Mini-ML (CDDK86) + クラスとインスタンス宣言
    - Mini-Haskell
  - 次の段落では、型クラスの簡単な説明を提供
    - 動機と例
      - Haskell レポート (HJW92) 
      - 型クラスに関するオリジナルの論文 (WB89) を参照

  - この例では、 Haskell のクラスなどの具体的な名前に従わないことに注意

---

## 図1. Mini-Haskell 型と式の構文

    Type classes        C
    Sorts               S  = {C1, ..., Cn}
    Type variables      α
    Type constructors   t
    Types               τ  = α | t(τ1, ..., τn)
    Type schemes        σ  = τ | ∀α:S.σ
    Identifiers         x
    Expressions         e  = x
                           | (e0 e1)
                           | λx.e
                           | let x = e0 in e1
    Declarations        d  = class α : C ≤ S where x : σ
                           | inst t : (S1, ..., Sn)C where x = e
    Programs            p  = d; p | e

---

### Mini-Haskell

  - 制限された形式のオーバーロードによってMLを拡張
  - あるクラスのサブクラスを無視
    - 各クラス宣言には新しいクラス `C` と新しいオーバーロードされた関数名 `x` が導入
  - 意味的には、`C` は関数 `x` をサポートするすべての型の集合を表す
  - 例)

      class α : Eq where eq : α → α → bool

  - `eq : τ → τ → bool` 関数を提供する全ての型 `τ` のクラス `Eq` を導入
  - クラス宣言は、モジュールインタフェースのようなもの
    - 宣言と実装を分離

---

  <!-- page 3 -->

### インスタンス宣言の目的


  - 特定の型、例えば `int` が `Eq` であることを "証明" するために、
    - 必要な関数 `eq` の "目撃者" が提供される必要がある
  - これはインスタンス宣言の目的
  - `int` を証明するためには、 `eq` を `eq int` でインスタンス化
  - 既存の `int → int → bool` の関数:

      inst int : Eq where eq = eq int

  - 一般的には、地面型だけでなく、型コンストラクタによってもクラスをインスタンス化できる

---

### 例

  - `list(τ)` 型が `τ` が提供する等価性を認めている型を表現したいと思うかも:

    inst list : (Eq)Eq where eq = ...

  - 宣言 `list : (Eq)Eq` は、クラス `Eq` の型をクラス `Eq` の型にマップするリストを表す。
  - リスト上の `eq` の実装は意図的に空白のまま:
    - パターンマッチングと私たちの言語での再帰がない
      - 必要なコードは不動点コンビネータで囲まれた条件のネストに

---

### 階層構造

  - クラスは階層構造で配置可能
  - 一般的なクラス宣言

    class α : C ≤ S where x : σ

  - すでに定義されているはずの `S` 内のすべてのクラスのサブクラスとして新しいクラス `C` を導入
  - 型 `α` は、`S` のすべてのクラスの交差点にある場合にのみ `C` にあり、型 `σ` の関数 `x` を提供します。

---

### 例)

  - 例えば、順序付けされた型のクラス `Ord`
    - `le` という追加の関数を提供する `Eq` のサブクラスとして定義:

    class α : Ord ≤ Eq where le : α → α → bool

  - サブクラスは単なる構文糖 (CHO92) 
  - 上の例では、 `Ord` は完全に別のクラスとして `Eq` を参照することなく定義可能

---

### 相違点

  - 唯一の相違点
    - サブクラスがなければ、
      - 判定 `τ : Ord` は、`τ : Eq ∧ τ : Ord` 、
      - すなわち `τ : {Eq, Ord}` に拡張されなければならないこと
  - しかし、 (NP93) のように、
    - サブクラスを直接削除するより、
    - サブクラスを直接処理する方が簡単
  - これを実証するため、またサブクラスが Haskell の一部である
    - Mini-Haskell にサブクラスを含めた


  <!-- page 4 -->

---

## 2.1 ソートと型

  - 導入の動機付けとして、ソートは有限集合クラス
  - この表現は、型推論の簡潔な処理のための重要な要素
  - それでも、意味的には、ソート `{C1, ..., Cn}` は `C1 ∩ ... ∩ Cn` と理解されるべき
  - したがって、 `{C}` と `C` は等価であり、空集合 `{}` はすべての型のソート/集合
  - `S1` がより特殊化されている場合、
    - すなわち、 `S2` よりも少ない型を表す場合、
    - `S1 ⪯ S2` と書く

---

  - クラスの部分順序 `≤` が与えられると、ソートされた準順序 `⪯` は次のように定義される

    S1 ⪯ S2 ⇔ ∀C2 ∈ S2 .∃C1 ∈ S1.C1 ≤ C2

  - `S1 ⊇ S2` は `S1 ⪯ S2` を意味
  - クラスについての些細でない順序の文脈
    - `{Ord} ⊉{Eq}` でも `{Ord} ⪯ {Eq}` のように逆の意味は成立しない
  - どのような2つの種類の `S1` と `S2` が、それらの和集合が `S1 ∪ S2` である最小値を持つことは容易に分かる

---

  - `⪯` は一般に擬似次数のみである(すなわち、非対称ではない)ため、等価性を生じる

    S1 ≈ S2 ⇔ S1 ⪯ S2 ∧ S2 ⪯ S1.

  - `{Ord}` や `{Ord, Eq}` のような `≈` を法とするソートは、同じ型の集合を表す
  - 等価クラス `[S]≈` を使うのは数学的にはより洗練されている
    - 実装に近づき、ソートを直接行うことを好む
  - それにもかかわらず、実装は等価クラス `[S]≈` から任意の代表を自由に選ぶことができる。
  - 例) 最小要素を持つものなど

---

  - Mini-Haskell の型:
    - 固定アリティの変数とコンストラクタに対する単純な項
    - `→` は別の型のコンストラクタであることに注意
      - `τ1 → τ2` は `→(τ1, τ2)` の略
  - 型スキームの自由変数のセット: `FV(σ)`
  - 型スキームの束縛変数: 型の特定のサブセットに対してのみ範囲をとる
  - `∀α:S.σ` はすべてのインスタンス `{α |→ τ}σ` を略して `τ : S` を正式に定義

---

  - 今後、構文オブジェクト `s1, ..., sn` のリストは `(sn)~` と省略
  - 例)
    - `∀(αn : Sn)~ .σ` は
    - `∀α1:S1, ..., αn:Sn.σ` と等価
  - 順序は、コンポーネントごとに
    - `Sn ⪯ Tn ⇔ ∀i. Si ⪯ Ti` のようにリストに拡張

---

## 2.2 宣言とプログラム

  - 図1に示すように、式は let 定義で拡張された λ 項
  - プログラムとは、一連の宣言の後に式が続くもの

---

  - Haskell 宣言
      - `class (C1 α, ..., Cm α) ⇒ Cα` に対応する Mini-Haskell クラス宣言
      - `class α : C ≤ {C1, ..., Cm}`、 `τ` は `σ` の本体
      - `σ` は、 `α` を除く自由変数を必ず含むことに留意
  - Haskell クラスは任意の数の関数を宣言可能
    - 逆方向への変換がより複雑
  - この特徴は明らかに必須ではない
    - 例) 1組の関数を1組の関数で表現しモデル化可能
  - 厳密に言えば、
    - クラス名とそのクラスで宣言された単一の関数との間には1対1の対応がある
    - クラス名を完全に削除できた

  <!-- page 5 -->

  - これは私たちをStefan Kaes(Kae88)の言葉に導きましたが
    - Haskellとの関係を不明瞭に

---

### Mini-Haskell のインスタンス宣言

  `inst t : (S1, ..., Sn)C where x = e`

  - `τi` が与えられているなら `t(τ1, ...τn)` がクラス `C` ソート `Si`
  - Haskell 宣言

    `inst(con) ⇒ C(t α1 ... αn) where x = e` に対応

      - `con` は `C' ∈ Si` の `C'αi` と全て `i = 1 ... n`

---

## 2.3 型の分類

  型推論に着手する前に、より簡単なソート推論の問題を解決しなければなりません。
  MLや他の多くの言語では、`e : τ` という判断があり、 `e` は `τ` 型であると表現しています。
  同様に、型 `τ : S` を用いて型を分類すると、型 `τ` はソート `S` であることが示されます。
  この判断は、

---

  - `τ` における型変数の種類。

    これはソートコンテキスト `Γ` に記録されます。これは、型変数から `Dom(Γ) = {α | Γα ≠ {}}` は有限です。
    ソートコンテキストは `[α1 : S1, ..., αn : Sn]` と書くことができます。

  - 型コンストラクタの "関数性" です。
  
    型コンストラクタの振る舞いは、インスタンス宣言から直接持ち上げられる `t : ((Sn)~)C` という形式の宣言によって指定されます。
    続編では、`∆` は常にそのような宣言のセットを示します。

  - サブクラスが `≤` を並べ替えます。


  `∆,≤` の組は `(型)シグニチャ` と呼ばれ、`Σ` で示されます。すなわち、`∆,≤` および `Σ` は互換的に使用されます。

---

  `Γ` と `Σ` が与えられれば、 `Σ,Γ ⊢ τ : S` という判断を使って `τ` 型の類型を推論することができます。
  規則を図2に示します。
  `{C}` とクラス `C` は同等であることに注意してください。

---

  - `⪯` という順序は、ソートからコンテキストに容易に拡張される

      Γ ⪯ Γ' ⇔ ∀α. Γα ⪯ Γ' α

  - `Γ'` は `Γ` よりも一般的
  - この順序付けに関して `⊢` が単調であることを示すことは容易:
    - `Σ,Γ' ⊢ τ : S` は `Σ,Γ ⊢ τ : S` を意味
  - 続編では、この事実はしばしば暗黙的に使用

---

  - 全ての2つのソートが最小値を有するので、全ての型 `τ` は、最も特有のソート `S` を有する
  - すなわち、 `Σ, Γ ⊢ τ : S` であり、 `Σ, Γ ⊢ τ : S'` ならば `S ⪯ S'`
  - この最も具体的なソートの計算は簡単で、私たちの目的には関係しないので、ここでは心配しない

  - Mini-Haskell 型のソート推論を見て、私たちは Mini-Haskell プログラムの主目的、型推論、型再構築の準備

