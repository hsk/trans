/*
# System O

## 例

System O で表せる例を２つほどまず見てみましょう。

### 例1

  以下のプログラムは、等価関数 `(==)` のインスタンス宣言を示しています。

    inst (==) : Int -> Int -> Bool =
      primEqInt
    in
    let listEq : ∀α.((==) : a->a->Bool => [a]->[a]->Bool) =
      λ[].λ[].True |
      λ(x:xs).λ(y:ys). x == y && listEq xs ys
    in
    inst (==) : a->a->Bool => [a]->[a]->Bool =
      listEq
    in
    1 == 1

  インスタンス宣言は再帰的ではないので、2番目のインスタンス宣言で `(==)` を直接使用することはできません。
  再帰的なインスタンス宣言に対するシステムOの拡張は価値がありますが、ここでは簡略化のために省略されています。

## 2 型システム

  図1は、型とプログラムの構文です。 型だけ見てみましょう。

    α ∈ A                                                                    型変数
    D ∈ D                                                                    データ型コンストラクタ
    τ = α | τ -> τ' | D τ1 ... τn        ここで n は D のアリティ                  型
    T ∈ T = D ∪ (->)                                                        型コンストラクタ
    πα= o1 : α -> τ1, ..., on : α -> τn  (n ≧ 0, with o1, ..., on distinct)  α上の制約
    σ = τ | ∀α.πα => σ                                                       型スキーム
    Γ = x1 : σ1, ..., xn : σn            (n ≧ 0)                             型環境

  図1: システムOの抽象構文(型)
  
  - `α`は型変数を表します。
  - データ型 `D` は、 データ型コンストラクタ `D` から構築されます。
  便宜上、データ型 `D τ1...τn` のすべての値コンストラクタとセレクタが事前に定義されており、いくつかの固定初期型束縛は `Γ0` であると仮定します。
  ユーザ定義の型宣言は、与えられたプログラムで実際に宣言されているすべてのセレクタとコンストラクタを `Γ0` に含めて表します。
  - 型 `τ` は、型変数`α`、関数型 `τ -> τ'`、またはデータ型 `D τ1 ... τn` です。
    `T` はデータ型コンストラクタと関数型コンストラクタ `（->）` からなり、 `（->） τ τ` は `τ -> τ` の同じ意味です。
  - 制約 `πα` は、 指定された型でオーバーロードされた識別子が定義されることを要求することによって、型スキームのインスタンス型を制限します。
  オーバーロードされた変数 `o` は、制約内に一度しか現れません。
  - 型スキーム `σ` は、型 `τ` といくつかの型変数 `α` の量化子からなります。
  Hindley/Milner 型スキーム `∀α.σ` は `∀α.（）=>σ` の構文糖とみなされます。
  Hindley/Milner 多相型とは異なり、量化変数 `α` には束縛のセット（おそらく空の）である `πα` という制約が付いています。
  - `Γ` は言わずと知れた型環境です。


    u ∈ U                                  一意の変数
    o ∈ O                                  オーバーロードされた変数
    k ∈ K = ∪{K_D | D ∈ D}                コンストラクタ
    x = u | o | k                           変数
    e = x | λu.e | e e' | let u = e in e'   項
    p = e | inst o : στ = e in p            プログラム

  図1: システムOの抽象構文(プログラム)

  - ユニークな変数は `U` と `u`で表し、 1回だけプログラムで束縛されます。
  - オーバーロードされた変数は `O` と `o` で表します。
  - データコンストラクタは `K` と `k` で表します。
    `K_D` は、いくつかの型 `τ1,...,τn` に対して `Dτ1,...,τn` の値を生成するすべての値コンストラクタの集合です。
    `K_⫫ = ∅` であるボトムデータ型 `⫫ ∈ D` が存在します。
  - `x` は変数全体を表し、ユニーク変数、オーバーロードされた変数、またはデータコンストラクタを表します。
  - 項 `e` の構文は、 [Mil78] の Exp 言語と同じでラムダ計算に let を加えたものです。
  - プログラム `p` は、 インスタンス宣言の列と項 `e` で構成されています。
    インスタンス宣言（`inst o:στ = e in p`）は、型コンストラクタ `T` から構築されたすべての引数に `e` によって与えられた関数で識別子 `o` をオーバーロードします。


--------

#### 型付け規則

  図2は、システムOの型付け規則を定義しています。

    Γ ⊢ x : σ (x : σ ∈ Γ)              (TAUT)

    Γ, πα ⊢ e : σ     (α ∉ tv(Γ))
    ------------------------------------ (∀I)
    Γ ⊢ e : ∀α.πα => σ

    Γ, u : τ ⊢ e : τ'
    ------------------------------------ (->I)
    Γ ⊢ λu.e : τ -> τ'

    Γ ⊢ e : σ     Γ, u : σ ⊢ e' : τ
    ------------------------------------ (LET)
    Γ ⊢ let u = e in e' : τ

    Γ ⊢ x1 : σ1 ... Γ ⊢ xn : σn
    ------------------------------------ (SET)
    Γ ⊢ x1 : σ1, ..., xn : σn

    Γ ⊢ e : ∀α.πα => σ   Γ ⊢ [τ/α] πα
    ------------------------------------ (∀E)
    Γ ⊢ e : [τ/α] σ

    Γ ⊢ e : τ' -> τ      Γ ⊢ e' : τ'
    ------------------------------------ (->E)
    Γ ⊢ e e' : τ

    (o : σ_{T'} ∈ Γ => T ≠ T')
    Γ ⊢ e : στ    Γ, o : στ ⊢ p : σ'
    ------------------------------------ (INST)
    Γ ⊢ inst o : στ = e in p : σ'

  図2: システムOの型付け規則

  型システムは、(∀I)と(∀E)の2つの変更があり、(INST)が追加されています。
  
  1. 規則(∀I)において、導入された束縛変数 `α` に対する制約 `πα` は、仮説と型式の間で交換されます。
    規則(∀E)は、除去された制約のインスタンス化を前提としています。
    制約は、規則(SET)を使用して導出されます。
    これは規則(∀I)と(∀E)を規則(->I)と(->E)と対称であることに注意してください。

  2. インスタンス宣言のための追加規則(INST)があります。
    オーバーロードされた変数 `o` が明示的な型スキーム `στ` を有し、変数 `o` の各インスタンス化において型コンストラクタ `T` が異なることを除いて、ルールは(LET)に類似しています。


  最も外側の引数型のコンストラクタとして `T` を持つ閉じた型のスキームに対して `στ` の範囲を与えます:

    στ  = T α1 ... αn -> τ    (tv(τ) ⊆ {α1, ..., αn})
        | ∀α.πα => στ'       (tv(πα) ⊆ tv(στ')) .

  規則(INST)における `στ` の明示的宣言は、主要型が常に存在することを保証するために必要です。
  それがなければ、次のようなインスタンス宣言を宣言するかもしれません:

    inst o = λx.x in p

  ここで `o` がオーバーロードされている型コンストラクタを一意に決定することはできません。

  型スキーム `στ` に対する構文上の制限は、3つの性質を強制します:
  第1に、オーバーロードされたインスタンスは、指定された型コンストラクタのすべての引数に対して一様に働く必要があります。
  第2に、引数型は結果型を一意に決定しなければなりません。
  最後に、すべての制約が引数のコンポーネント型に適用される必要があります。
  制限は、型再構築アルゴリズムの終了を確実にするために必要です。
  例は6章で与えられます。

  型スキーム `στ` の構文上の制限は、制約 `πα` のオーバーロード変数がペアをつくれなければならない理由も説明します。
  オーバーロードされた関数の単相の引数は、その関数のインスタンス型を完全に決定します。
  したがって、任意の引数型 `τ` およびオーバーロードされた変数 `o` の場合、 `τ` 型の引数に `o` というインスタンス型が1つしか存在しないことがあります。
  このルールを型制約の制約の形で具体化することで、可能な限り早くそれを実施します。



ーーーーーーーーーー



## 6 型再構築

  図6と図7は、システムOの型再構築と単一化アルゴリズムを示しています。
  Milner のアルゴリズムW [<a name="rMil78"></a>[Mil78](#Mil78)] と比較すると、2つの拡張があります。

  - 1. 単一化アルゴリズムにおいて型変数を束縛する場合が拡張されています。
    型変数 `α` を型 `τ` にバインドするには、 `Γα` の制約を満たす必要があります。
    関数 `mkinst` は、型 `τ` が制約 `Γα` を保証することを保証します。

  - 2. 関数 `tp` は、 宣言 `inst o : στ = e in p` の分岐で拡張されます。
     この場合、オーバーロード項 `e` の推論された型 `στ'` は、
     与えられた型 `στ` より一般的ではないことをチェックしなければなりません。

  以下の略語を使用します:

    Γα = {o : α -> τ | o : α -> τ ∈ Γ}
    ΓA = ∪_{α ∈ A} Γα

  ここで `A` は型変数の集合です。

    unify : (τ,τ) -> (Γ,S) -> (Γ,S)
    unify (τ1,τ2) (Γ,S) = case (S τ1,S τ2) of
      (α,α) =>
        (Γ,S)
      (α,τ),(τ,α) where α ∉ tv(τ) =>
        foldr mkinst (Γ \ Γα,[τ / α] o S) Γα
      (T τ1s,T τ2s) =>
        foldr unify (Γ,S) (zip(τ1s,τ2s))

    mkinst : (o : α -> τ) -> (Γ,S) -> (Γ,S)
    mkinst (o : α -> τ) (Γ,S) = case S α of
      β =>
        if ∃o : β -> τ' ∈ Γ
        then unify (τ,τ') (Γ,S)
        else (Γ ∪ {o : β -> [β / α] τ},S)
      T τs =>
        case {newinst(στ,Γ,S) | o : στ ∈ Γ} of
          {(τ1,Γ1,S1)} => unify (α -> τ,τ1) (Γ1,S1)

  図6: 制約付き単一化アルゴリズム


  型付け問題 `(p,Γ,S)` の型付け解決は3つ組 `(σ,Γ',S')` です。ここで `(Γ',S') ≼ (Γ,S)` かつ `S'Γ' ⊢  p : S'σ` です。

  他のすべての型付け解決 `(σ'',Γ'',S'')` は `(Γ'',S'') ≼ (Γ',S')` かつ `S'' σ'' ≼S''Γ'' S'' σ` が成り立つ場合、型付け解決 `(σ,Γ',S')` が最も一般的です。

## 7 結論

  我々は、 Hindley/Milner システムのやや控えめな拡張が、限定されたF境界型多相型を持つ多重定義と多相型レコードの両方をサポートするのに十分であることを示しました。
  得られたシステムは、 Hindley/Milner システムに完全に類似した型の健全性および主要型の特性を備えた、ML型の伝統にしっかりと留まります。

    newinst     : (σ,Γ,S)  ->  (τ,Γ,S)
    newinst(∀α.πα => σ,Γ,S)
                = let β a new type variable
                  in  newinst
                  ([β/α] σ,Γ ∪ [β/α] πα,S)
    newinst(τ,Γ,S)
                = (τ,Γ,S)

    skolemize   : (σ,Γ,S) -> (τ,Γ,S)
    skolemize (∀α.πα => σ,Γ,S)
                = let T a new 0-ary type constructor
                  in  skolemize
                      ([T/α] σ,Γ ∪ [T/α] πα,S)
    skolemize (τ,Γ,S)
                = (τ,Γ,S)

    gen         : (τ,Γ,S) -> (σ,Γ,S)
    gen (σ,Γ,S) = if ∃ α.α ∈ tv(Sσ) \ tv(S (Γ\Γα))
                  then gen (∀α.Γα => σ,Γ\Γα,S)
                  else (σ,Γ,S)

    tp          : (p,Γ,S) -> (τ,Γ,S)
    tp (u,Γ,S)  = if u : σ ∈ Γ
                  then newinst (σ,Γ,S)

    tp (o,Γ,S)  = newinst (∀β ∀α: (o : α -> β) => α -> β,Γ,S)

    tp (λu.e,Γ,S)
                = let α a new type variable
                    (τ,Γ1,S1) = tp (e, Γ ∪ {u : α},S)
                  in (α -> τ,Γ1,S1)

    tp (e e',Γ,S)
                = let (τ1,Γ1,S1) = tp (e,Γ,S)
                      (τ2,Γ2,S2) = tp (e,Γ1,S1)
                      α a new type variable
                      (Γ3,S3) = unify (τ1,τ2 -> α) (Γ2,S2)
                  in (α,Γ3,S3)

    tp (let u = e in e',Γ,S)
                = let (σ,Γ1,S1) = gen (tp (e,Γ,S))
                  in tp (e,Γ1 ∪ {u : σ},S1)

    tp (inst o : στ = e in p,Γ,S)
                = let (στ',Γ1,S1) = gen (tp (e,Γ,S))
                      (τ2,Γ2,S2) = skolemize (στ,Γ1,S1)
                      (τ3,Γ3,S3) = newinst (στ',Γ2,S2)
                  in if ∀o : στ' ∈ Γ . T ≠ T' ∧
                        unify (τ2,τ3)(Γ3,S3) defined then
                          tp (p, Γ1 ∪ {o : στ},S1)

  図7: システムOの型再構築アルゴリズム

*/
% 単一化
unify(T1,T2, (Γ,S), R) :- subst(S,T1,T1_), subst(S,T2,T2_), unify1(T1_,T2_).
unify1(A,A,(Γ,S),(Γ,S)).
unify1((A,T),(T,A),(Γ,S),R) :- tv(T,TV), \+ member(A,TV), foldr(mkinst, (Γ \ Γα,[τ / α] o S), Γα, R).
unify1(t(T1S),t(T2S),(Γ,S),R) :- foldr(unify,(Γ,S),zip(T1S,T2S),R).

% インスタンスを作成
mkinst : (o : α -> τ) -> (Γ,S) -> (Γ,S)
mkinst (o : α -> τ) (Γ,S) = case S α of
    β =>
        if ∃o : β -> τ' ∈ Γ
        then unify (τ,τ') (Γ,S)
        else (Γ ∪ {o : β -> [β / α] τ},S)
    T τs =>
        case {newinst(στ,Γ,S) | o : στ ∈ Γ} of
        {(τ1,Γ1,S1)} => unify (α -> τ,τ1) (Γ1,S1)

% インスタンスを新しく作る
newinst     : (σ,Γ,S)  ->  (τ,Γ,S)
newinst((A#PiA => Sc,Γ,S),R) :-
            newtvar(B),
            subst(A,B,Sc,Sc_),
            subst(A,B,PiA,PiA_),
            union(Γ,PiA_,Γ_)
            newinst((SC_,Γ_,S),R).
newinst((T,Γ,S),(T,Γ,S)).

% スコレマイズ
skolemize(((A#PiA => Sc),Γ,S), R) :-
            new0ary_type_constructor(T),
            subst(A,B,Sc,Sc_),
            subst(A,B,PiA,PiA_),
            union(Γ,PiA_,Γ_)
            skolemize((SC_,Γ_,S),R).
skolemize((T,Γ,S), (T,Γ,S)).

% 一般化
gen((Sc,Γ,S),R) :- member(A, tv(S Sc) \ tv(S (Γ\Γα))), gen((A#Γα => Sc,Γ\Γα,S),R).
gen((Sc,Γ,S),(Sc,Γ,S)).

% 型推論

% 変数
tp((U,Γ,S), R) :- member(u(U),Γ)), member(U : Sc, Γ), newinst((Sc,Γ,S), R).
% オーバーロードされた変数
tp((O,Γ,S), R) :- member(o(O),Γ)), newinst((b#(a#((O : (a -> b)) => (a -> b))),Γ,S), R).
% 関数
tp((fun(U->E),Γ,S),((A -> T),Γ1,S1)) :- newtvar(A),
                union(Γ,[U : u(A)],Γ_),
                tp((E, Γ_, S),(T,Γ1,S1)).
% 関数適用
tp((E $ E_,Γ,S),(A,Γ3,S3)) :-
                tp((E,Γ,S),(T1,Γ1,S1)),
                tp((E,Γ1,S1),(T2,Γ2,S2)),
                newtvar(A),
                unify((T1,(T2 -> A)),(Γ2,S2),(Γ3,S3)).
% let
tp((let(U = E ; E_),Γ,S), R) :-
                tp((E,Γ,S),R1),
                gen(R1,(Sc,Γ1,S1)),
                union(Γ1,[U : u(Sc)],Γ2),
                tp((E,Γ2,S1),R).

%    στ  = T α1 ... αn -> τ    (tv(τ) ⊆ {α1, ..., αn})
%        | ∀α.πα => στ'       (tv(πα) ⊆ tv(στ')) .
getTC(t(TC,(As->T)), TC).
getTC(A#PiA=>ScT_, TC) :- getTC(ScT_, TC).

% inst
tp((inst(O : ScTC = E ; P),Γ,S),R) :-
                tp((E,Γ,S),R1),
                gen(R1,(ScTC_,Γ1,S1)),
                skolemize((ScTC,Γ1,S1),(T2,Γ2,S2)),
                newinst((ScTC_,Γ2,S2),(T3,Γ3,S3)),
                getTC(ScTC_,TC_), getTC(ScTC,TC), TC \= TC_,
                member(O : o(ScT_), Γ), % . T ≠ T' ∧
                unify((T2,T3),(Γ3,S3),_),
                union(Γ1,[O : o(ScT)],Γ2),
                tp((P, Γ2,S1), R).

