
e の代わり ᘓ

# 型クラスの型推論

    Type classes        C
    Sorts               S  = {C1, ..., Cn}
    Type variables      α
    Type constructors   t
    Types               τ  = α | t(τ1, ..., τn)
    Type schemes        σ  = τ | ∀α:S.σ
    Identifiers         x
    Expressions         e  = x
                           | (e0 e1)
                           | λx.e
                           | let x = e0 in e1
    Declarations        d  = class α : C ≤ S where x : σ
                           | inst t : (S1, ..., Sn)C where x = e
    Programs            p  = d; p | e

  図1 Mini-Haskell 型と式の構文

  ソートが追加され、classとinstの構文があります。

Σ = ∆,≤ でシグニチャとよぶ

    [i = 1 ... n]
      :
      :
    Σ,Γ ⊢ τ : Ci
    -----------------------------
    Σ,Γ ⊢ τ : {C1, ..., Cn}

    Σ,Γ ⊢ τ : {C1, ..., Cn}
    -----------------------------  i = 1 ... n
    Σ,Γ ⊢ τ : Ci

    Γ(α) = S
    -------------
    Σ,Γ ⊢ α : S

                        [i = 1 ... n]
                              :
                              :
    t : ((Sn)~)C ∈ ∆     Σ,Γ ⊢ τi : Si
    --------------------------------------
    Σ,Γ ⊢ t((τn)~) : C

    Σ,Γ ⊢ τ : C1   C1 ≤ C2
    ---------------------------
    Σ,Γ ⊢ τ : C2

  図2 判断 Σ, Γ ⊢ τ : S

  これは、ソートに対する判断式です。ソートはクラスの集合で、クラス単体で扱う必要もあるのでクラス単体で扱う式もあります。
  {C1,...,Cn} は C1 ∪ ... ∪ Cn の略なので {C} は C であるので Cに対する規則も Σ, Γ ⊢ τ : S の判断でもあります。
  名前ついていないので分かりづらいものがありますが、1,3個目がソート ２,4,5個目がクラスの判断式です。
  
          ∆,(≤ ∪{(C, D) | D ∈ S})*,Γ,E[x:∀α:C.σ] ⊢ p : σ'
    CLASS ----------------------------------------------------------
          ∆,≤,Γ,E ⊢ (class α : C ≤ S where x : σ; p) : σ'

          ∆ ∪ {t : ((Sn)~)C},≤,Γ,E ⊢ p : σ'
          E(x) = ∀α:C.σ
          Γ[(αn : Sn)~],∆,≤,E ⊢ e : {α |→ t((αn)~)}σ
    INST  -----------------------------------------------------
          ∆,≤,Γ,E ⊢ (inst t : ((Sn)~)C where x = e; p) : σ'

  図3 判断 ∆,≤,Γ,E ⊢ p : σ

  図３は宣言に対する判断式で、CLASS は≤とEの環境に変更を加え、INSTは∆に変更を加えています。
  INSTのeに対する判断式の環境の入れ替えが気持ち悪いのですがいいのか確認したいところです。

    ASM --------------------
        Σ,Γ,E ⊢ x : E(x)

        Σ,Γ,E ⊢ e : ∀α:S.σ   Σ,Γ ⊢ τ : S
    ∀E -----------------------------------
        Σ,Γ,E ⊢ e : {α |→ τ}σ

        Σ,Γ[α:S],E ⊢ e : σ    α ∈ FV(σ) − FV(E)
    ∀I ----------------------------------------
        Σ,Γ,E ⊢ e : ∀α:S.σ

        Σ,Γ,E ⊢ e1 : τ2 → τ1    Σ,Γ,E ⊢ e2 : τ2
    APP -----------------------------------------
        Σ,Γ,E ⊢ (e1 e2) : τ1

        Σ,Γ,E[x:τ1] ⊢ e : τ2
    ABS ---------------------------
        Σ,Γ,E ⊢ λx.e : τ1 → τ2

        Σ,Γ,E ⊢ e1 : σ1    Σ,Γ,E[x:σ1] ⊢ e2 : σ2
    LET ------------------------------------------
        Σ,Γ,E ⊢ let x = e1 in e2 : σ2

  図4 判断 Σ,Γ,E ⊢ e : σ

  図4は HMシステムに若干の変更を加えて型クラスに対応したものです。
  ∀E,∀Iの規則には左再帰が含まれているのでプログラムに直接落とすことが出来ません。

         Σ,Γ ⊢ E(x) ⪰ τ
    ASM' ------------------
         Σ,Γ,E ▷ x : τ

         Σ,Γ[(αk : Sk)~],E ▷ e1 : τ1
         Σ,Γ,E[x:∀(αk :Sk)~ .τ1] ▷ e2 : τ2
    LET' --------------------------------------
         Σ,Γ,E ▷ let x = e1 in e2 : τ2
         where {(αk)~} = FV(τ1) − FV(E)

  図5 判断 Σ,Γ,E ▷ e : σ

  図5は図4の判断式のうちASM,LETに変更を加えて∀E,∀Iの規則を盛り込み、構文主導なものに変更した規則です。
  ２つの式しか書いてありませんが、APP',ABS' はAPP,ABSの⊢を▷に書き換えたものになります。

    W(V,Γ,E,e) = case e of
                     x ⇒ let ∀(αn : Sn)~ .τ = E(x)
                                          βi ∉ V [i = 1 ... n]
                          in (V' ∪ {(βn)~}, Γ[(βn :Sn)~], {}, {(αn |→ βn)~}τ)
                  λx.e ⇒ let            α ∉ V
                              (V',Γ',θ',τ) = W(V ∪ {α}, Γ, E[x:α], e)
                          in (V',Γ',θ',α → τ)
               (e1 e2) ⇒ let (V1,Γ1,θ1,τ1) = W(V,Γ,E,e1)
                              (V2,Γ2,θ2,τ2) = W(V1,Γ1,θ1 E,e2)
                                          α ∉ V2
                                    (Γ',θ') = unify(Γ2, θ2θ1τ1 = θ2τ2 → α)
                          in (V2 ∪ {α},Γ',θ'θ2θ1,α)

      let x = e1 in e2 ⇒ let (V1,Γ1,θ1,τ1) = W(V, Γ, E, e1)
                                    {(αn)~} = FV(θ1 τ1) − FV(θ1 E)
                              (V2,Γ2,θ2,τ2) = W(V1, Γ1 \ {(αn)~},
                                                (θ1 E)[x : ∀(αn :Γ1 αn)~ .θ1 τ1],e2)
                          in (V2,Γ2,θ2θ1,τ2)

  図6 アルゴリズム W

  図6 は単一化のアルゴリズムを示したものです。

    I(V,Γ,θ,E,e) = case e of
      x    ⇒ let ∀(αn : Sn)~ .τ  =  E(x)
                              βi  ∉  V [i = 1 ... n]
              in (V ∪ {(βn)~},Γ[(βn : Sn)~],θ,{(αn |→ βn)~}τ)
      λx.e ⇒ let        α ∉ V
              (V',Γ',θ',τ) = I(V ∪ {α},Γ,θ,E[x:α],e)
              in (V',Γ',θ',α → τ)
      (e1 e2) ⇒ let (V1,Γ1,θ1,τ1) = I(V,Γ,θ,E,e1)
                     (V2,Γ2,θ2,τ2) = I(V1,Γ1,θ1,E,e2)
                                 α ∉ V2
                           (Γ',θ') = unify(Γ2,θ2τ1 = θ2τ2 → α)
                in (V2 ∪ {α},Γ',θ'θ2,α)
      let x = e1 in e2 ⇒ let (V1,Γ1,θ1,τ1) = I(Γ,θ,E,e1)
                                    {(αn)~} = FV(θ1τ1) − FV(θ1E)
                          in I(V1,Γ1 \ {(αn)~},θ1,E[x : ∀(αn :Γ1 αn)~ .θ1τ1],e2)

  図7. アルゴリズムI

  図7 は問題を何か解決するものなのかも知れませんがよくわかっていません。


  特に、よくわからないところがアルゴリズムIです。アルゴリズムIの説明は短かったのもあるので集中的に読んでみましょう。
