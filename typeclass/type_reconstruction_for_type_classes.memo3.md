## アジェンダ

  - 要約
  - 1 はじめに
  - 2 Mini-Haskell
  - **3 型推論システム**
      - 3.1 構文指向型推論
  - ４ ソート制約付き単一化
  - 5 アルゴリズムW
  - 6 アルゴリズムI

---

## 3 型推論システム

  - このセクションでは、 Mini-Haskell の2つの型推論システムを紹介
      - Mini-Haskell プログラムと式の型を定義する一連の推論規則から始める

  - 次に、より限定された構文指向の規則のセット
      - これは型推論アルゴリズムの基礎

  <!-- page 6 -->

---

#### 図2 判断 Σ, Γ ⊢ τ : S (1)

    Σ,Γ ⊢ τ : Ci [i = 1 ... n]
    -----------------------------
    Σ,Γ ⊢ τ : {C1, ..., Cn}

    Σ,Γ ⊢ τ : {C1, ..., Cn}
    ----------------------------- i = 1 ... n
    Σ,Γ ⊢ τ : Ci

    Γ(α) = S
    -------------
    Σ,Γ ⊢ α : S

<!-- -->

    t : ((Sn)~)C ∈ ∆　　Σ,Γ ⊢ τi : Si [i = 1 ... n]
    --------------------------------------
    Σ,Γ ⊢ t((τn)~) : C

    Σ,Γ ⊢ τ : C1　　C1 ≤ C2
    ---------------------------
    Σ,Γ ⊢ τ : C2


---

### 図3 判断 ∆,≤,Γ,E ⊢ p : σ
  
          ∆,(≤ ∪{(C, D) | D ∈ S})*,Γ,E[x:∀α:C.σ] ⊢ p : σ'
    CLASS ----------------------------------------------------------
          ∆,≤,Γ,E ⊢ (class α : C ≤ S where x : σ; p) : σ'

          ∆ ∪ {t : ((Sn)~)C},≤,Γ,E ⊢ p : σ'
          E(x) = ∀α:C.σ
          Γ[(αn : Sn)~],∆,≤,E ⊢ e : {α |→ t((αn)~)}σ
    INST  -----------------------------------------------------
          ∆,≤,Γ,E ⊢ (inst t : ((Sn)~)C where x = e; p) : σ'

---

#### 環境 E

  - 環境は識別子から型への有限のマッピング
      - `E = [x1 : σ1, ..., xn : σn]`
      - 通常MLのような言語の型推論と同様
  - `E` のドメイン: `Dom(E) = {x1, ..., xn}`
  - `E[x:σ]` :
      - `x` を `σ` にマッピング
      - 他のすべての `xi` を `σi` にマッピングする新しいマップ
  - `E` の自由型変数 :
      - `FV(E) = FV(E(x1)) ∪ ... ∪ FV(E(x n))`
  - `V` が型変数の集合で `V` にない変数に対するΓの制限は
      - `Γ \ V = [α:Γα | α ∈ Dom(Γ) − V]`

---

#### 置換 θ

  - **置換** は、型変数から型への有限のマッピング
      - `{α1 |→ τ1, ...}`
  - 置換は `θ` で示され、`δ;{}` は空の置換

  - `Dom(θ) = {α | θα ≠ α}`、
  - `Cod(θ) = ∪_{α∈Dom(θ)} FV(θ(α))`、
  - `FV(θ) = Dom(θ) ∪ Cod(θ)` を定義

---

#### 判断

  - 図3と図4で定義されている2つの判断がある:

      - `∆,≤,Γ,E ⊢ p : σ` はプログラム `p`
      - `∆,≤,Γ,E ⊢ e : σ` は式 `e`
      - プログラム `p` と式 `e` はどちらも `∆,≤,Γ,E` の文脈で型 `σ`

  - 逆方向に適用されたとき、
      - `∆,≤,Γ,E ⊢ p : σ` の規則は単に宣言をトラバース
      - `∆,≤,E` を構築するだけ
      - class 宣言は `E` と `≤` を拡張
      - inst 宣言は `∆` を拡張

  <!-- page 7 -->

---

#### クラス宣言とインスタンス宣言

  - 規則 CLASS の推移閉包 `≤` の `(≤ ∪ {(C, D) | D ∈ S})*` は新しいサブクラス関係を取る必要があることに注意
  - 規則 INST は、 `e` が `{α |→ t((αn)~)}σ` 型であることを確認して `x` のインスタンス化を型チェック
  - `σ` はジェネリック型 `x` と `{α |→ t((αn)~)}` は新しい型変数 `(αn)~` の型置換

---

#### 宣言シーケンス

  TODO>>>

  - 定式化しない宣言シーケンスには、次の2つの文脈条件:

  - 1. `class α : C ≤ S` の前に `S` の各スーパークラスの宣言を置く
      - `class α : C;`
  - 2. `(Sn)〜)C`は` C`の各スーパークラス `D 'の前に`(Sn)~D``が宣言 `inst t:((Tn)〜) 〜⪯(Tn)〜 `であるが、別の宣言` inst t(...)C 'ではない

---

  - これらの条件は、Haskell (HJW92,4.3.2) で実際に採用されている制限を Mini-Haskell に変換した結果です。
  - それらを実施するのは簡単なので、このホワイト論文では無視されています。
  - それにもかかわらず、すべての宣言、したがって `∆` および `≤` が上記の条件を満たしていると続編で仮定します。

---

#### 図4 判断 Σ,Γ,E ⊢ e : σ

    ASM --------------------
        Σ,Γ,E ⊢ x : E(x)

        Σ,Γ,E ⊢ e : ∀α:S.σ   Σ,Γ ⊢ τ : S
    ∀E -----------------------------------
        Σ,Γ,E ⊢ e : {α |→ τ }σ

        Σ,Γ[α:S],E ⊢ e : σ    α ∈ FV(σ) − FV(E)
    ∀I ----------------------------------------
        Σ,Γ,E ⊢ e : ∀α:S.σ

  <!-- -->

        Σ,Γ,E ⊢ e1 : τ2 → τ1    Σ,Γ,E ⊢ e2 : τ2
    APP -----------------------------------------
        Σ,Γ,E ⊢ (e1 e2) : τ1

        Σ,Γ,E[x:τ1] ⊢ e : τ2
    ABS ---------------------------
        Σ,Γ,E ⊢ λx.e : τ1 → τ2

        Σ,Γ,E ⊢ e1 : σ1    Σ,Γ,E[x:σ1] ⊢ e2 : σ2
    LET ------------------------------------------
        Σ,Γ,E ⊢ let x = e1 in e2 : σ2


---

  - `Σ,Γ,E ⊢ e : σ` の規則は、`Σ,Γ` を介して表現される並べ替えの概念と型スキームの制限付き定量化によって、Damas and Milner(DM82)の古典的なシステムを拡張します。
  - `∀I` の中の `α ∈ FV(σ)` という仮定は本当に本質的ではありません(健全性のために)。
  - その実用的な意義については第8章で論じます。
  - CLASS と INST の規則とは対照的に、 `Σ` は固定されたままです。

---

## アジェンダ

  - 要約
  - 1 はじめに
  - 2 Mini-Haskell
  - 3 型推論システム
      - **3.1 構文指向型推論**
  - ４ ソート制約付き単一化
  - 5 アルゴリズムW
  - 6 アルゴリズムI

---

## 3.1 構文指向型推論

  - 型再構成アルゴリズムへの次のステップは、より制限された規則セットです。
  - これらの規則の適用は、その型が計算されるべき式の構文によって決定されます。

  <!-- page 8 -->

  - 構文指向システムを区別するために、 `⊢` の代わりに `？` を使い、その規則の名前をプライムします。 `ASM` 。

---

#### 定義 3.1

  - `Σ` と `Γ` の下では、 `σ = ∀(αm :Sm)~ .τ` の一般的なインスタンスであり、`σ' = ∀(αn' :Sn')~ .τ'` となるような置換 `θ` が存在する場合、

    θτ                   = τ ' ,
    Dom(θ)               ⊆ {α m },
    Σ, Γ[α n ' :S n ' ]  ⊢ θα i : S i  [i = 1 ... m],
    {(α n ')~} ∩ FV(σ)   = {}.

  - このような型の関係を使って、最も一般的な、または主要な型の式を定義できるようになりましました。
  - `FV(E) = {}` ならば `E` は閉じます。

---

#### 定義 3.2

  - もしも `Σ,[],E ⊢ e : σ` かつ `Σ,[],E ⊢ e : σ'` を用いたすべての `σ` に対して、型スキーム `σ'` は、 `σ` の一般的なインスタンス、すなわち、 `Σ,[] ⊢ σ ⪰ σ'` でなければならず、`Σ` および閉環境 `E` に関して、型スキーム `σ` は、式 `e` の主要型です。
  - 構文指向システムでは、規則 APP と ABS は変更されず、図5に示すように、数量子規則は ASM と LET に組み込まれます。
  - 2つのシステム間には直接の対応があります。構文指向の導出は健全です

---

#### 図5. 判断 Σ,Γ,E ▷ e : σ

         Σ,Γ ⊢ E(x) ⪰ τ
    ASM' ------------------
         Σ,Γ,E ▷ x : τ

         Σ,Γ[(αk : Sk)~],E ▷ e1 : τ1
         Σ,Γ,E[x:∀(αk :Sk)~ .τ1] ▷ e2 : τ2
    LET' --------------------------------------
         Σ,Γ,E ▷ let x = e1 in e2 : τ2
         where {(αk)~} = FV(τ1) − FV(E)

---

#### 定理 3.3

  - `Σ,Γ,E ▷ e : τ` ならば `Σ,Γ,E ⊢ e : τ` です。

  - そしてある意味では元のシステムに関して完全です:

---

#### 定理 3.4

  - `Σ,Γ,E ⊢ e : ∀α n : Sn .τ` ならば `Σ,Γ[αn : Sn], E ▷ e : τ` です.


  

  - **証明** 最後の定理の証明は、例えば (CDDK86, App. A.1) のように標準的です。

---

  - 定理3.4は、`⊢:` がプライムされた規則を後方に適用することによって `⊢:` が `▷` とどのように異なるのかを明確にし、型変数のソート制約は `e` の型式スキームではなく `Γ` にのみ格納されます。
  - たとえば、 `LET` 規則は `Γ` を明示的に拡張します。
  - `ASM` 規則で使用される `⪰` 演算は、 `Γ` で拘束されなければならない新しい型変数を導入するかもしれません。

  <!-- page 9 -->

  - 構文指向システムは、すでに非常に操作上の味があります。
  - 型推論システムからアルゴリズムに移行するためには、もう一つの要素、すなわち単一化が必要です。
