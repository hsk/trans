# 型クラスの型再構築 1

  トビアス・ニプコウ 2、 クリスチャン・プレファー 3

  TU ミュンヘン 4

## 要約

  関数型プログラミング言語Haskellのような型クラスを持つシステムの型推論問題を研究します。
  型クラスは、多重定義を持つML形式の多相型の拡張です。
  Milnerの多相型に関する研究は、タイピング判断において型変数を制約する別のコンテキストを導入することによって一般化されています。
  これは、簡単な型推論システムとMLに酷似したアルゴリズムにつながります。
  具体的には、拘束解法を用いた構文単一化の拡張である新しい単一化アルゴリズムを提示します。
  主要型の存在は、この単一化アルゴリズムの分析に従います。

## 1 はじめに

  Hindley/Damas/Milner 多相型の拡張は、関数型プログラミング言語 Haskell(HJW92) の型クラスの概念で大きな注目を集めています。
  型クラスは、 Hindley/Damas/Milner システムの利点を保持しながら、関数名の体系的なオーバーロードを可能にします。すべての型付き式は、自動的に推論できる最も一般的な型です。
  Haskell 型のシステムへの拡張は既に提案されていますが (実装されていますが)、 Haskell の型推論アルゴリズムの本質はまだ単純化されていないと考えられます。
  この論文の主な目的は、特に単純なアルゴリズムを提供することであり、実装者にとっての貢献です。
  同時に、対応する単純な型推論システムを提示します。これは、言語のユーザーを対象としています。
  最後に、推論システムに関してアルゴリズムの健全性と完全性を厳密に証明します。
  アルゴリズムと推論システムはどちらもML対応のものと非常によく似ていますが、証明はかなり複雑です。

  Haskellの型クラスは、本質的には一連の型(ある種の関数を提供する)です。
  古典的な例は等価演算子です。
  standard ML より前のバージョンでは、等式関数 `=` は多相型 `∀α.α → α → bool` を持ち、

  ----

  1 これは、(NP93)の拡張バージョンです。

  2 ESPRIT BRA 6453、TYPESでサポートされている研究。

  3 ドイツForschungsgemeinschaft(DFG)の助成金Br 887/4、Deduktive Programmentwicklungによる研究。

  4 住所:InstitutfürInformatik、ドイツミュンヘン工科大学UniversitätMünchen80290ミュンヘン。電子メール:{nipkow、prehofer} @ informatik.tu-muenchen.de

  ----

<!-- page 2 -->

  ここで、型変数 `α` はすべての型にわたります。
  ただし、 `=` は関数型の引数には適用しないでください。
  この問題を解決するために、 standard ML (MTH90) では、等価が定義されている型の範囲にしかない特殊な型変数が導入されています。
  等価性は、他の多型関数とは限られた領域だけでなく、多形性と多重定義が混在しているためにも異なります。リストの等価性は、整数の等価性とは異なって実装されます。

  型クラスは、両方の問題を系統的に扱います。型変数αは、すべての "等価型" のクラスである特定の型クラスのエレメント、たとえば `Eq` に制限されています。
  次に、各型 `τ` について `=` を定義する必要がある場合、 `τ` が型 `τ → τ → bool` の実装を提供することによって `τ` がクラス `Eq` であると宣言しなければなりません。

  型 `τ` があるクラス `C` にあるという事実を表現するために、我々は判定 `τ : C` を導入します。 1
  Haskell を表現、型、クラスの3つのレベルのシステムとして見るという考えは、クラスが型を分類するところで、 Nipkow と Snelting (NS91) に戻ります。
  しかし、そのシステムでは、型が複数のクラスに属することを表現することは不可能です。
  この困難を克服するために、有限集合クラスとしてソートを導入します。
  判定 `τ : {C1, ..., Cn}` は、接続詞 `τ : C1 ∧ ... ∧ τ : Cn` のコンパクトな形です。
  あるいは、`{C1, ..., Cn}` を `C1 ∩ ... ∩ Cn` の表記法と考えることができます クラス `C1` 〜 `Cn`。
  これは、単純な型推論システムおよびアルゴリズムにつながります。
  前者はMini-ML(CDDK86)の場合と似ていますが、後者はMilner(Mil78)のアルゴリズムIと非常に似ています。
  主な相違点は、両方の場合において、我々はまた、`α : {C1, ..., Cn}` 形式の制約の集合を計算することです。ここで、`α` は型変数です。

## 2 Mini-Haskell

  この論文の目的は簡単なので、型クラスに関する Haskell の最も重要な機能だけを扱います。
  結果として得られる言語は基本的に Mini-ML (CDDK86) とクラス宣言とインスタンス宣言、 Mini-Haskell です。
  その構文を図1に示します。
  次の段落では、型クラスの簡単な説明を提供しますが、動機と例については、 Haskell レポート (HJW92) または型クラスに関するオリジナルの論文 (WB89) を参照する必要があります。
  この例では、 Haskell のクラスなどの具体的な名前に従わないことに注意してください。

  Mini-Haskell は制限された形式のオーバーロードによってMLを拡張します。
  あるクラスのサブクラスを無視すると、各クラス宣言には新しいクラス `C` と新しいオーバーロードされた関数名 `x` が導入されます。
  意味的には、`C` は関数 `x` をサポートするすべての型の集合を表します。
  例えば

    class α : Eq where eq : α → α → bool

  `eq : τ → τ → bool` 関数を提供する全ての型 `τ` のクラス `Eq` を導入します。
  クラス宣言は、モジュールインタフェースのようなものです。宣言と実装を分離しています。
  特定の型、例えば `int` が `Eq` であることを "証明" するために、必要な関数 `eq` の "目撃者" が提供される必要があります。


  ----

  1 クラスが型の述語として見られる場合、これは Haskell 表記 `C(τ)` につながります。

  ----

<!-- page 3 -->

    Type classes        C
    Sorts               S  = {C1, ..., Cn}
    Type variables      α
    Type constructors   t
    Types               τ  = α | t(τ1, ..., τn)
    Type schemes        σ  = τ | ∀α:S.σ
    Identifiers         x
    Expressions         e  = x
                           | (e0 e1)
                           | λx.e
                           | let x = e0 in e1
    Declarations        d  = class α : C ≤ S where x : σ
                           | inst t : (S1, ..., Sn)C where x = e
    Programs            p  = d; p | e

  図1. Mini-Haskell 型と式の構文

  これはインスタンス宣言の目的です。
  `int` を証明するためには、 `eq` を `eq int` でインスタンス化します。既存の `int → int → bool` の関数:

    inst int : Eq where eq = eq int

  一般的には、地面型だけでなく、型コンストラクタによってもクラスをインスタンス化できます。
  例えば、 `list(τ)` 型が `τ` が提供する等価性を認めている型を表現したいと思うかもしれません:

    inst list : (Eq)Eq where eq = ...

  宣言 `list : (Eq)Eq` は、クラス `Eq` の型をクラス `Eq` の型にマップするリストを表しています。
  リスト上の `eq` の実装は意図的に空白のままです: パターンマッチングと私たちの言語での再帰がないため、必要なコードは不動点コンビネータで囲まれた条件のネストになります。

  クラスは階層構造で配置できます。
  一般的なクラス宣言

    class α : C ≤ S where x : σ

  すでに定義されているはずの `S` 内のすべてのクラスのサブクラスとして新しいクラス `C` を導入します。
  型 `α` は、`S` のすべてのクラスの交差点にある場合にのみ `C` にあり、型 `σ` の関数 `x` を提供します。
  例えば、順序付けされた型のクラス `Ord` は `le` という追加の関数を提供する `Eq` のサブクラスとして定義することができます:

    class α : Ord ≤ Eq where le : α → α → bool

  サブクラスは単なる構文糖 (CHO92) です。
  上の例では、 `Ord` は完全に別のクラスとして `Eq` を参照することなく定義できます。
  唯一の相違点は、サブクラスがなければ、判定 `τ : Ord` は、`τ : Eq ∧ τ : Ord` 、すなわち `τ : {Eq, Ord}` に拡張されなければならないことです。
  しかし、 (NP93) のように、サブクラスを直接削除するよりも、サブクラスを直接処理する方が簡単です。
  これを実証するため、またサブクラスが Haskell の一部であるため、 Mini-Haskell にサブクラスを含めましました。

<!-- page 4 -->
## 2.1 ソートと型

  導入の動機付けとして、ソートは有限集合クラスです。
  この表現は、型推論の簡潔な処理のための重要な要素です。
  それでも、意味的には、ソート `{C1, ..., Cn}` は `C1 ∩ ... ∩ Cn` と理解されるべきです。
  したがって、 `{C}` と `C` は等価であり、空集合 `{}` はすべての型のソート/集合です。
  `S1` がより特殊化されている場合、すなわち、 `S2` よりも少ない型を表す場合、我々は `S1 ⪯ S2` と書きます。
  クラスの部分順序 `≤` が与えられると、ソートされた準順序 `⪯` は次のように定義されます。

    S1 ⪯ S2 ⇔ ∀C2 ∈ S2 .∃C1 ∈ S1.C1 ≤ C2

  `S1 ⊇ S2` は `S1 ⪯ S2` を意味します。
  クラスについての些細でない順序の文脈では、 `{Ord} /⊇{Eq}` でも `{Ord} ⪯ {Eq}` のように逆の意味は成立しません。
  どのような2つの種類の `S1` と `S2` が、それらの和集合が `S1 ∪ S2` である最小値を持つことは容易に分かります。

  `⪯` は一般に擬似次数のみである(すなわち、非対称ではない)ため、等価性を生じます

    S1 ≈ S2 ⇔ S1 ⪯ S2 ∧ S2 ⪯ S1.

  `{Ord}` や `{Ord, Eq}` のような `≈` を法とするソートは、同じ型の集合を表します。
  等価クラス `[S]≈` を使うのは数学的にはより洗練されていますが、実装に近づき、ソートを直接行うことを好みます。
  それにもかかわらず、インプリメンテーションは等価クラス `[S]≈` から任意の代表を自由に選ぶことができます。例えば、最小要素を持つものなどです。

  Mini-Haskell の型は、固定アリティの変数とコンストラクタに対する単純な項です。
  `→` は別の型のコンストラクタであることに注意してください。つまり、 `τ1 → τ2` は `→(τ1, τ2)` の略です。
  型スキームの自由変数のセットは、 `FV(σ)` で表されます。
  型スキームの束縛変数は、型の特定のサブセットに対してのみ範囲をとります。 `∀α:S.σ` はすべてのインスタンス `{α |→ τ}σ` を略して `τ : S` を正式に定義します。

  続編では、構文オブジェクト `s1, ..., sn` のリストが `(sn)~` で省略されています。
  例えば、 `∀(αn : Sn)~ .σ` は `∀α1:S1, ..., αn:Sn.σ` と等価です。
  順序は、コンポーネントごとに `Sn ⪯ Tn ⇔ ∀i. Si ⪯ Ti` のようにリストに拡張されます。

## 2.2 宣言とプログラム

  図1に示すように、式は let 定義で拡張された λ 項です。
  プログラムとは、一連の宣言の後に式が続くものです。

  Haskell 宣言 `class (C1 α, ..., Cm α) ⇒ Cα` に対応する Mini-Haskell クラス宣言 `class α : C ≤ {C1, ..., Cm}`、 `τ` は `σ` の本体です。
  `σ` は、 `α` を除く自由変数を含まなくてはならないことに留意してください。
  Haskell クラスは任意の数の関数を宣言することができるので、逆方向への変換がより複雑になります。
  この特徴は明らかに必須ではなく、例えば、1組の関数を1組の関数で表現することによってモデル化することができます。
  厳密に言えば、クラス名とそのクラスで宣言された単一の関数との間には1対1の対応があるため、クラス名を完全に削除することができましました。

<!-- page 5 -->

  これは私たちをStefan Kaes(Kae88)の言葉に導きましたが、Haskellとの関係を不明瞭にしていましました。

  Mini-Haskell のインスタンス宣言 `inst t : (S1, ..., Sn)C where x = e` は、 `τi` が与えられているなら `t(τ1, ...τn)` がクラス `C` ソート `Si` です。
  これは Haskell 宣言 `inst(con) ⇒ C(t α1 ... αn) where x = e` に対応します。ここで `con` は `C' ∈ Si` の `C'αi` と全て `i = 1 ... n` です。

## 2.3 型の分類

  型推論に着手する前に、より簡単なソート推論の問題を解決しなければなりません。
  MLや他の多くの言語では、`e : τ` という判断があり、 `e` は `τ` 型であると表現しています。
  同様に、型 `τ : S` を用いて型を分類すると、型 `τ` はソート `S` であることが示されます。
  この判断は、

  - `τ` における型変数の種類。

    これはソートコンテキスト `Γ` に記録されます。これは、型変数から `Dom(Γ) = {α | Γα /= {}}` は有限です。
    ソートコンテキストは `[α1 : S1, ..., αn : Sn]` と書くことができます。

  - 型コンストラクタの "関数性" です。
  
    型コンストラクタの振る舞いは、インスタンス宣言から直接持ち上げられる `t : ((Sn)~)C` という形式の宣言によって指定されます。
    続編では、`∆` は常にそのような宣言のセットを示します。

  - サブクラスが `≤` を並べ替えます。


  `∆,≤` の組は `(型)シグニチャ` と呼ばれ、`Σ` で示されます。すなわち、`∆,≤` および `Σ` は互換的に使用されます。

  `Γ` と `Σ` が与えられれば、 `Σ,Γ ⊢ τ : S` という判断を使って `τ` 型の類型を推論することができます。
  ルールを図2に示します。
  `{C}` とクラス `C` は同等であることに注意してください。

  `⪯` という順序は、ソートからコンテキストに容易に拡張されます。

    Γ ⪯ Γ′ ⇔ ∀α. Γα ⪯ Γ′ α

  `Γ'` は `Γ` よりも一般的です。
  この順序付けに関して `⊢` が単調であることを示すことは容易です: `Σ,Γ' ⊢ τ : S` は `Σ,Γ ⊢ τ : S` を意味します。
  続編では、この事実はしばしば暗黙的に使用されます。

  全ての2つのソートが最小値を有するので、全ての型 `τ` は、最も特有のソート `S` を有する。すなわち、 `Σ, Γ ⊢ τ : S` であり、 `Σ, Γ ⊢ τ : S′` ならば `S ⪯ S′` です。
  この最も具体的なソートの計算は簡単で、私たちの目的には関係しないので、ここでは心配しないものとします。

  Mini-Haskell 型のソート推論を見て、私たちは Mini-Haskell プログラムの主目的、型推論、型再構築の準備をしています。

## 3 型推論システム

  このセクションでは、 Mini-Haskell の2つの型推論システムを紹介します。
  Mini-Haskell プログラムと式の型を定義する一連の推論規則から始めます。
  
<!-- page 6 -->

    [i = 1 ... n]
      :
      :
    Σ,Γ ⊢ τ : Ci
    -----------------------------
    Σ,Γ ⊢ τ : {C1, ..., Cn}

    Σ,Γ ⊢ τ : {C1, ..., Cn}
    -----------------------------  i = 1 ... n
    Σ,Γ ⊢ τ : Ci

    Γ(α) = S
    -------------
    Σ,Γ ⊢ α : S

                        [i = 1 ... n]
                              :
                              :
    t : ((Sn)~)C ∈ ∆     Σ,Γ ⊢ τi : Si
    --------------------------------------
    Σ,Γ ⊢ t((τn)~) : C

    Σ,Γ ⊢ τ : C1   C1 ≤ C2
    ---------------------------
    Σ,Γ ⊢ τ : C2

  図2 判断 Σ, Γ ⊢ τ : S
  
          ∆,(≤ ∪{(C, D) | D ∈ S})*,Γ,E[x:∀α:C.σ] ⊢ p : σ′
    CLASS ----------------------------------------------------------
          ∆,≤,Γ,E ⊢ (class α : C ≤ S where x : σ; p) : σ′

          ∆ ∪ {t : ((Sn)~)C},≤,Γ,E ⊢ p : σ′
          E(x) = ∀α:C.σ
          Γ[(αn : Sn)~],∆,≤,E ⊢ e : {α |→ t((αn)~)}σ
    INST  -----------------------------------------------------
          ∆,≤,Γ,E ⊢ (inst t : ((Sn)~)C where x = e; p) : σ′

  図3 判断 ∆,≤,Γ,E ⊢ p : σ

  次に、より限定された構文指向の規則のセットに進みます。これは型推論アルゴリズムの基礎となります。

  通常MLのような言語の型推論のように、環境は識別子から型への有限のマッピング `E = [x1 : σ1, ..., xn : σn]` です。
  `E` のドメインは `Dom(E) = {x1, ..., xn}` です。
  `E[x:σ]` は `x` を `σ` にマッピングし、他のすべての `xi` を `σi` にマッピングする新しいマップです。
  `E` の自由型変数は `FV(E) = FV(E(x1)) ∪ ... ∪ FV(E(x n))` です。
  `V` が型変数のセットであるならば、`V` にない変数に対するΓの制限は `Γ \ V = [α:Γα | α ∈ Dom(Γ) − V]` となります。

  **置換** は、型変数から型への有限のマッピングであり、 `{α1 |→ τ1, ...}` と書かれています。
  置換は `θ` で示され、`δ;{}` は空の置換です。
  `Dom(θ) = {α | θα /= α}`、 `Cod(θ) = ∪_{α∈Dom(θ)} FV(θ(α))`、 `FV(θ) = Dom(θ) ∪ Cod(θ)` を定義します.

  図3と図4で定義されている2つの判定があります: `∆,≤,Γ,E ⊢ p : σ` と `∆,≤,Γ,E ⊢ e : σ` はプログラム `p` と表現 `e` は、`∆`、 `≤`、`Γ`、 `E`の文脈で `σ` 型です。
  逆方向に適用されたとき、 `∆,≤,Γ,E ⊢ p : σ` の規則は単に宣言をトラバースし、`∆`、 `≤`、` E` を構築します。

<!-- page 7 -->

  クラス宣言は `E` と `≤` を拡張し、インスタンス宣言は `∆` を拡張します。
  ルール CLASS の推移閉包 `≤` の `(≤ ∪ {(C, D) | D ∈ S})*` の新しいサブクラス関係を取る必要があることに注意してください。

  ルールINSTは、 `e` が `{α |→ t((αn)~)}σ` 型であることを確認して `x` のインスタンス化を型チェックします。`σ` はジェネリック型 `x` と `{α |→ t((αn)~)}` は新しい型変数 `(αn)~` の型置換です。

  定式化しない宣言シーケンスには、次の2つのコンテキスト条件があります:

  1. `class α : C ≤ S` の前に `S` の各スーパークラスの宣言を置かなければなりません。 `class α : C;`

  `(Sn)〜)C`は` C`の各スーパークラス `D 'の前に`(Sn)~D``が宣言 `inst t:((Tn)〜) 〜⪯(Tn)〜 `であるが、別の宣言` inst t(...)C 'ではありません。


  これらの条件は、Haskell (HJW92,4.3.2) で実際に採用されている制限を Mini-Haskell に変換した結果です。
  それらを実施するのは簡単なので、このホワイト論文では無視されています。
  それにもかかわらず、すべての宣言、したがって `∆` および `≤` が上記の条件を満たしていると続編で仮定します。

    ASM --------------------
        Σ,Γ,E ⊢ x : E(x)

        Σ,Γ,E ⊢ e : ∀α:S.σ   Σ,Γ ⊢ τ : S
    ∀E -----------------------------------
        Σ,Γ,E ⊢ e : {α 7→ τ }σ

        Σ,Γ[α:S],E ⊢ e : σ    α ∈ FV(σ) − FV(E)
    ∀I ----------------------------------------
        Σ,Γ,E ⊢ e : ∀α:S.σ

        Σ,Γ,E ⊢ e1 : τ2 → τ1    Σ,Γ,E ⊢ e2 : τ2
    APP -----------------------------------------
        Σ,Γ,E ⊢ (e1 e2) : τ1

        Σ,Γ,E[x:τ1] ⊢ e : τ2
    ABS ---------------------------
        Σ,Γ,E ⊢ λx.e : τ1 → τ2

        Σ,Γ,E ⊢ e1 : σ1    Σ,Γ,E[x:σ1] ⊢ e2 : σ2
    LET ------------------------------------------
        Σ,Γ,E ⊢ let x = e1 in e2 : σ2

  図4 判断 Σ,Γ,E ⊢ e : σ

  `Σ,Γ,E ⊢ e : σ` のルールは、`Σ,Γ` を介して表現される並べ替えの概念と型スキームの制限付き定量化によって、Damas and Milner(DM82)の古典的なシステムを拡張します。
   `∀I` の中の `α ∈ FV(σ)` という仮定は本当に本質的ではありません(健全性のために)。
   その実用的な意義については第8章で論じます。
   CLASS と INST の規則とは対照的に、 `Σ` は固定されたままです。

## 3.1 構文指向型推論

   型再構成アルゴリズムへの次のステップは、より制限されたルールセットです。
   これらの規則の適用は、その型が計算されるべき式の構文によって決定されます。

<!-- page 8 -->

  構文指向システムを区別するために、 `⊢` の代わりに `？` を使い、そのルールの名前をプライムします。 `ASM` 。

  定義 3.1

  `Σ` と `Γ` の下では、 `σ = ∀(αm :Sm)~ .τ` の一般的なインスタンスであり、`σ′ = ∀(αn′ :Sn′)~ .τ′` となるような置換 `θ` が存在する場合、

    θτ                   = τ ′ ,
    Dom(θ)               ⊆ {α m },
    Σ, Γ[α n ′ :S n ′ ]  ⊢ θα i : S i  [i = 1 ... m],
    {(α n ′)~} ∩ FV(σ)   = {}.

  このような型の関係を使って、最も一般的な、または主要な型の式を定義できるようになりましました。
  `FV(E) = {}` ならば `E` は閉じます。

  定義 3.2

  もしも `Σ,[],E ⊢ e : σ` かつ `Σ,[],E ⊢ e : σ'` を用いたすべての `σ` に対して、型スキーム `σ'` は、 `σ` の一般的なインスタンス、すなわち、 `Σ,[] ⊢ σ ⪰ σ′` でなければならず、`Σ` および閉環境 `E` に関して、型スキーム `σ` は、式 `e` の主要型です。
  構文指向システムでは、ルール APP と ABS は変更されず、図5に示すように、数量子ルールは ASM と LET に組み込まれます。

         Σ,Γ ⊢ E(x) ⪰ τ
    ASM′ ------------------
         Σ,Γ,E ▷ x : τ

         Σ,Γ[(αk : Sk)~],E ▷ e1 : τ1
         Σ,Γ,E[x:∀(αk :Sk)~ .τ1] ▷ e2 : τ2
    LET′ --------------------------------------
         Σ,Γ,E ▷ let x = e1 in e2 : τ2
         where {(αk)~} = FV(τ1) − FV(E)

  図5. 判断 Σ,Γ,E ▷ e : σ

  2つのシステム間には直接の対応があります。構文指向の導出は健全です

  定理 3.3

  `Σ,Γ,E ▷ e : τ` ならば `Σ,Γ,E ⊢ e : τ` です。

  そしてある意味では元のシステムに関して完全です:

  定理 3.4

  `Σ,Γ,E ⊢ e : ∀α n : Sn .τ` ならば `Σ,Γ[αn : Sn], E ▷ e : τ` です.

  最後の定理の証明は、例えば (CDDK86, App. A.1) のように標準的です。

  定理3.4は、`⊢:` がプライムされたルールを後方に適用することによって `⊢:` が `▷` とどのように異なるのかを明確にし、型変数のソート制約は `e` の型式スキームではなく `Γ` にのみ格納されます。
  たとえば、 `LET` ルールは `Γ` を明示的に拡張します。
  `ASM` ルールで使用される `⪰` 演算は、 `Γ` で拘束されなければならない新しい型変数を導入するかもしれません。

<!-- page 9 -->

  構文指向システムは、すでに非常に操作上の味があります。
  型推論システムからアルゴリズムに移行するためには、もう一つの要素、すなわち単一化が必要です。

## 4 ソート制約付きの型の単一化

  この節では、ソート制約の存在下でのコンテキストの形式による単一化について説明します。
  原則として、この問題は、(NS91) で `⪯` に関して行われたように、順序ソートされた単一化に縮小することができます。
  しかし、われわれは、シンプルさを求める私たちの探求に反しているので、そうしないことを控えています。すなわち、オーダーソートされた単一化を伴い、アルゴリズムは実際よりも複雑に見えます。
  さらに、オーダーソートされた単一化の標準理論は、とにかく再形式化する必要があります。変数は、コンテキストを使用するのではなく、ソートでタグ付けされていると仮定します。

  この論文の残りの部分では、固定シグネチャ `Σ = (∆, ≤)` を仮定します。
  これは、過度のパラメータ化を避ける表記的なデバイスにすぎません。

  ソート情報はコンテキスト内で維持されるため、頻繁にコンテキストと置換のペアを処理します。
  置換 `θ` は、すべての `α` に対して `Γ` の文脈における `Γ` のソート制約に従い、`Γ` :`Γ、Γ、Γθα:Γα` と書かれています。
  `Γα = {}` ならば、 すべての `α ∈ Dom(Γ)` に対して `Σ,Γ' ⊢ θα : Γα` がすべて成り立つので、 `Σ,Γ′ ⊢ θα : Γα`  を必要とすれば十分です。
  例えば、セクション2の例のように `Eq` とリストを定義します。
  それから `[β:Eq] ⊢ {α |→ list(β)} : [α:Eq]` となります。

  コンテキスト置換ペアの順序付けを定義します。

    (Γ,θ) ≥ (Γ′,θ′) ⇔ ∃δ. δθ = θ′ ∧ Γ′ ⊢ δ : Γ

ここで `δθ` は合成として定義されます: `(δθ)(s) = δ(θ(s))`。

   `τ1` と `τ2` の unifier の集合 w.r.t. `Γ` は、`U(Γ, τ1 = τ2)` と書かれ、以下のコンテキスト置換対からなります。

    U(Γ, τ1 = τ2) = {(Γ′,θ) | θτ1 = θτ2 ∧ Γ′ ⊢ θ : Γ}

すべての `(Γ1, θ1) ∈ U(Γ, τ1 = τ2)` に対して、 `(Γ0, θ0) ≥ (Γ1, θ1)` ならば、ユニファイア `(Γ0 , θ0) ∈ U(Γ, τ1 = τ2)` は最も一般的です。
   すべての `Γ` と `τ1 = τ2` に対して集合 `U(Γ, τ1 = τ2)` が空であるか、最も一般的な統合を含むならば、 `Σ` を法とする単一化は単一であるといいます。

   シグネチャ `Σ` は、すべての型のコンストラクタ `t` に対してすべてのクラス `C` がセットされていれば、コアグラルと呼ばれます

    D(t, C) = {(Sn)~ | ∃D ≤ C. (t : ((Sn)~)D) ∈ ∆}

  は空であるか、または `⪯` に関して最大の要素を含みます。
  `D(t,C)` が空であれば `Σ` がコアグラルであると `Dom(t,C)` は `D(t,C)` の最大要素を返します。
   例えば、 `Dom(list, Eq) = Eq` でも `Dom(list, Ord)` は失敗します。

   ソートされた単一化は、ソートされていない単一化+制約の解決として表現できます。
   コアギュラシグネチャ `Σ` が与えられた場合、これは以下の簡単な形式をとります:

    unify(Γ,τ1 = τ2) =
      let θ  = mgu(τ1 = τ2)
          Γc = Constrain(θ,Γ)
      in (Γc ∪ (Γ \ Dom(θ)),θ)

<!-- page 10 -->

  ここで

  - `mgu` は未分類の `mgu` を計算する(特に、 `θ` が冪等であり、`Dom(θ) ∪ Cod(θ) ⊆ FV(τ1 = τ2))` 又は存在しない

  - 2つのソート・コンテキストの和集合は、

         Γ1 ∪ Γ2 = [α : Γ1α ∪ Γ2α | α ∈ Dom(Γ1) ∪ Dom(Γ2)]

   - `Constrain(θ,Γ)` は、 `Γc ⊢ θ : Γ` となるような最も一般的な文脈 `Γc` を計算します。
  
        Constrain(θ,Γ) = ∪_{α∈Dom(θ)} constrain(θα,Γα)

   - `constrain(τ,S)` は `Σ,Γ ⊢ τ : S` となるような最も一般的な文脈 `Γ` を計算します。

        constrain(α,S)        = [α:S]
        constrain(t((τn)~), S)  = ∪_{C∈S} constrains((τn)~, Dom(t,C))
        constrains((τn)~,(Sn)~) = ∪_{i=1...n} constrain(τi, Si)
        

  したがって、 `mgu` が失敗した場合、または `Constrain` で使用されている `Dom(t,C)` が存在しない場合、統合は失敗します。
  拘束の第一引数の誘導によって、
  
    constrain(t((τn)~,S) = ∪_{C∈S} constrains((τn)~, Dom(t,C))
  

  これは、以下の証明においても有用な制約の代替定義を提供します。
  制約がどのように働くかを見るには、 `Eq` を仮定し、セクション2の例のように再度リストします。
  それから、 `constrain(list(β), Eq) = constrains(β, Dom(list, Eq)) = [β:Eq]` を制約します。

  Constrainの健全性と完全性は、 `Σ` の中核性を仮定し、 `τ` の構造上の誘導によって証明される以下の補題によって捕捉されます:

  補題 4.1

  `constrain(τ,S)` が定義されていれば `Σ`、`constrain(τ,S) ⊢ τ : S` を定義します。

  補題 4.2

  `constrain(θτ,S)` が定義されていれば `constrain(τ,S)` も定義され、さらに `constrain(θτ,S) ⊢ θ : constrain(τ,S)` が成り立ちます。

  補題 4.3

  `Σ,Γ ⊢ τ : S` ならば `constrain(τ,S)` が定義され、 `Γ` よりも一般的です。

  最後に、主定理:

  定理 4.4

  `Σ` がコアグラムの場合、 unify は最も一般的なユニファイアーを計算します。

  証明健全性を示すために、 `(Γ,τ1 = τ2)` の単一化を`(Γ0, θ0)` の結果で終わらせます。
  それは `θ0 τ1 = θ0 τ2` に直接従います。
  すべての`α` に対して`Γ0 ⊢ θ0 α : Γα` が残っていることは変わりません。
  `α ∈/ Dom(θ0)` ならば、 `Γα ⊆ Γ0 α` となり、主張は自明です。
  `α ∈ Dom(θ0)` ならば、 `Γ0 ⪯ Γc = Constrain(θ0,Γ) ⪯ constrain(θ0 α,Γα)` を制約し、補題 4.1 に従います。

<!-- page 11 -->

  完全性を示すためには、`(Γ1,θ1) ∈ U(Γ, τ1 = τ2)`、すなわち、`θ1 τ1 = θ1 τ2` かつ `Γ1 ⊢ θ1 : Γ` とします。
  `τ1` と `τ2` はunorted unifier `θ1` を持っているので、 `mgu(τ1 = τ2)` が定義され、ある `δ` の `θ1 = δθ0` となるような置換 `θ0` が得られます。
  `unify(Γ,τ1 = τ2)` の定義は、`constrain(θ0 α, Γα)` の定義を必要とします: 補題4.2は `constrain(θ0 α, Γα)` の定義を与えます。
  したがって、 `unify(Γ,τ1 = τ2)` は結果 `(Γ0,θ0)` で終了します。

  それは `Γ1 ⊢ δ : Γ0` であることが分かります。
  `β ∈ Dom(θ0)` ならば `Γ0 β = {}` したがって `Γ1 ⊢ δβ : Γ0 β` が保たれるのは自明です。
  ここで、 `β ∈/ Dom(θ0)` とします。
  従って、`Γ0 β = Γc β ∪ Γβ` です。
  `Γ1 ⊢ θ1 : Γ` から `Γ1 ⊢ δβ : Γβ` となります。
  `Γ1 ⊢ δ : Γc` の証明はより複雑です。
  補題 4.2 から、(α1α、Γα)⊢δ:任意の`α` に対して `constrain(θ1 α, Γα) ⊢ δ : constrain(θ0 α, Γα)` です。
  `Γ1 ⊢ θ1 α : Γα` から、 補題 4.3 は `Γ1 ⪯ constrain(θ1 α, Γα)`、したがって単調性 `Γ1 ⊢ δ : constrain(θ0 α, Γα)` を意味します。
  これは簡単に `Γ1 ⊢ δ : Constrain(θ0, Γ)`、すなわち `Γ1 ⊢ δ : Γc` を容易に生成します。 □

  定理 4.5

  `Σ` が中核である場合、`Σ` を単一化は単一です。

  証明 "if" 方向は定理4.4の結果です。
  "唯一の" 方向については、`Σ` は中括弧ではありません。
  したがって、第3の宣言 `t : ((Un)~)E′`, `E′ ⪯ E`, かつ `(Sn)~`, `(Tn)~ ⪯ (Un)~` が存在しないようなクラス `C`, `D ≤ E` 及び宣言  `t : ((Sn)~)C` and `t : ((Tn)~)D, (Sn)~ ⪯/ (Tn)~` 及び `(Tn)~ ⪯/ (Sn)~` が存在します。
  したがって、単一化問題([β:E]、t((αn)〜)=β) `は、最も一般的な単一化を持ちません。
  2つの最大値は、`([(αn : Sn)~],θ)` と `([(αn:Tn)~], θ)` です。ここで `θ = {β → t((αn)~)}` です。 □

  したがって、プリンシパル型が存在するシグネチャの正確な特徴付けが行われます。

  Mini-HaskellのCLASS宣言とINST宣言がコアギュラシグネチャを生成するかどうかはまだ分かりません。
  実際には、第3章で述べた非形式化された文脈条件によって制限された場合に行います。
  後者の文脈条件は、有効なクラス宣言およびインスタンス宣言から導出されたすべての `∆` および `≤` が以下の強い特性を有することを意味します。
  `D(t、C) `は `t((Sn)~)C` が `t` と結果 `C` のための一意の宣言であれば、シングルトン `{(Sn)~}` で、そのような宣言がないならば、空です。
  したがって、 `Dom(t,C)` は `≤` を参照することなく、 `∆` だけを使って計算することができます。
  これは、型の単一化、したがって次のセクションの型推論で見られるように、サブクラス階層を完全に無視できるという観察につながります。

  サブクラス階層を無視するということは、セクション2で定義されているソートで等価 `≈` によって与えられる自由度を放棄することを意味します。
  例えば、 `unify([α : {Eq}, β : {Ord}], α = β)` は `([α : {Eq, Ord}], {β |→ α})` を返します。
  `≈` を考慮すると、`([α : {Ord}], {β |→ α})` を返すこともできます。
  次の展開がこれらのユニファイアのどれが計算されているかに依存しないことを示すために、 `unify` は任意の関数であると仮定し、 `Σ` がコアギュラであると仮定し、最も一般的な湯にファイアを返すと仮定すると: もしも `U(Γ, τ1 = τ2) /= {}` ならば

  - `unify(Γ, τ1 = τ2) ∈ U(Γ, τ1 = τ2)` かつ
  - すべての `(Γ′,θ) ∈ U(Γ, τ1 = τ2)` に対して、 `(Γ′,θ) ≤ unify(Γ, τ1 = τ2)` です。


  これには、いくつかの単純なプロパティが含まれます。

<!-- page 12 -->

  事実 4.6

  もし `unify(Γ,τ1 = τ2) = (Γ′,θ)` ならば

   - `θ` は `τ1` と `τ2` の最も一般的な統合であり、
  - `Dom(Γ′) ∪ FV(θ) ⊆ Dom(Γ) ∪ FV(τ1) ∪ FV(τ2)`、
  - `Dom(Γ′) ∩ Dom(θ) = {}` です。


  第2の事実は、 `unify` が新しい変数を導入しないことを示し、最後は `Γ'` が `θ` によってインスタンス化された変数を制約しないことを表しています。
  `Γ` は`≈` までしか決まらないことは容易に分かります。
  したがって、単一化アルゴリズムは、冗長要素を各ソートから削除することによって、常に`Γ` が "最小化" されることを保証することができます。

  最後に、 Haskell の文脈条件よりも厳密に弱いという事実が、後者が緩和できるかどうかを疑問に思うかもしれません。
  私たちは、些細なリラクゼーションはないと考えていますが、セマンティクスと語用論を考慮に入れて型システムを超えなければならないため、このテーマを拡大したくありません。

## 5 アルゴリズムW

  図5の構文指向ルールシステムは、ルール ASM' が型 `x` の任意のインスタンスを選択できるので、非決定論的です。
  決定論的アルゴリズムを得るために、構文指向システムを改良して、できる限り一般的な型を保持するようにします。
  結果は図6のアルゴリズムWです。この節では、`Σ` がコアグリヤであると仮定します。そうでなければ、ユニファイドは明確に定義されていません。

    W(V,Γ,E,e) = case e of
                     x ⇒ let ∀(αn : Sn)~ .τ = E(x)
                                          βi ∈/ V [i = 1 ... n]
                          in (V′ ∪ {βn}, Γ[(βn :Sn)~], {}, {(αn |→ βn)~}τ)
                  λx.e ⇒ let            α ∈/ V
                              (V′,Γ′,θ′,τ) = W(V ∪ {α}, Γ, E[x:α], e)
                          in (V′,Γ′,θ′,α → τ)
               (e1 e2) ⇒ let (V1,Γ1,θ1,τ1) = W(V,Γ,E,e1)
                              (V2,Γ2,θ2,τ2) = W(V1,Γ1,θ1 E,e2)
                                          α ∈/ V2
                                    (Γ′,θ′) = unify(Γ2, θ2θ1τ1 = θ2τ2 → α)
                          in (V2 ∪ {α},Γ′,θ′θ2θ1,α)

      let x = e1 in e2 ⇒ let (V1,Γ1,θ1,τ1) = W(V, Γ, E, e 1 )
                                       {αn} = FV(θ1 τ1) − FV(θ1 E)
                              (V2,Γ2,θ2,τ2) = W(V1, Γ1 \ {αn},
                                                (θ1 E)[x : ∀(αn :Γ1 αn)~ .θ1 τ1],e2)
                          in (V2,Γ2,θ2θ1,τ2)

  図6. Algorithm W

  アルゴリズムWは同じ名前のMilnerオリジナルアルゴリズム(Mil78)と同じパターンに従います。式 `e` の型はトップダウン方式で `e` をトラバースして計算されます。
  `θτ` は `Γ` と `θE` の文脈における `e` の型であるとき、 `W(V,Γ,E,e)` は ４つ組み `(V′,Γ′,θ,τ)` を返します。

<!-- page 13 -->

  最上位レベルの呼び出しは `W({},[],E,e)` で、 `E` は閉じています。
  異なるlet-constructを見てください。左側のものはオブジェクト言語にあり、右側のものは型推論アルゴリズムの一部です。

  パラメータ `V` は、すべての`使用された` 変数、すなわち、 `Γ` または `E` に現れる変数を含みます。
  したがって、型変数 `α ∈/  V` は "新しい" 変数です。
  真に機能するアルゴリズムのために、"次の" 新しい変数 `α ∈/ V` が決定論的に計算されるように、変数に対する線形順序付けを使用することができます。
  一般に、 `W` は `FV(E) ∪ Dom(Γ) ⊆ V` となるように `V`、 `Γ` と `E` で呼び出されると仮定します。

  アルゴリズムWは直接的に実装されることを意味するのではなく、効率的な実装に向けて数学的に扱いやすいステップの役割を果たすだけです。
  主な弱点は、置換が最初から計算され、後で構成されるという事実です。
  この問題は、次のセクションのアルゴリズムIで解決され解決されます。
  置換とは対照的に、コンテキストは徐々に計算され、すなわち結果コンテキスト `Γ′` は入力コンテキスト `Γ` の拡張です。

  `W` の正式な分析にはさらに表記が必要です。
  環境 `E` と置換 `θ` については、 `θE = [x : θ(E(x)) | x ∈ Dom(E)]` と定義します。
  すべての `α ∈ W` に対して`θα = θ′ α` であれば、`θ = W θ` と書かれた変数 `W` のセットに対して2つの置換が等しくなります。
  変数セット `W` への置換の制限は、`α ∈ W` であれば `θ |W α = θα` であり、そうでなければ `θ |W α = α` と定義されます。
  構文オブジェクト `(Cn)~` のリストが与えられれば、 `FV(C1) ∪ ... ∪ FV(Cn)` の代わりに `FV((Cn)~)` と書きます。

  アルゴリズムがα変換のもとで不変であることを最初に示します。
  式eの自由変数、すなわち、`FV(e)` および `e` への置換の適用は、通常、λ-計算で定義されます。

  補題 5.1

  もし `W(V,Γ,E[x:τ],e) = (V′,Γ′,θ′,τ′)` かつ `y ∈/ Dom(E)` ならば `W(V,Γ,E[y:τ], {x |→ y}e) = (V′,Γ′,θ′,τ′)` です。
  `e` の誘導による証明。 □

  この補題では、α変換の望ましい定理を簡単に示すことができます。

  定理 5.2

  `e` を `λx.e2` または `let y = e1 in e2` とします。
  もし `W(V,Γ,E,e)` が定義されており、  `y ∈/ Dom(E)` かつ `y ∈/ FV(e)` ならば `W(V,Γ,E,e′) = W(V,Γ,E,e)` です。ここで、`e′` は 各々 `λy.{x |→ y} e2` または `let y = e1 in {x |→ y} e2` です。

  補題 5.1 を用いた誘導により証明できます。 □

  `W` の次の正確さと完全性の結果は、セクション4の終わりに向かって議論されるように、特定の単一化アルゴリズムに依存しません。

  定理5.3 (Wの正しさ)

  `W(V,Γ,E,e) = (V′,Γ′,θ,τ)` ならば `Σ,Γ′, θE ▷ e : θτ` です。

  正解定理を証明する前に、一連の補題を与える必要があります。
  次の補題は、 `W` によって使用されるオブジェクトの変数間の基本的な関係を示しています。
  最初の項目は、すべての使用された変数が `V` で記録されていると述べています。
  次に、計算されたオブジェクト内で発生する全ての新しい変数は`V` にあるが、`V` にはない。すなわち、名前の`再使用` はありません。

<!-- page 14 -->

  3番目の項目は、計算された型のいくつかの型変数が新しいものでない場合、それらが環境 `E` に入っていなければなりません。
  最後の項目は、計算された文脈が古い変数(`Dom(θ′)`にある)、すなわち　”ゴミ" がないことを前提としていないことを要求します。

  補題 5.4

  `W(V,Γ,E,e) = (V′,Γ′,θ′,τ)` かつ `FV(E) ∪ Dom(Γ) ⊆ V` とします。
  このとき

  1. `V ⊆ V′` かつ `Dom(Γ′) ∪ FV(θ′,E,τ) ⊆ V′`
  2. `(Dom(Γ′) ∪ FV(θ′,τ)) − (Dom(Γ) ∪ FV(E)) ⊆ V′ − V`
  3. `FV(θ′,τ) ∩ V ⊆ FV(E)`
  4. `Dom(Γ′) ∩ Dom(θ′) = {}`


  **証明** 最初の主張は、すべての新しい変数が `V′` で記録され、単一化アルゴリズムが新しい変数を導入しないので簡単に続きます(事実4.6参照)。
  同様の理由で、 `Dom(Γ′) ∪ FV(θ′,τ)` のすべての変数は新しいか `Dom(Γ) ∪ FV(E)` であるので、`FV(E) ∪ Dom(Γ) ⊆ V` からの第二の主張を得ます。

  残りの2つの項目は、用語構造上の誘導によって示されます。

  `x` は全ての `βi` が新しい変数、すなわち `βi ∈/ V` であるので自明です。

  `λx.e` : 誘導仮説によるものであり、 `α` は新しい変数であるからです。

  `(e1 e2)` : 最初に

    (FV(θ′) ∪ {α}) ∩ V ⊆ FV(E).

  単一化アルゴリズムは新しい変数を導入しないので、 `FV(θ′) ⊆ FV(θ2θ1,τ1,τ2) ∪ {α}` となります。
  `α ∈/ V` であるので、

    FV(θ2θ1,τ2,τ1) ∩ V ⊆ FV(E).  (1)

  `e2` の帰納仮説は、 `FV(θ2,τ2) ∩ V1 ⊆ FV(θ1E)` となります。
  `FV(θ1E) ⊆ FV(E,θ1)` と `V ⊆ V1` を用いて、`FV(θ2,τ2) ∩ V ⊆ F V(E,θ1)` を得ます。
  `e1`、すなわち、 `FV(θ1,τ1)∩V ⊆ FV(E)` の誘導仮説により、(1) を容易に得ることができます。
  次に、 `Dom(Γ′) ∩ Dom(θ′θ2θ1) = {}` を示します。
  帰納仮説から `Dom(Γ1) ∩ Dom(θ1) = {}` を得ます。
  次に、`Dom(θ1) ⊆ V1` と `Dom(θ1) ∩ FV(θ1E) = {}`(`θ1`の冪等)から、`Dom(Γ2) − (Dom(Γ1) ∪ FV(θ1E)) ⊆ V2 − V1`(補題5.4の2項)として `Dom(Γ2) ∩ Dom(θ1) = {}` を得ます。
次に、`Dom(Γ2) ∩ Dom(θ2) = {}` (帰納法の仮定) からと `Dom(θ2θ1) = Dom(θ1) ∪ Dom(θ2)` 以来、`Dom(Γ2) ∩ Dom(θ2θ1) = {}` は、次のとおりです。
  したがって、`Dom(Γ′) ∩ Dom(θ′θ2θ1) = {}` は単一化アルゴリズムの特性に従います。すなわち、変数は `Dom(θ′)` から制約されません(事実4.6参照)。

  `let x = e1 in e2` : 最初に

    FV(θ2θ1,τ2) ∩ V ⊆ FV(E).

  `e2` の帰納仮説は、

    FV(θ2,τ2) ∩ V1 ⊆ FV(θ1 E[x : ∀(αn :Γ1 αn)~ .θ1τ1])

  `FV(∀(αn :Γ1 αn)~ .θ1 τ1) ⊆ FV(θ1E)` となるので、

    FV(θ2,τ2) ∩ V1 ⊆ FV(θ1E) です。

<!-- page 15 -->

  証明の残りの部分は `(e1 e2)` と同じように進行します。
  `Dom(Γ2) ∩ Dom(θ2θ1) = {}` の証明は `(e1 e2)` の場合と同様に働きます。
  (追加の `θ′` とは別に) 唯一の相違点は、 `Dom(Γ2) ∩ {(αn)~} = {}` という証明を単純化するだけです。 □

  次の補題は、 `Γ ⊢ θ : Γ′` という関係が置換に関して一種の過渡性を持つことを示しています。

  補題 5.5

  もしも `Γ2 ⊢ θ2 : Γ1` かつ `Γ1 ⊢ θ1 : Γ` ならば `Γ2 ⊢ θ2 θ1 : Γ` です。

  **証明** `∀α ∈ Dom(Γ).Γ2 ⊢ θ2θ1α : Γα` を表示する必要があります。
  `Γ1 ⊢ θ1 α : Γα` (前提条件)の導出を考えてみましょう。
  `Γ2 ⊢ θ2 θ1 α : Γα` の導出は、`∀β ∈ FV(θ1 α).Γ2 ⊢ θ2 β : Γ1 β` かつ `Γ1 ⊢ β : Γβ` から (`θ1 β = β` は `θ1` の冪等子から続く) 簡単に求まります。 □

  `W` が文脈を特化しているという事実が次の結果に示されています。

  補題 5.6

  もしも `W(V,Γ,E,e) = (V′,Γ′,θ′,τ)` ならば `Γ′ ⊢ θ′ : Γ` です。

  `e` の構造に対する誘導による証明:

  `x` : `Γ[βn : Sn] ⊢ {} : Γ` は自明です。

  `λx.e` : 誘導仮説は 任意の `E`に対して成り立つので`E[x:α],Γ′ ⊢ θ′ : Γ` を直接含みます。

  `(e1 e2)` : 誘導仮説により、`Γ1 ⊢ θ1 : Γ` かつ `Γ2 ⊢ θ2 : Γ1` を得て、推移性(補題5.5)および単一化アルゴリズムの正しさにより `Γ′ ⊢ θ′θ2θ1 : Γ` です。

  `let x = e1 in e2` : 帰納仮説によって、

    Γ1 ⊢ θ1 : Γ           (2)
    Γ2 ⊢ θ2 : Γ1 \ {αn}   (3)

  今度は

    Γ1 \ {αn} ⊢ θ1 : Γ    (4)

  つまり、すべての `β∈Dom(Γ)` に対して `Γ1 \ {(αn)~} ⊢ θ1β : Γβ` を表示しなければなりません。
  まず、`FV(θ1 (Dom(Γ))) ∩ {(αn)~} = {}` を証明します。
  Lemma 5.4、item 3から、 `FV(θ1τ1) ∩ Dom(Γ) ⊆ FV(E)` となります。
  `θ1` の等式は、`FV(θ1τ1) ∩ FV(θ1(Dom(Γ))) ⊆ FV(θ1E)` となります。
  単純集合理論は、上記のように、`FV(θ1(Dom(Γ))) ∩ (FV(θ1τ1) − FV(θ1E)) = {}` をもたらします。
  今(4)が続きます。
  (4)と(3)を過渡性(Lemma 5.5)と組み合わせると、 `Γ2 ⊢ θ2θ1 : Γ` です。 □

  次の補題は、制約に従う文脈を仮定して、インスタンス化の下で `▷` が保存されると述べています。

  補題 5.7

  もしも `Σ,Γ,E ▷ e : τ` かつ `Γ′ ⊢ θ′ : Γ` ならば `Σ,Γ′,θ′E ▷ e : θ′ τ` です。

<!-- page 16 -->

  `Σ,Γ′,θ′E ▷ e : θ′ τ` の証明を得るために `Σ,Γ,E ▷ e : τ` の証明木に `Γ′ ⊢ θ′ α : Γα` という形の証明を加えることで簡単に証明できます。 □

  最後に、正解定理を証明することができます:

  `e` の構造の誘導による定理5.3で証明できます。
  私たちは次のような場合があります:

  `x` : 正確さは、

         Σ, Γ[(βn : Sn)~] ⊢ E(x) ⪰ {(αn |→ βn)~}τ
    ASM′ ーーーーーーーーーーーーーーーーーーーーーーーーーー
         Σ, Γ[(βn : Sn)~],E ▷ x : {(αn |→ βn)~}τ

  `λx.e` : 帰納仮説によって `Σ,Γ′,(θ′E)[x:θ′α] ▷ e : θτ` となります。
  ABSが適用されます:

        Σ,Γ,(θ′E)[x:θ′α] ▷ e : θ′ τ′
    ABS -----------------------------
        Σ,Γ,θ′E ▷ λx.e : θ′α → θτ′

  `(e1 e2)` : `e1` と `e2` の帰納仮説から

    Σ,Γ1,θ1E ▷ e1 : θ1 τ1
    Σ,Γ2,θ2θ1E ▷ e2 : θ2 τ2

  を得ます。
  単一化アルゴリズムの正しさは `Γ′ ⊢ θ′ : Γ2` をもたらし、 `Γ2 ⊢ θ2 : Γ1` (補題5.6から)と補題5.5を得て、 `Γ' ⊢ θ'θ2 : Γ1` を得ます。

  補題5.7より、APPルールの2つの前提が得られます。なぜなら、 `θ′θ2θ1τ1 = θ′θ2τ2 → θ′ α` であるからです。
  さらに、 `α` は新しい変数 (すなわち、補題5.4によると、`α ∈/ V2` および `Dom(θ2) ∪ Dom(θ1) ⊆ V2`) であるので、 `θ2θ1α = α` です。

        Σ,Γ′,θ′θ2θ1E ▷ e1 : θ′θ2θ1τ1
        Σ,Γ′,θ′θ2θ1E ▷ e2 : θ′θ2τ2
    APP ------------------------------
        Σ,Γ′,θ′θ2θ1E ▷ (e1 e2) : θ′α

  `Γ′1 = Γ1 \ {(αn)~}`, `(Sn = Γ1 αn)~` かつ `E′ = E[x : ∀(αn :Sn)~ .θ1τ1]` を用いると、誘導仮説は以下のようになります

    Σ,Γ′1[(αn : Sn)~],θ1E ▷ e1 : θ1τ1 (5)
    Σ,Γ2,θ2θ1E′ ▷ e2 : θ2τ2 (6)

  `FV(θ1E′) ∩ {(αn)~} = {}` に注目します。
  LET' を適用するには、

    Σ, Γ2[(αn : Sn)~], θ2θ1E ▷ e1 : θ2θ1τ1  (7)

  Lemma 5.6 から `Γ2 ⊢ θ2 : Γ′1` を、補題5.4(`{(αn)~} ⊆ V1` と `{(αn)~} ∩ FV(θ1 E′) = {}`) から `FV(θ2) ∩ {(αn)~} = {}` を得て、

    Γ2[(αn : Sn)~] ⊢ θ2 : Γ′1[(αn : Sn)~] です。

  次に(7)は補題5.7と(5)に従います。

  補題5.4（上記のように、 `θ1` は等価であるので、`Dom(θ1) ⊆ V1` かつ `Dom(θ1) ∩ FV(θ1 E′) = {}`）の結果は `Dom(θ1) ∩ FV(τ2) = {}` であるので、我々は以下を得ます

    Σ,Γ2,θ2θ1E′ ▷ e2 : θ2θ1τ2  (8)

<!-- page 17 -->

  今すぐ LET' に適用されます

    (7)   (8)   {(αn)~} = FV(θ1τ1) − FV(θ1E)
    --------------------------------------------------------
    Γ2,Σ,θ2θ1E ▷ let x = e1 in e2 : θ2θ1τ2

  □

  以下の補助定理は、主要型定理を確立するために重要です。

  補題 5.8(Wの完全性)

  もし `Σ,Γ*,θ* E ▷ e : τ*`, `Dom(Γ) ∪ FV(E) ⊆ V` かつ `Γ* ⊢ θ* : Γ` ならば、次のような置換δが存在する。

    W(V,Γ,E,e)    = (V1,Γ1,θ1,τ1),
    θ* E          = δθ1E,
    τ*            = δθ1τ1,
    Γ*            ⊢ δ : Γ1.

  `e` の構造に対する誘導により証明できます。
  我々は、一般性を失うことなく、アルゴリズムWによって使用される新しい変数`V1 - V`との可変オーバーラップを持たない`Σ,Γ*,θ* E ▷ e : τ*`の導出を仮定します。

  `x` : 私たちは持っています

          Σ,Γ* ⊢ θ* E(x) ⪰ τ*
    ASM′ ---------------------
          Σ,Γ*,θ* E ▷ x : τ*

   `∀(αn :Sn)~ .θ̂* τ` として`θE(x) = θ* ∀(αn :Sn)~ .τ` と書くことができることに注意してください。ここで `θ̂* = θ*| (Dom(θ*) − {(αn)~})` は、おそらく `(αn)~` の名前を変更しています。
  `Σ, Γ* ⊢ θ* E(x) ⪰ τ*` と仮定すると、 `θ` は `Dom(θ) ⊆ {(αn)~}` と定義3.1の対応する置換であり、 `τ* = θθ̂* τ` です。
  `δ = θ* ∪ {(βn |→ θαn)~}` とします。
  `(βn)~` は新しい変数なので、 `θ* E = δE` が成立します。
  次に、 `τ* = δ({(αn |→ βn)~}τ) = θθ* τ` は容易に追従します。
  最後に、 `Γ* ⊢ θ* : Γ` (前提) と `Σ,Γ* ⊢ θ′ αi : Si`、`[i = 1, ..., n]` (定義3.1参照) から `Γ* ⊢ δ : Γ[(βn : Sn)~]` です。

  `λx.e` : 導出はで終わります

        Σ,Γ*,(θ* E)[x:τ1*] ▷ e : τ2*
    ABS -----------------------------------------
        Σ,Γ*,θ* E ▷ λx.e : τ1* → τ2*

  アルゴリズムは α 変換の下で不変である(補題5.2)ので、安全に `x ∈/ Dom(E)` と仮定できます。
  帰納仮説を適用するために、 `θ0 = θ* ∪ {α |→ τ1*}` を定義します。
  そして、`Σ,Γ*,θ0 (E[x:α]) ▷ e : τ2*` と `Γ* ⊢ θ0 : Γ` は簡単に検証できます。
  帰納仮説によって、`δ1` が存在し、

    W(V ∪ {α}, Γ, E[x:α], e) =  (V′,Γ′,θ′,τ′),              (9)
    (θ0 E)[x:τ1*]             = δ1 θ′ E[x:α],               (10)
    τ2*                       = δ1 θ′ τ′,                   (11)
    Γ*                        ⊢ δ1 : Γ′                     (12)

  したがって、 `W(V,Γ,E,λx.e) = (V′,Γ′,θ′,α → τ′)` です。
  今、`θ0 E = δ1 θ′ E` は(10)から続きます。
  さらに(10)から、 `τ1* = δ1 θ′ α` となり、(11)から、 `τ1* → τ2* = δ1 θ′ (α → τ′)` となります。

<!-- page 18 -->

  `(e1 e2)` : 以下を仮定し

        Σ,Γ*,θ* E ▷ e1 : τ2* → τ1*    Σ,Γ*,θ* E ▷ e2 : τ2*
    APP -----------------------------------------------------
        Σ,Γ*,θ* E ▷ (e1 e2) : τ1*

  帰納仮説を `e1` に適用し、yields `δ1` such that

       W(V,Γ,E,e) =  (V1,Γ1,θ1,τ1), (13)
             θ* E =  δ1θ1 E,        (14)
        τ2* → τ1* =  δ1θ1 τ1,       (15)
               Γ* ⊢  δ1 : Γ1.       (16)

  `Γ1` と`Γ1` と`Γ1` と`Γ1` とを`e2` とする誘導仮説は、

  W(V1,Γ1,θ1E,e2) = (V2,Γ2,θ2,τ2), (17)  
             θ* E = δ2θ2θ1E,       (18)
              τ2* = δ2θ2τ2,        (19)
               Γ* ⊢ δ2 : Γ2.       (20)
  
  `δ*` を以下のように定義する
  
            | δ1 β    if β ∈ FV(θ1τ1) − Cod(θ2)
    δ * β = | τ1*     if β = α
            | δ2 β    otherwise


  `δ*` は、`θ2θ1τ1 = θ2τ2 → α` のユニファイアーであることを示します。
  補題5.4から、`FV(θ2,τ2) ∩ FV(θ1τ1) ⊆ FV(θ1 E)` が成り立ち、二つの置換 `δ2θ2` と`δ1` は `FV(θ1 E)` と(18)の収率

    δ2 θ2 = FV(θ1 E) δ1  (21)

  このオーバーラップは、事例分析による以下の証明を簡略化します。ここで、`β = α` の場合は重要ではありません。
  まず、 `δ* θ2 τ2 = δ2 θ2 τ2 = τ2*` を示すために、`β ∈ FV(τ2)` とします。
  `β ∈ FV(θ1 τ1)` を `FV(θ2,τ2) ∩ FV(θ1τ1) ⊆ FV(θ1E)` とすると、`β∈FV(θ2)` ならば、`δ*τ2=δ2τ2` となり、そうでない場合は自明です。
  `β ∈ FV(θ2)`　ならば、`δ*θ2τ2 = δ2θ2τ2` となります。

  `δ*θ2θ1τ1 = δ1θ1τ1` を示すには、`β ∈ FV(θ1τ1)` と仮定します。
  もし、`β ∈ Dom(θ2)` ならば、(21)は所望の結果を `Dom(θ2) ∩ FV(θ1τ1) ⊆ FV(θ1E)` とします。
  `β ∈/ Dom(θ2)` の場合、`δ*θ1τ1 = δ1τ1` となります。
  したがって、 `δ*` は望ましいユニファイアーです:

    δ* θ2θ1τ1 = τ2* → τ1* = δ* (θ2τ2 → α).

  (16)と(20)から `Γ* ⊢ δ* : Γ2` を求めます: これは、すべての `β ∈ Dom(Γ2)` に対して `Σ,Γ* ⊢ δ* β : Γ2 β` です。
  まず、補題5.4で `Dom(Γ2) ∩ Dom(θ2) = {}` を思い出してください。
  もし、`β ∈ FV(θ1τ1) - Cod(θ2)` ならば、 `Γ2 β = {}` であり、そうでなければ `θ2 β = β` から `Γ2 ⊢ θ2 : Γ1` (補題5.6)では、`Γ1 β ⊆ Γ2 β` を持ち、(16)式からの要求に従います。
  `Γ2 α = {}` なので、 `β = α` の場合は自明です。
  残りの場合、 `Σ,Γ* ⊢ δ2θ2 β : Γ2 β` は `Dom(Γ2) ∩ Dom(θ2)= {}` から容易に(20)から得られます。

<!-- page 19 -->

  そして、単一化の完全性によって、`θ′` は単一化で計算される最も一般的な単一化者であり、`δ* =δ'θ` のような `δ′` が存在します。
  それで我々は得ます

    W(V,Γ,E,(e1 e2)) =  (V2 ∪ α,Γ′,θ′θ2θ1,α),
               θ* E = δ′θ′θ2θ1E,
                 τ* = δ′θ′θ2τ2,
                 Γ* ⊢ δ′ : Γ′,

  最後のステートメントは単一化の完全性から続きます。
  `let x = e1 in e2` : `Γ* ⊢ θ* : Γ` と仮定すると、LET' より

    Σ,Γ*[(αk* : Sk*)~],θ* E ▷ e1 : τ1*
    Σ,Γ*,(θ* E)[x:∀(αk* : Sk*)~ .τ1*] ▷ e2 : τ2*
    ----------------------------------------------
    Σ,Γ*,θ* E ▷ let x = e1 in e2 : τ2*

  ここで、`{(αk*)~} = FV(τ1*) − FV(θ* E)` です。
  アルゴリズムは α 変換の下で不変である(補題5.2)ので、安全に `x ∈/ Dom(E)` と仮定できます。

  `{(αk*)~} ∩ FV(θ* E) = {}`として、`{(αk*)~} ∩ Dom(Γ*) = {}` を想定するために、上記の規則の前提（`(αk*)~`の名前は `Γ'` ではなく）で`(αk*)~`の名前を変更することなく一般性を下げることができます。
  正式には、補題5.5でこれを行うことができます。
  次に、`Γ* [(αk* : Sk*)~] ⊢ θ* : Γ`を用いて `e1` に帰納仮説を適用し、

         W(V,Γ,E,e1) = (V1,Γ1,θ1,τ1),            (22)
                θ* E = δ1θ1E,                    (23)
                 τ1* = δ1θ1τ1,                   (24)
    Γ*[(αk* : Sk*)~] ⊢  δ1 : Γ′1 [(αn : Sn)~],   (25)

  ここで `Γ′1 = Γ1 \ {(αn)~}` かつ `(Sn)~ = (Γ1 αn)~` です。

  `{(αn)~} = FV(θ1τ1) − FV(θ1 E)` から `FV({(δ1αn)~}) = FV(δ1θ1τ1) − FV(δ1θ1E) = {(αk*)~}` と推定します。
  したがって、(25)から`Γ* ⊢ δ1 : Γ′1` が得られます。
  ここで、 `δ̂1 = δ1|(Dom(δ1)−{(αn)~})` とすると、`δ1 ∀(αn :Sn)~ .θ1τ1 = ∀(αn :Sn)~ .δ̂1θ1τ1` Wによって使用される新しい変数は、選択された導出、すなわち `Cod(δ1)` には現れません。
  次に、 `δ1 | {(αn)~}` を用いて、`Σ,Γ* ⊢ δ1 ∀(αn :Sn)~ .θ1 τ1 ⪰ ∀(αk* :Sk*)~ .τ*` 定義3.1の中の代入として `δ1 | {(αn)~}` を代入し、 `Σ,Γ* [(αk* :Sk*)~] ⊢ δ1αi : Si`, `[i = 1 ... n]` は (25)。

  今、問題は、一般的な `(θ* E)[x:∀(αk* :Sk*)~ .τ1* ] /= (δ1 θ1 E)[x:δ1 ∀(αn :Sn)~ .θ1 τ1]` では、帰納仮説を`Γ* ⊢ δ1 : Γ′1` と `θ1 E[...]`で `e2` に直接適用することができないということです。
  したがって、 `e2` の帰納仮説を適用するためには、異なる根拠を見つけなければなりません。

  から

    Σ,Γ* (θ* E)[x:∀(αk* :Sk*)~ .τ1*] ▷ e2 : τ2*  (26)

  推論することができます

    Σ,Γ*,(θ* E)[x:δ1 ∀(αn :Sn)~ .θ1 τ1] ▷ e2 : τ2*,

  (26)の証明で ASM の `x` への各適用において、`[x:∀(αk* :Sk*)~ .τ1*]` の代わりにより一般的な `[x:δ1 ∀(αn :Sn)~ .θ1 τ1]` となります。

  次に、帰納仮説が `e2` に `Γ* ⊢ δ1 : Γ′1` と環境 `θ1 E[x:∀αn :Sn .θ1 τ1]` を適用します。
  
<!-- page 20 -->

  我々は、次のような `δ2` を得ます。

                  W(V1,Γ′1,E,e2) = (V2,Γ2,θ2,τ2),  (27)
    (θ* E)[x:δ1 ∀αn : Sn .θ1τ1] = δ2θ2 (θ1 E[x:∀αn : Sn.θ1τ1]), (28)
                             τ2* = δ2θ2τ2, (29)
                              Γ* ⊢ δ2 : Γ2. (30)
  
  したがって、`W(V,Γ,E,let x = e1 in e2) = (V2,Γ2,θ2,τ2)` となります。
  `τ2* = δ2θ2τ2` と `Dom(θ1) ∩ FV(τ2) = {}`(定理5.3のように)から `τ2* = δ2θ2θ1τ2` を得ます。
  これは(28)の結果である `θ* E = δ2θ2θ1E` を `x ∈/Dom(E)` として表示するだけです。 □

  ここで、最終的に、所望のプリンシパル型定理を示すことができます。

  定理 5.9

  `E` が閉じられた環境 `E` の下で型 `σ0` である、すなわち `Σ,[],E ⊢ e : σ0` かつ `FV(E) ⊆ V0` ならば `W(V0,[],{},E,e) = (V,Γ,θ,τ)` であり、`∀(αn : Γαn)~ .θτ` は `Σ` と`E` を用いて `e` の主要型です。ここで `{(αn)~} = FV(θτ)` とします。

  **証明** いくつかの型の `Σ,[],E ⊢ e : ∀(αm':Sm')~ .τ'` を仮定します。
  `Σ,[αm′ :Sm′], E ⊢ e` を推論します :
  `τ'` を `∀E` で置き換え、構文指向の導出を定理3.4により `Σ,[αm' :Sm'],E ▷ e : τ′` を得ます。
  次に、補題5.8が `Γ* = [αm' : Sm']` と `θ* = {}` に適用されます。
  このようにして、`δ` が得られ

    E   = δE,
    τ′  = δθτ,
    Γ*  ⊢  δ : Γ です。

   そして、 `∀(αn : Γαn)~ .θτ` は `E` に関して `e` の主要な型で、 `τ' = δθτ`, `{(αn)~} = FV(θτ)` から `τ' = δθτ`、 `{(αn)~} = FV(θτ)`、 `Γ* ⊢ δ : Γ` です。 □

## 6 アルゴリズムI

  Milner(Mil78)の元々の作業のように、アルゴリズムWをより効率的に改良しましました。
  Wと比較して、アルゴリズムI 2は余分な議論をとります。
  この代入は、新しい補題を計算して後で構成する代わりに、段階的に拡張されます。

  WとIの同値は簡単なことです。
  名前の変更は、変数を変数にのみマップする注入型の置換です。

  定理6.1(WとIの同値性)

  `θ0`は、`θ0E0= E`となるような冪等置換であるとします。
  もし `W(V,Γ,E,e) = (V′,Γ′,θ′,τ′)` ならば、`I(V,Γ,θ0,E0,e) = (V′′,Γ′′,θ′′,τ′′)` かつ `V′′ = σV′`、 `∀α.Γ′′α = Γ′(σα)`、 `θ′′τ′′ = σθ′τ′`、 `θ′′E = σθ′E` のような改名 `σ` が存在します。

  `e`の構造上の簡単な誘導による証明。 □

  ----

  2(Mil78)のタイポグラフィはあいまいですが、Milnerはメールで、JではなくIであることを意図していることを確認しました: W の必須実装です。
  ミルナーの私は、副作用によって更新される `θ` の1つのグローバルコピーを維持しているので、絶対に必要です。
  純粋に機能的なスタイルでは、これには追加の引数と結果が必要です。

  ----

<!-- page 21 -->

    I(V,Γ,θ,E,e) = case e of
      x    ⇒ let ∀(αn : Sn)~ .τ  =  E(x)
                              βi  ∈/  V [i = 1 ... n]
              in (V ∪ {(βn)~},Γ[(βn : Sn)~],θ,{(αn |→ βn)~}τ)
      λx.e ⇒ let        α ∈/ V
              (V′,Γ′,θ′,τ) = I(V ∪ {α},Γ,θ,E[x:α],e)
              in (V′,Γ′,θ′,α → τ)
      (e1 e2) ⇒ let (V1,Γ1,θ1,τ1) = I(V,Γ,θ,E,e1)
                     (V2,Γ2,θ2,τ2) = I(V1,Γ1,θ1,E,e2)
                                 α ∈/ V2
                           (Γ′,θ′) = unify(Γ2,θ2τ1 = θ2τ2 → α)
                in (V2 ∪ {α},Γ′,θ′θ2,α)
      let x = e1 in e2 ⇒ let (V1,Γ1,θ1,τ1) = I(Γ,θ,E,e1)
                                    {(αn)~} = FV(θ1τ1) − FV(θ1E)
                          in I(V1,Γ1 \ {(αn)~},θ1,E[x : ∀(αn :Γ1 αn)~ .θ1τ1],e2)

  図7. アルゴリズムI

## 7 関連仕事

  アルゴリズムWとIの構造は、Milnerの同じ名前のアルゴリズム(Mil78)の構造に非常に近いです。
  私たちの私のバージョンが純粋に適用可能であるという事実とは別に、私たちは置換と使用された変数のセットを明示的に持ちますが、主な違いは制約のセット `Γ` を維持しなければならないということです。
  実際、これはMilnerのアルゴリズムとの唯一の違いです。

  おそらくMLスタイルの多形性とパラメトリックなオーバーロード(Hope(BMS80)のような有限のオーバーロードとは対照的)の最初の組み合わせはKaes(Kae88)によって提示されましました。
  彼の言葉は実際にクラスを明示的に導入していないことを除いて、私たちのMini-Haskellに非常に近いです。
  さらに重要なのは、型変数に関する情報を記録するためにコンテキストを使用せず、型変数を直接タグ付けすることです。

  後にVolpanoとSmith(V​​S91)が示すように、WadlerとBlott(WB89)が提示した型クラスの元のバージョンは、Haskellのものよりもはるかに強力でしました。
  Haskell との関係は第2章で議論されています。

  Nipkow and Snelting(NS91)は、型クラスの型推論は、順序付き分類型の通常のML型型推論の拡張として、すなわち型の代数と対応する単一化アルゴリズムを単に変更することによって定式化できることを認識しました。
  これは興味深い理論的な洞察でしたが、 Haskell の制限されたバージョンのための単純なアルゴリズムにつながり、各型の変数は厳密に1つのクラスに制約されています。
  さらに、文脈の概念がなく、型変数にその並べ替えがタグ付けされているため、 `Σ,[α:C],E ⊢ e : int` などのあいまいな型を識別することはできませんでしました。
  本論文では両方の問題を解決しましました。

  マーク・ジョーンズ(Jon92b)は、"修飾型" の概念を用いた Haskell の興味深い拡張を設計し実装しましました。
  主な違いは、メンバーシップ制約 `α : S` ではなく、型に対して任意の述語 `P(τ1,...,τn)` を許すことです。

<!-- page 22 -->

  一方、彼は、関数拘束で行われているように、`τ : S` という形式の制約を解いて、`α : S′` の形の原子制約を得ることはできません。
  代わりに、彼は未解決の制約を蓄積します。

  Hudak and Odersky(CHO92)は、独自の研究とは無関係に、同様のテクニックを使用し、同様の型再構成アルゴリズムに到達する型クラスの拡張を開発しましました。
  彼らの型システムはより一般的であるため、特に単一化のために異なる、より複雑な形式を使用します。
  これとは対照的に、単一化を標準統合と制約解決に分割することで、本質への統合を減らします。
  これにより、主体型に必要な単一化単一化のための十分かつ必要な基準を与えることができます。
  セクション4で議論したように、Haskell の制限は単一化単一化を保証します。

  Kaes(Kae92)は、過負荷、亜型、および再帰型のHindley / Milner多型の拡張を示しています。
  結果として生じるシステムの全体的な複雑さのために、過負荷のための純粋なシステムの単純さは失われます。

  型・クラスを実装するための言い回しは、Peterson and Jones(PJ83)によって論じられています。
  特に、それらは可変変数を使用してアルゴリズムIの本当に不可欠なバージョンを実装する方法のヒントを与えます。
  これは、アルゴリズムIの単純な機能的実装、特に、関連リストとしての置換を表すものが非常に不十分に機能するため、非常に重要です。

## 8 あいまいさ

  オーバーロードを伴うほとんどの型システムに影響を与えるあいまい性問題の議論をもってこの論文を終わりにしたいと思います。
  これは、プログラムが固有の型を持つ可能性があるにもかかわらず、そのセマンティクスが明確に定義されていないために発生します。
  私たちのルールによると、プログラム

    class α : C where f : α → int;
    class α : D where c : α;
    (f c)

  仮定は `α : {C, D}` を含む任意の文脈で型 `int` を持ちます。
  しかし、 `f` と `c` のインスタンスが全くないので、プログラムには意味がありません。
  `C` と `D` の両方のインスタンスが複数存在する場合、`(f c)` の式でどちらを使うのかを判断することはできません。

  このような例に動機付けされていると、 `Σ,Γ,E ⊢ e : σ` 型は `Γ` に型変数があり、 `σ` や `E` では空きでないと定義されるのが普通です。

  理想的には、すべての型付き式には明確なセマンティクスがあることを望みます。
  しかしながら、あいまいな用語は、上の例が示唆するように、複数の意味論を有するかもしれません。
  幸いにも、Blott(Blo92)とJones(Jon92a)は、この論文で研究された型システムと密接に関連する型システムでは、明確な用語のセマンティクスは実際には明確に定義されていることを示しています。

  私たちの言語のためのセマンティクスを提供していないので、我々は形式的にあいまいさを導入していません。
  それにもかかわらず、あいまいさの特定の扱いが予想される私たちの推論システムには1つの場所があります。
  ルール `∀I` では、条件曖昧性の問題を伝播させることを目的としている:この制約により、`let x = (f c) in 5`(クラス `C` と `D` 上で宣言したように)は、仮定 `α : {C, D}` を含む文脈でのみ `int` 型を持ちます。

<!-- page 23 -->

  条件が破棄されると、式は空のコンテキストに `int` 型を持ち、局所的なあいまいさを隠します。
  その理由は、 `x` はあいまいな型 `∀α:{C, D}.int` を与えることができますが、 `x` は 5 にはないので、これは問題ではありません。
  怠惰な言語では `x` を評価する必要はないので、`let` 全体の意味は確かに曖昧ですが、実際的な理由から、あいまいさが発生するたびにフラグを立てることをお勧めします。

  この議論から、セマンティクスに関して型システムの意味論と一貫性の証明が緊急に必要であることは明らかです。

  **謝辞** 著者は批判的な読解と彼らの有益なコメントのために匿名の審判員に感謝します。

## References

  Stephen Blott. An approach to overloading with polymorphism. PhD thesis, Dept. of Computing Science, University of Glasgow, 1992.

  Rod Burstall, Dave MacQueen, and Don Sannella. Hope: an experimental applicative language. In Proc. 1980 LISP Conference, pages 136–143, 1980.

  Dominique Clément, Joëlle Despeyroux, Thierry Despeyroux, and Gilles Kahn. A simple applicative language: Mini-ML. In Proc. ACM Conf. Lisp and Functional Programming, pages 13–27, 1986.

  Kung Chen, Paul Hudak, and Martin Odersky. Parametric type classes. In Proc. ACM Conf. on LISP and Functional Programming, pages 170–181. ACM Press, June 1992.

  Luis Damas and Robin Milner. Principal type schemes for functional programs. In Proc. 9th ACM Symp. Principles of Programming Languages, pages 207–212, 1982.

  Paul Hudak, Simon Peyton Jones, and Philip Wadler. Report on the programming language Haskell: A non-strict, purely functional language. ACM SIGPLAN Notices, 27(5), May 1992. Version 1.2.

  Mark P. Jones. Qualified types: Theory and practice. D.Phil. Thesis, Programming Research Group, Oxford University Computing Laboratory, July 1992.

  Mark P. Jones. A theory of qualified types. In Bernd Krieg-Brückner, editor, Proc. European Symposium on Programming, pages 287–306. LNCS 582, 1992.

  Stefan Kaes. Parametric overloading in polymorphic programming languages. In Proc. 2nd European Symposium on Programming, pages 131–144. LNCS 300, 1988.

  Stefan Kaes. Type inference in the presence of overloading, subtyping and recursive types. In Proc. ACM Conf. LISP and Functional Programming, pages 193–204. ACM Press, June 1992.

  Robin Milner. A theory of type polymorphism in programming. J. Comp. Sys. Sci., 17:348–375, 1978.

  Robin Milner, Mads Tofte, and Robert Harper. The Definition of Standard ML. MIT Press, 1990.

  Tobias Nipkow and Christian Prehofer. Type checking type classes. In Proc. 20th ACM Symp. Principles of Programming Languages, pages 409–418. ACM Press, 1993.

  Tobias Nipkow and Gregor Snelting. Type classes and overloading resolution via order-sorted unification. In Proc. 5th ACM Conf. Functional Programming Languages and Computer Architecture, pages 1–14. LNCS 523, 1991.

  John Peterson and Mark Jones. Implementing type classes. In Proc. SIGPLAN ’93 Symp. Programming Language Design and Implementation, pages 227–236. ACM Press, 1983.

<!-- page 24 -->

  Dennis M. Volpano and Geoffrey S. Smith. On the complexity of ML typability with overloading. In Proc. 5th ACM Conf. Functional Programming Languages and Computer Architecture, pages 15–28. LNCS 523, 1991.

  Philip Wadler and Stephen Blott. How to make ad-hoc polymorphism less ad hoc. In Proc. 16th ACM Symp. Principles of Programming Languages, pages 60–76, 1989.
