# パラメトリック型クラス

  <!-- TODO>>> ∀∪⊎∈∉≠⊆<⊢⊦⊦≼≥>⇒`Γ`Δ`α`β`γ`σ`τ`λ`κ`≃ -->

  (拡大要約)

  カン・チェン、ポール・フダク、マーティン・オデスキー

  イェール大学、コンピュータサイエンス学科、

  Box 2158 Yale Station、New Haven、CT 06520

  ACM Conf. LISPと関数型プログラミング、1992年6月

## 要約

  我々は、クラスがプレースホルダ変数の他に型パラメータを持つことができる Haskell の型クラスへの一般化を提案します。
  オーバーロードされたデータコンストラクタとセレクタ操作でコンテナクラスを表すには、この一般化が不可欠であることを示します。
  また、得られた型システムには主要型と現在の単一化型再構成アルゴリズムがあります。

## 1 はじめに

  Haskellの型クラスは、オーバーロードされた関数を導入するための構造化された方法を提供し、おそらく言語設計[HJW91]の最も画期的な(やや議論の多い)側面です。
  型クラスは、オーバーロードされた演算子の定義を、基本的なHindley-Milner型システムと完全に統合された、厳密かつ(かなり)一般的な方法で行うことを可能にします。
  その結果、他の型付き言語で単相性の演算子には、より一般的な型を与えることができます。
  例には、数値演算子、任意のデータ型の読み書き、および等価、順序付けなどの比較演算子が含まれます。

  Haskellの型クラスは非常に有用であることが証明されています。
  しかし、特に欠けているのは、データの選択と構築のためにオーバーロードされた機能です。
  このようなオーバーロードされた関数は非常に便利ですが、現在のHaskell型システムは、それらをサポートするのに十分な表現力ではありません(もちろん、型セーフな方法でそれらをサポートできるかどうかわかっている他の言語はありません)。

  ----

  \* この研究は、DARPAとONRの契約によって支援されました
  N00014-90-C-0024およびN00014-91-J-4043である。

  ----

### 動機づけの例

  簡単な例として、シーケンスの概念を考えてみましょう。
  すべて同じ型の要素の線形に順序付けられたコレクションです。
  シーケンス、リンクリスト、およびベクトルの少なくとも2つの合理的な実装があります。
  これらの表現の1つを選択する際の効率のトレードオフがあります。
  リストは新しい要素の効率的な追加をサポートし、ベクトルは効率的なランダム(並列)アクセスをサポートします。
  現在、表現の選択はプログラミング言語レベルで行われています。
  ほとんどの関数型言語はリストを `コア` データ構造体(しばしばそれらをサポートする特殊な構文)として提供し、配列をやや第二級の状態にします。
  SisalやNialなどの他の言語では、この選択を逆にし、リストの代わりに配列の特殊な構文を提供します(これは、並列および/または科学計算への偏見を反映することが多い)。

  もちろん、両方の "コンテナ構造"に等しく重点を置く言語を設計することは可能です。
  しかし、単純なアプローチでは、シーケンスのすべての関数をリストのために1回、配列のために1回、2回実装しなければならないという問題に直面しています。
  この名前空間汚染と重複したコードの明白なソリューションは、オーバーロードです。
  我々の文脈では、シーケンスの概念を(少なくとも)リストとベクトルをインスタンス型として持つ型クラスとして指定することを意味します。
  Haskellのような表記を使用すると、これは次の宣言になります。

    class Sequence a s
    where cons :: a -> s -> s
          nth  :: s -> Int -> a
          len  :: s -> Int

    instance Sequence a (List a)
    where cons = (:)
          nth  = (!)
          len  = (#)

    instance Sequence a (Vector a)
    where cons = vecCons
          nth  = vecNth
          len  = vecLen

  これは、オーバーロードされたコンストラクタcons、オーバーロードされたインデックスセレクタnth、およびlength関数lenを定義します。
  (オブジェクト指向プログラミングの "コンテナクラス"と似ていることに注意してください)。

  このコードの唯一の問題は、Haskellの型クラスが1つの型だけを制約することが許されているため、 "class Sequence a s"のような宣言を排除するため、Haskellが有効でないことです。
  本質的には、この制限により、オーバーロードされたコンストラクタとセレクタは強制的に単調
  (それは彼らをかなり無駄にする)。

  <!-- page 2 -->

  この制限が存在しない場合でも、現在の型クラスのメカニズムには別の問題があります。これは、lenの型指定によって示されます。

    Sequence a s => s -> Int

  複数引数型のクラスが許されていても、この修飾された型はあいまいなのでHaskellでは有効ではありません:
  型変数aはコンテキスト(Sequence a s)で出現しますが、型部分固有ではありません(s→Int)。
  あいまいな型は、矛盾する可能性がある実装が複数あるため、拒否する必要があります。

  オーバーロードされたマップ関数を含むように例を拡張すると、関連するがより困難な問題が発生します。
  このような関数を持つことは、結合およびフィルタと共に、リストだけでなくシーケンスのすべてのインスタンスを含むように `リストの理解` の概念を一般化(すなわち過負荷)することを可能にするので、魅力的である。
  第7節では、これを詳しく説明し、バッグやリストなどのクラスモナドの任意のインスタンスについての理解にさらに拡張します。
  結局のところ、セットの領域は `理解` 表記がどこから来たかということから、これはかなり自然なようです。
  しかし、マップの型を指定しようとするとすぐに問題が明らかになります。

    map: (Sequence a sa, Sequence b sb)
        => (a -> b) -> sa -> sb.

  この型はあまりにも一般的です。これは、1つのシーケンス型(例えばリスト)を取り、別のシーケンス(例えばベクトル)を返す実装も認められるためです。
  一般性は、この文脈では再び曖昧さにつながるため、費用がかかる。
  例えば、関数のコンポジション `(map f。map g)`はあいまいです。囲み式の型に現れない `map g`の型は、リストかベクトルのどちらかです。

  必要なのは、そのマップが引数と同じ種類のシーケンスを返しますが、要素の型が異なる可能性があることを指定する方法です。
  この型を通知する良い方法は次のとおりです:

    map: Sequence (s a) => (a -> b) -> s a -> s b

  sは型の代わりに型のコンストラクタに渡る変数です。
  これに対応するために、Sequenceは型クラスの代わりに型コンストラクタクラスとして表示されるようになりました。
  しかし、インスタンスの関係はファンクタレベルで表現されるため、型を再構築するために二次単一化が必要であり、システムを決定不能にする危険性がある(Lil91で推測されているように)。

### 我々の貢献

  これらの問題を解決するために、Haskellの型クラスの重要な一般化としてパラメトリック型クラスの概念を導入する。
  我々の貢献は以下のように要約できます:

  1. パラメトリック型クラスは、制約付き型変数に加えて型引数を持つことができるため、先に定義したSequenceなどのクラスを表現することができます。

  2. 単純な符号化スキームを介して、パラメトリック型のクラスは "型コンストラクタ変数"という概念を取り込めるため、マップなどのオーバーロードされた演算子を定義できることを示しています。

  3. パラメトリック型クラスは、Haskellの型システムを控えめに拡張したものです。

    すべてのクラスにパラメータがない場合、2つのシステムは同等です。

  4. 我々のシステムは決定可能であると証明し、有効な型推論アルゴリズムを提供する。

  5. システムのパワーと実用性の具体的なデモンストレーションとして、モナドへのリストの理解の概念を一般化することを可能にするクラスのモナドとモナドを定式化する。

    これは、リスト内包表記の標準翻訳ルールを使用して行われます。 特殊な構文は必要ありません。

### 関連研究

  WadlerとBlott [WB89]は型クラスを導入し、それらを組み込んだHindley-Milner型システムの拡張を示しました。
  彼らは、オーバーロード関数の型を指定するために、述語型と呼ばれる新しい型の型を提案しました。
  シンボリック計算のためのScratchpad IIシステムのカテゴリの名前の下で全く同じ概念が使用された[JT81]。
  パラメトリックオーバーロード[Kae88]、オブジェクト指向プログラミング[CCH + 89]、および[Rou90]におけるF境界限定多形性に関するKaesの作業も関連しています。
  型クラスの考え方は、Haskellの設計ですぐに取り上げられました。
  しかし、その理論的基盤は発展するのに時間がかかりました。
  [WB89]の最初のアプローチは、Haskell自体よりも強力な型システムにおけるHaskellのソースレベル構文をコード化しました。これは、複数の型にまたがるクラスを収容できるからです。
  しかし、この表現力の向上は、VolpanoとSmith [VS91]によって検討されているように、決定不能につながる可能性がある。
  確かに、[WB89]に掲載されたシステムは明らかに決めることができない。

  一方、Haskellのソースレベルの構文には、デシジョン可能性を保証するのに十分な数の静的制約があります。
  これは[NS91]に示されています.NipkowとSneltingは、3レベルの値、型、および部分的に順序付けされたソートの型クラスをモデル化しました。
  それらのシステムでは、クラスはソートに対応し、型はクラス階層に従ってソートされます。
  順序のソートされた統合[MGS89]は、型の再構築時のオーバーロードを解決するために使用されます。
  順序ソート手法の使用は数学的にはエレガントですが、クラス間の順序関係は構文メカニズムであり、型クラスの型システムを開発するためには必要ではないと主張しています。
  さらに、提案された拡張を組み込むためにシステムを拡張する方法は明らかではない。

  型クラスの概念を複数の型にわたる述語に拡張する作業も行われました。
  VolpanoとSmith [VS91]は、型再構築の決定可能性を保証し、よく型された表現のシャープな概念を得るために、[WB89]の元のシステムの修正を検討しました。
  Jones [Jon91、Jon92b]は、修飾型の一般的なフレームワークを提供しました。
  彼の述語セットの使用は、我々の文脈制約型インスタンス理論に非常によく似ています。
  2つのアプローチの主な違いは、通常のフォーム(ジョーンズはこの問題に対処していない)と制約付き変数と従属変数の区別です。
  この違いにより、コンテナクラスの定義で以前に遭遇したあいまい性の問題を解決できます。

  <!-- page 3 -->

  本論文の残りの部分は以下のように構成されている。第2節ではパラメトリック型のクラスを紹介する。
  第3節では、非決定論的な型のシステムにおいて正式にそれらを提示する。
  セクション4は、非決定論的システムと型再構築アルゴリズムとの間のギャップを埋める同等の構文指向システムを提示する。
  5章では、型の再構成と単一化について述べる。
  第6章では、型スキームがあいまいであるときについて説明します。
  第7節では、モナドをパラメトリッククラスとして定義する際にシステムを適用する。
  セクション8は結論づけられる。

## 2 パラメトリック型クラス

  パラメトリック型クラスは、クラス宣言に常に存在するプレースホルダ変数に加えて型パラメータを持つクラスです。
  プレースホルダと型パラメータを区別するために、クラスの前にプレースホルダを挿入 `(::)` で区切って記述します。
  例えば:

    class t :: Eq where
    class s :: Sequence a where

  最初の定義では、パラメータを持たないクラスが導入されています。Haskellではこれはクラス `Eq t` と書かれます。
  2番目の定義は、1つのパラメータを持つ型クラス `Sequence` を定義します。これは標準の Haskell では表現できません。
  中置の `(::)` 表記は、インスタンスの宣言と文脈でも使われます。

  最後のセクションで提示された `Sequence` の2つのインスタンス宣言は次のようになります。

    inst List a   :: Sequence a where ...
    inst Vector a :: Sequence a where ...

  `T :: Sequence a` という形式のインスタンス宣言では、`T` 型は変数であってはなりません。
  さらに、 `T1` と `T2` の2つの型が両方とも `Sequence` のインスタンスとして宣言されている場合、その最上位型のコンストラクタは異なる必要があります。
  したがって、上記のインスタンス宣言は両方とも有効です。
  一方、

    inst a :: Sequence (List a)

  最初の制限に違反し、

    inst List Int :: Sequence Int
    inst List Char :: Sequence Char

  2番目の制限に違反します。
  効果的には、これらの制約により、インスタンス関係の証明では、すべてのステップがクラス名とプレースホルダ位置の型によって決まることが保証されます。
  一方、クラスパラメータ型は、プレースホルダ型によって異なります。

  これらの制限の1つの結果は、型がクラスのインスタンスであることを推論する方法が1つしかないということです。
  これは_coherence_を保証するために必要です。
  型があいまいなので十分ではありません。 6章を参照してください。
  もう一つの結果は、インスタンス述語のセットが現在_consistency_ criterionの対象になっているということです: `T :: Sequence a` と `T :: Sequence b` の両方を持つ場合、 `a = b` を持たなければなりません。
  つまり、 `a = b` は2つのインスタンス述語の論理的帰結であり、インスタンス宣言に対する制限です。
  型再構築アルゴリズムは、この状況において、 `a` と `b` を単一化することによって一貫性を強制する。

  整合性を早期に適用すると、型を小さく保つのに役立ちます。
  さもなければ、型に多くの余分なインスタンス制約を与えることができます。
  例として、 `(tl . tl)` という構成を考えてみましょう。ここで、tlは `(s :: Sequence a)=> s -> s` です。
  一貫性の要求がなければ、コンポジションの最も一般的な型は (`s :: Sequence a, s :: Sequence b) => s -> s` です。
  `tl n` 回合成すると、`n` 個のシーケンス制約を持つ型が生成されます。

## 3 パラメトリッククラスの型システム

  このセクションでは、正式に型システムを紹介します。
  最初に、小さなサンプル言語のコンテキストで、クラスと型の抽象構文を定義します。
  次に、型がクラスのインスタンスであることを正式に説明します。
  これらの定義に基づいて、我々は[DM82]と同じ6つの規則を持つ非決定論的型システムを定義するが、パラメトリック型クラスを追加する。
  一般性が増したにもかかわらず、システムは実際には標準のHaskellの以前に公開された型のシステムよりも単純であると主張する。

  紙面の都合上、このセクションと次のセクションで示されている結果の詳細な証明については、[COH92]を参照してください。

### 構文

  サンプル言語は、パラメータ化された型クラスで補完されたMini-Haskell [NS91]の変種です。
  その抽象構文と型を図1に示します。

    Type variables     α
    Type constructors  κ
    Class constructors c
    Types              τ ::= () | κ τ | α | τ1 * τ2 | τ1 -> τ2
    Type schemes       σ ::= ∀α::Γ.σ | τ
    Type classes       γ ::= c τ
    Class sets         Γ ::= {c1 τ1,..., cn τn}       (n ≥ 0,ci pairwise disjoint)
    Contexts           C ::= {α1::Γ1, ..., αn::Γn} (n ≥ 0)

    Expressions        e ::= x | e e' | λx : e | let x = e' in e
    Programs           p ::= class α::γ where x : σ in p
                        |  inst C ⇒ τ::γ where x = e in p
                        |  e
    
  図1: Mini-Haskell+ の抽象構文

  この構文におけるパラメトリック型クラス `γ` は、 `c τ` の形式を有し、ここで `c` は Haskell のクラスに対応するクラスコンストラクタであり、 `τ` は型です。
  いくつかのパラメータを持つクラスはタプル型を使用してエンコードされます。
  `c(α、β)`である。
  パラメータのないクラスは、ユニット型を使用して符号化される。
  `Eq()`
  型と型クラスとの間のインスタンス関係は `inix(::);述語`τ ':: cτは ``τ``が `cτ`のインスタンスです。

  標準的なHaskellに関する1つの単純化は、クラスに階層がないことに関係しています。
  代わりに、サブクラス/スーパークラスの関係は、クラスセット `Γ` によってモデル化される。
  たとえば、Haskellの等価型クラス `Eq()`と、順序付けられた型の `Ord()`というサブクラスを考えてみましょう。
  `Ord()`は `Ord()`で定義された `(<、≤)`演算のみを含む `{Eq()、Ord `Eq`ではなく。
  このようにしてプログラム内のすべてのクラスを翻訳すると、クラスのフラットなドメイン上のセットで終わります。
  これは、一般性を失うことなく、抽象構文でクラス階層を無視できることを示しています。

### インスタンス理論

  このセクションでは、型 `τ` がクラス集合 `Γ` のインスタンスであるときに、 `τ::Γ` を表現するという事実を正確にします。
  明らかに、インスタンス関係は、プログラム中のインスタンス宣言 `D` に依存します。
  これらの宣言は、文が `C ⊦⊦ τ::γ` のインスタンス判定であるという理論を生みだします。
  インスタンスの判断は、図2の推論ルールを使用して推論することができる場合には、理論に当てはまります。

  <!-- page 4 -->

    C ⊦⊦ α :: γ     (α::{...γ...} ∈ C)

    C ⊦⊦ C'
    ---------    ("inst C' ⇒ τ::γ" ∈ Ds)
    C ⊦⊦ τ::γ

    C ⊦⊦ τ::γ1   ...   C ⊦⊦ τ::γn
    -----------------------------    (n ≥ 0)
    C ⊦⊦ τ:: {γ1 ,..., γn}

    C ⊦⊦ τ1::Γ1   ...   C ⊦⊦ τn::Γn
    ------------------------------------ (n ≥ 0)
    C ⊦⊦ {τ1::Γ1,  ...  ,fτn::Γn}

  図2: 束縛の推論規則

### 文脈 Context

  これらの規則では、文脈 `C` は、(全て `C` の `α` は互いに素である)インスタンス仮定 `α::Γ` の集合です。
  便利な場合には、コンテキストを型変数からクラスセットへの有限写像、すなわち `α::Γ∈C` ならば `Cα=Γ` とみなします。
  したがって、 `C` の領域、 `dom(C)` は、 `α::Γ∈C` となるような型変数 `α` の集合として定義されます。
  型クラスはパラメータを含むことができるので、コンテキスト `C` の領域の定義は

      reg(C) = ∪_{α ∈ dom(C)} fv(C)

  かつ `C*(Δ)` と書かれた型変数の集合 `Δ` に対する `C` のクロージャは方程式の最小固定点として、

    C*(Δ) = Δ ∪ C(C* (Δ))

  です。 `α ∈ dom(C1)` のそれぞれにおいて 、`dom(C1) ⊆ dom(C2)` かつ `C1α ⊆ C2α` ならば、 `C1≼C2` と書き、`C1`は`C2`に含まれると読みます。
  我々は、2つのコンテキストの互いに素な結合を `C1 ⊎ C2` と `α` 以外のすべての型変数への文脈 `C` の制限を `C\α` と書きます。
  文脈 `C` は `C*(dom(C)) = dom(C)` ならば閉じられ、等価的には `reg(C) ⊆ dom(C)` と呼ばれます。
  全ての型変数 `α` で、 `α ∈ fv (C β)` の場合に `α ∈ dom(C)` を次の順序に従ってトポロジソートすることができれば、コンテキスト `C` は非循環と呼ばれます。
  我々は、この論文の残りの部分では、閉鎖非環式文脈のみに限定して説明します。

### 制約付き置換

  以下では、型だけでなく、クラス(の集合)およびインスタンス述語(の集合)にも変数置換を適用します。
  これらの全てにおいて、置換は個別に定義されます。
  例えば、集合、クラスコンストラクタ関数適用、 `(::)` の準同型性です。
  コンテキストはインスタンス述語セットの特別な形式なので、置換はコンテキストに適用できます。
  しかしながら、インスタンス述語 `α::Γ` の左側の `α` は非変数型に map できるので、そのような置換の結果は一般に文脈ではありません。
  一方、我々の型付け規則は、一般述語集合の代わりに文脈を必要とします。
  したがって、述語集合に対する控えめな近似である文脈を見つける手段が必要です。
  以下の定義を使用します:

  **定義** 制約付き置換は pair `(S,C)` です。ここで `S` は置換で、 `C` は `C = SC` のような文脈です。

  **定義** 制約付き置換 `(S, C)` は、 `S = R o S0` と `C ⊦⊦ RC0` のような置換 `R` がある場合、制約付き置換 `(S0, C0)` を保ちます。
  この場合、 `(S, C) ≼ (S0, C0)` と書きます。

  <!-- page 5 -->

   `≼` が前順序であることを示すのは簡単です。

  **定義** 制約付き置換 `(S,C)` が `R` を満たしていれば何らかの要件 `R` を満たす制約付き置換の中で最も一般的なものであり、任意の `(S',C') で `(S',C') ≼ (S',C')` を満たします。

  **定義** 制約付き置換 `(S,C)` は、`C ⊦⊦ SP` ならばインスタンス述語集合 `P` の正規化子(normalizer)です。

  パラメトリック型クラスを持つ型システムの主要型の性質を保証するために、含意関係 `⊦⊦` に以下の要件を課す必要があります。

  - **単調性:** 任意のコンテキスト `C` と `C'` で、 `C' ≼ C` ならば `C ⊦⊦ C'` です。

  - **置換の下での推移性:** 任意の置換 `S`、 文脈 `C` および `C'`、 述語集合 `P` において、 `C ⊦⊦ SC'` かつ `C' ⊦⊦ P` ならば `C ⊦⊦ SP` です。

  - **最も一般的な正規化子** 述語集合 `P` が正規化子を持つならば、それは最も一般的な正規化子を持ちます。


  型の再構築の観点からは、いったん確立された同義語が後の文脈への置換または追加によって改竄されないようにするために、最初の2つの要件が必要です。
  これらは図2の推論規則に直接従います。
  最後の要件は、含意制約に対する最も一般的な解決策が存在することを保証します。
  最も一般的な正規化子の存在を証明するためには、プログラムのインスタンス宣言に2つの制限を設ける必要があります。

  (a) `inst C ⇒ α :: c τ` という形式のインスタンス宣言はありません。

  (b) 型とクラスのコンストラクタ `(κ, c)` のすべての対に対して、 `inst C ⇒ κ τ':: c τ` という形式のインスタンス宣言が最大で1つあります。さらに、`τ` はユニット型、または異なる型変数と `dom(C)` と `fv(τ)` の両方の可能な空のタプルは `fv(τ')` に含まれています。

  制限(a)は現在の Haskell の一部であり、制約(b)はパラメトリック型クラスを組み込むための現在のHaskellの制限の直接的な一般化です。

  **定理3.1** プログラムのインスタンス宣言 `Ds` が制約(a)と(b)を満たす場合、 `⊦⊦` は最も一般的な正規化を認めます。

### 型付け規則

  文脈とインスタンス述語との間に付随関係 `⊦⊦` があると仮定して、今我々は型付け判定の理論を形式化します。
  型付け判定は、 `A,C ⊢ e : σ` という形であり、 `A` は述語 `x : σ` (すべて `x` は互いに素) であり、`C` は文脈であり、`e` は式またはプログラムです。
  図3と図4の推論規則を用いて推論することができるならば、型判断 `A,C ⊢ e : σ` が理論を保ちます。

    (var)       A,C ⊢ x : σ    (x : σ ∈ A)

                A,C ⊢ e : ∀α::Γ.σ    C ⊦⊦ τ::Γ
    (∀-elim)   --------------------------------
                A,C ⊢ e : [α -> τ] σ

                A,C.α::Γ ⊢ e : σ
    (∀-intro)  ------------------------ (α ∉ fv A ∪ reg C)
                A,C ⊢ e : ∀α::Γ.σ
    
                A,C ⊢ e :τ' -> τ    A,C ⊢ e' : τ'
    (λ-elim)    --------------------------------
                A,C ⊢ e e' : τ

                A.x:τ',C ⊢ e : τ
    (λ-intro)   --------------------------------
                A,C ⊢ λx.e :τ' -> τ

                A,C ⊢ e' : σ    A.x : σ,C ⊢ e : τ
    (let)       --------------------------------------
                A,C ⊢ let x = e' in e : τ

  図3: 式の型付け規則

  図3の規則は、標準の Hindley/Milner システム[DM82]の行に沿って、式のための非決定論的型システムを形成します。
  このシステムと標準的な Hindley/Milner システムとの間の注目すべき違いは、型スキーム `∀α::Γ.σ` の束縛された変数は、文脈から `τ::Γ` (規則 ∀-elim) です 。
  2番目の違いは規則 (∀-intro) であり、一般化された変数 `α` のインスタンス述語は文脈から `排出` され、型スキーム `∀α::Γ.σ` に移動します。

                A.x : ∀_{fvγ} ∀α :: {γ}.σ, C ⊢ p : τ
    (class)     -------------------------------------------
                A,C ⊢ class α :: γ　where x : σ in p : τ

                A,C ⊢ x : ∀α :: {γ} :σ    A,C ⊢ e :[α ->τ'] σ    A,C ⊢ p : τ
    (inst)      --------------------------------------------------------------
                A,C ⊢ inst C' ⇒ τ'::γ where x = e in p : τ

  図4: 宣言の型付け規則

  図4の規則は、このシステムを式からプログラムまで拡張しています。
  規則(class)では、オーバーロードされた識別子 `x` が仮定集合に追加されます。
  規則(inst)は、オーバーロードされた識別子とそのインスタンス式の間の互換性要件を表します。
  これらの規則は、前のサブセクションにリストされているインスタンス宣言についての要件(a)、(b)と関連して取られなければなりません。
  もしも `Ds` が これらの条件を満たし、包含関係 `⊦⊦`、 `A0,{} ⊢ p : σ` を生成する（ここで初期仮定は `A0` に設定されます。）ならば、プログラム `p = Ds e` は 型スキーム `σ` を持つといいます。

### インスタンス関係と主要型スキーム

  Hindley/Milner 型システムについての有益な事実は、式 `e` が型を持つとき、汎用インスタンスの概念を通した `e` に導き出せる他のすべての型の集合を取り込む主要型スキームがあるということです。
  このセクションの残りの部分では、我々のシステムにおける一般的なインスタンスと主要型スキームの定義を紹介します。

  **定義** 型スキーム `σ' = ∀αj' :: Γj'.τ'` は、文脈 `C` の下での型スキーム `σ = ∀αi::Γi.τ` の一般的なインスタンスです。 `Sτ = τ'` のような `{αi}` に置換 `S` が存在する場合、 `αj'` は `σ` と `C ⊎ {αj' :: Γj'} ⊦⊦ Sαi :: SΓi` で自由ではありません。
  この場合、 `σ' ≼C σ` と書きます。

  `≼C` の定義は [DM82] で定義された順序関係の拡張です。
  パラメトリック型クラスを持つ拡張では、インスタンスの含意に関する唯一の新しい要件が必要です。
  `≼C` が型スキーム集合のプリオーダを定義することは容易に分かります。

  次の性質は、定義から直接得られます。

  **補題3.2** `σ' ≼C σ` かつ `C ≼ C'` ならば、 `σ' ≼C' σ` です。

  次の補題は、型スキームの順序付けが制約のある置換によって保持されることを示しています。

  **補題3.3** `σ' ≼C σ` かつ `C' ⊦⊦ SC` の場合、`Sσ' ≼C' Sσ` です。

  型スキームの順序付けの定義によって、我々のシステムにおける主要型スキームの概念を定義することができます。

  **定義** `A`、 `C`、 `e` が与えられたとき、 `A,C ⊢ e : σ` ならば `A` と `C` の間で `e` の主要型スキームを `σ` と呼び、 すべての `σ'` で `A,C ⊢ e : σ'` ならば `σ' ≼C σ` です。

  次のセクションでは、主要型スキームを計算するアルゴリズムを開発します。

## 4 決定論的型推論システム

  この節では、決定論的型推論システムを示します。
  セクション3の型規則と比較して、ここでの規則は、与えられた式 `e` の型推論が `e` の構文構造によって一意的に打ち切られ、したがって型推論アルゴリズム。
  システムは、表現力の面で前のものと同等であり、さらに、型再構成アルゴリズムの構築に向けて優れた特性を有することを示しています。

  <!-- page 6 -->

### 決定論的型付け規則

  決定論的システムの型付け規則は図5に示されています。

    (var')      A,C ⊢' x : τ    (x : σ ∈ A, τ ≼C σ)

                A,C ⊢' e : τ' -> τ    A,C ⊢' e' : τ'
    (∀-elim')  ------------------------------
                A,C ⊢' e e' : τ

                A.x : τ', C ⊢' e : τ
    (∀-intro') -----------------------
                A,C ⊢' λx.e : τ' -> τ
    
                A,C ⊢' e' : τ'    A.x : σ,C ⊢' e : τ
    (let')      ---------------------------------------- (σ, C'') = gen(τ',A,C'), C'' ≼ C
                A,C ⊢' let x = e' in e : τ

  ## 図5: 式の決定論的型付け規則

  `∀-intro` と `∀-elim` 規則は削除され、型判定は `A,C ⊢ e : τ` の形式になりました。ここで、型定義の型スキームセクション3の判断です。
  他の主な違いは、 `(var')` 規則はジェネリックインスタンスの定義に従って型スキームをインスタンス化し、 `(let')` 型スキームを導入するために汎化関数 `gen` を使用することです。

  関数 `gen` は、型スキーム、仮説集合、および文脈を引数として取り、一般化された型スキームと排出されたコンテキストを返します。
  関数 `gen` は以下のように定義されます:

    gen (σ,A,C) =
        if ∃α ∈ dom(C) \ (fv A ∪ reg C) then
            gen (∀α :: C α.σ,A,C\α)
        else (σ,C)

  言い換えれば、仮説セット内の制約型変数を除いて、与えられた文脈におけるインスタンス仮定は、型変数が適切に定量化されるように、より一般的な型スキームを形成するために放電され、移動されます。

### 2つのシステムの等価性

  ここで、決定論的型システムの多くの有用な特性を提示します。
  それらは、2つの型システムの合同性を確立するだけでなく、型システムと型再構成アルゴリズムとの間の関係を調べる際にも有用です。

  **補題4.1** (置換補題) もし `A,C ⊢' e : τ` かつ `C' ⊦⊦ SC` ならば `SA,C' ⊢' e : Sτ` です。

  この結果は、制約のある置換のもとで型の導出が保持されることを保証します。

  次の2つの補題は、文脈と仮説セットに関する型付け導出の単調性の形を表します。

  **補題4.2** もし `A,C ⊢ e : τ` と `C ≼ C'` ならば `A,C' ⊢' e : τ` です。

  **補題4.3** もし `A.x : σ,C ⊢ e : τ` かつ `σ ≼C σ'` ならば `A.x : σ',C ⊢ e : τ` です。

  ここで、決定論的システム `⊢'` は、以下の意味での非決定論的システム `⊢` と同等であることを示すことができます。

  **定理4.4** `A,C ⊢' e : τ` ならば `A,C ⊢ e : τ`。

  **定理4.5** `A,C ⊢ e : σ` ならば、`C ≼ C'`, `A,C' ⊢' e :τ` かつ `σ ≼C σ'` のような型と文脈 `C'` が存在します。ここで `(σ',C'') = gen (τ,A,C')` です。

  <!-- page 7 -->

## 5 単一化と型再構築

  このセクションでは、型再構築について説明します。
  いつものように、型再構築は単一化に依存します。まず、パラメトリック型クラスにはどのような単一化が必要かを考えます。
  次に、型再構築アルゴリズムを示し、最後のセクションの規則とそこに確立された等価な結果を使用して、セクション3で与えられた推論規則に関してその健全性と完全性を述べます。
  これらの結果の結果として、我々は[DM82]のものと類似の我々のシステムの主要型スキーム特性を得ます。
  型再構築アルゴリズムは Yale Haskell コンパイラで実装されています。
  そのサイズと複雑さは、以前の Haskell コンパイラの型再構築部分と比較して優れています。

### 文脈保存単一化

  型の再構築は、通常、最も一般的な型を計算するために単一化に依存します。
  規則(∀-elim)の結果の1つは、型への変数の置換がすべて、与えられたインスタンス制約を満たすわけではないので、Robinson [Rob65]のよく知られている構文単一化アルゴリズムを使うことができないということです。
  NipkowとSneltingは、Haskell [NS91]で型の再構成に順序ソートされた単一化を使用できることを示していますが、その結果をパラメトリック型クラスに拡張する方法は明確ではありません。
  このセクションでは、図6に示すアルゴリズムmguが2つの型の最も一般的な文脈保存 unifier を生成することを示します。

    mgu : τ -> τ -> S * C -> S * C
    mgn : τ -> Γ -> S * C -> S * C

    mgu τ1 τ2 (S,C)           = mgu' (Sτ1) (Sτ2) (S,C)

    mgu' α α                  = id_{S*C}
    mgu' α,(S,C) | α ∉ fv (τ) = mgn τ (Cα) ([α->τ] o S,[α->τ] C\α)
    mgu' ,α (S,C)             = mgu α (S,C)
    mgu' () ()                = id S C
    mgu' κ τ κ τ' (S,C)       = mgu τ τ' (S,C)
    mgu' (τ1,τ2) (τ1,τ2)      = (mgu τ1 τ1') o ( mgu τ2 τ2')
    mgu' (τ1->τ2) (τ1->τ2)    = (mgu τ1 τ1') o ( mgu τ2 τ2')

    mgn τ {}                  = id_{S*C}
    mgn τ {γ} (S,C)           = mgn' (Sτ) (Sγ) (S,C)
    mgn τ (Γ1 ∪ Γ2)          = (mgn τ Γ1) o (mgn τ Γ2)

    mgn' α c τ (S,C)          = if ∃τ: (c,2 C α) then mgu,fi (S,C)
                                else ( S,C [ α 7-> C α f c,g ])
    mgn' κ τ' c τ (S,C) | ∃ "inst C => κ ~τ' :: c,~τ" ∈ Ds
                                = let S' = match ~τ' τ'
                                    (S'',C'') = mgu τ (S' ~τ) (S,C)
                                    {τ1 :: Γ1, ...,τn :: Γn} = S'C'
                                in (mgn τ1 Γ1 (... (mgn τn Γn (S'',C''))))

    (and similarly for ->, *, ())

  図6: 単一化アルゴリズムと正規化アルゴリズム

  関数 mgu は2つの型をとり、制約付き置換で変換器を返します。
  アプリケーション `mgu τ1 τ2 (S0,C0)` は、型 `τ1` と `τ2` を単一化し、そのような置換があれば `(S0,C0)` を保存する最も一般的な制約付き置換を返します。
  アルゴリズムは Robinson のものと同様であるが、 `mgu α τ (S0,C0)` の場合を除き、`τ` が ` C0 α` です。
  この制約は、 `τ` と `C α` に補助関数 `mgn` を適用することに変換されます。
  コール `mgn τ Γ (S0,C0)` は、存在するならば、`C0 ∪ {τ::Γ}` の最も一般的な正規化を計算します。

  **定理5.1** 束縛された置換 `(S0,C0)` と型 `τ1`、`τ2`が与えられ、 `τ1` と `τ2` のユニファイアが `(S0,C0)` であるならば、  `mgu τ1 τ2 (S0,C0)` は、最も一般的なそのようなユニファイアを返します。
  そのようなユニファイアがない場合、 `mgu τ1 τ2 (S0,C0)` は有限個のステップで失敗します。

### 型再構築

  型再構築のアルゴリズムを図7に示します。


    tp (x,A,S,C)                = inst (S(Ax),S,C)
    tp (e1 e 2,A,S,C)           = let (τ1,S1,C1) = tp (e1,A,S,C)
                                        (τ2,S2,C2) = tp (e2,A,S1,C1)
                                        α a fresh type variable
                                        (S3,C3) = mgu τ1 (τ2->α) (S2,C2.α :: {})
                                    in (S3 α, S3,C3)
    tp (λx.e,A,S,C)             = let α a fresh type variable
                                        (τ1,S1,C1) = tp (e1,A.x:α,S,C.α :: {})
                                    in (S1 α ->τ1,S1,C1)
    tp (let x = e1 in e2,A,S,C) = let (τ1,S1,C1) = tp (e1,A,S,C)
                                        (σ,C2)     = tpgen (τ1,S1 A,C1,C)
                                    in tp (e2,A.x:σ,S1,C2)

    where

    inst (∀α :: Γ.σ,S,C)        = let β a fresh type variable
                                    in inst ([α -> β] σ,S,C.β :: Γ)
    inst (τ,S,C)                 = (τ,S,C)

    tpgen (σ,A,C,C)              = if ∃α ∈ dom(C)\(fv(A) ∪ reg(C) ∪ dom(C)) then
                                        tpgen(∀α :: C α.σ,A,C\α,C')
                                    else (σ, C)

  図7: 型再構築アルゴリズム

  [1](＃1) 関数 `tp` は、式として式、仮定集合、初期制約付き置換を引数とし、型と最終制約付き置換を返します。
  この機能はプログラムに直接拡張されています。
  このセクションの残りの部分は、 `tp` とセクション4の型システム、それによってセクション3の型システムとの間の対応関係を確立します。

  我々のアルゴリズムの健全性と完全性を確立するためには、以下の補題が必要である。
  最初に、 `tp` が本当に制約のある置換変圧器であることを示すことから始めます。

  **補題5.2** `(S,C)` は制約付き置換であり、`(τ,S',C') = tp (e,A,S,C)` ならば、 `(S',C')` は束縛された置換です。

  したがって、我々は今から制約付き置換の要件を省略します。

  **補題5.3** もし `tp (e,A,S,C) = (τ,S,C)` ならば `(S,C) ≼ (S,C)` です。

  この結果は、**let**-ケースを除いて直接的誘導によって確立することができます。
  セクション4で提示された型付け規則 (let') を思い出してください。
  この規則の前件部には、 let-definition の型を導出するためのものと let-body の型のためのものの2つの文脈があります。
  しかし、第2のものだけが結論部分に現れ、第1のものに含まれ、 `gen` 関数によって一般化されるそれらのインスタンス仮定です。
  `tp` では、単一のコンテキストを維持し、それをアルゴリズム全体に渡します。
  `tp` の **let**-ケースで `gen` 関数を使用する場合は、前のステージで生成されたインスタンスの仮定を過大化し、初期コンテキストの一部として `tp` に渡します。

  ----

  1 これは実際には、単一化関数の呼び出しの後に循環的なコンテキストを得ることができるため、コンテキストに対する我々の制限に違反するので、実際のアルゴリズムの単純化です。
  ここで欠けているのは、cliquedetectionアルゴリズムです。これは、単に出現検査のバリエーションです。
  わかりやすくするために、ここでは省略します。

  ----

  <!-- page 8 -->

  このような過大化を避けるためには、 let-definition の型を再構築する際に生成されるインスタンスの仮定のみに一般化のドメインを限定する必要があります。
  新しい一般化関数 `tpgen` を定義します。これは、 `gen` と比較して、インスタンスの仮定が一般化から除外される余分なコンテキストパラメータ `C` を取ります。
  アルゴリズムでは、一般化を行うときに、一般化のドメインを制限するために、最初のコンテキストを2番目のコンテキスト引数として `tpgen` に渡します。
  したがって、新たに生成されたインスタンスの仮定のみが一般化されます。

  今度はアルゴリズムの健全性を述べることができます。

  **定理5.4** `tp(e,A,S,C) = (τ,S,C)` ならば `S'A,C' ⊢' e :τ`。

  定理4.4と合わせて、我々は以下の健全性の結果を得ます。

  **系5.5** (`tp`の健全性) `tp(e,A,S,C) = (τ,S',C')` ならば `S'A,C' ⊢ e : τ`。

  最終的には、主要型付け結果を述べます。

  **定理5.6** `S'A,C' ⊢' e : τ'` かつ `(S',C') ≼ (S0,C0)` ならば
  `tp(e,A,S0,C0)` は `(τ,S,C)` で成功し、以下のような置換 `R` が存在します:

    S'A = RSA,   C' ⊦⊦ RC,   かつ,   τ'= Rτ.

  定理4.5と合わせて、我々は完全性の結果を得ました。

  **系5.7** (`tp`の完全性) `S'A,C' ⊢ e : σ'` と `(S',C') ≼ (S0,C0)` とするならば、
  `tp(e,A,S0,C0)` は `(τ,S,C)` で成功し、 以下のような置換 `R` が存在し、

      S'A = RSA,   かつ    σ' ≼C' Rσ

  ここで `(σ、〜C)= gen(τ、SA,C)`です。

  当然のこととして、主要型スキームについては次のような結果が得られます。

  `tp(e,A,S0,C0) = (τ,S,C)` and `gen(τ,SA,C) = (σ,C')`とするならば、 `σ` は `SA` と `C` の下で `e` の主要型スキームです。

## 6 あいまいさ再訪

  はじめに見てきたように、パラメトリック型クラスは、型スキームがあいまいかもしれないという問題を標準型のクラスと共有します。

  **定義**　型スキーム `σ = ∀αi :: Γi.τ` が与えられたとき、`Cσ = {αi :: Γi}` を `σ` の一般的な文脈とします。

  **定義**　型スキーム `σ = ∀αi :: Γi .τ` のジェネリック型変数αは、(1) `Cσ α ≠ ∅`、 (2) `α ∉ Cσ* (fv τ)` となります。

  あいまいな型変数は、実装の問題を引き起こします。
  多相性のオーバーロードを実装する通常の方法は、関数シグネチャのコンテキスト内のすべての型クラスに対して余分な辞書引数を渡すことです。
  あいまいな変数の制約は空でないため(1)、辞書を渡す必要があります。
  しかし、あいまいな変数は型(2)で空にならないので、インスタンス化されることはありません。したがって、どの辞書を渡すべきかわかりません。
  別の見方から見ると、適切なインスタンス型の辞書がありますが、一貫性の問題があります。異なるセマンティクス[Jon92a]を持つ式の実装がいくつかあります。

  <!-- page 9 -->

  この問題は、明示的な型シグネチャを使用して、プログラマが必要に応じて式の曖昧性を排除するように要求することによって回避されます。
  概念的には、曖昧さチェックは型再構築後に行われます。それが型の再構成の一部である場合、主要型のプロパティは失われます。
  ある意味では、あいまいさの問題は、再構成された型があまりにも一般的であることを示しています。
  すべてのあいまいな型には明白な置換インスタンスがあります(あいまいな変数をインスタンス化するだけです)。
  問題は、最も一般的で曖昧ではない型が常にあるということです。

  多項式型のクラスと比較して、型システムはしばしばあいまいさの少ない型を生成します。
  以下の式を考えましょう:

    len :: (sa :: Sequence a) => sa -> Int

  複数引数型のクラスとして見れば、`a`は述語では発生しますが型ではないのであいまいです。
  しかし、パラメトリック型クラスとして見ると、`a` はあいまいではありません。型には発生しませんが、`(sa :: Sequence a)`によって `sa` に制約されず依存します。
  したがって、(1)と(2)の両方が失敗します。

  3項の制約(b)のために、型のトップレベル型コンストラクタは、渡す必要がある辞書を一意に決定します。次のようにして、曖昧さの問題をさらに減らすことができます。
  したがって、2つの型が同じトップレベル型コンストラクタ(ただし型引数が異なる可能性があります)がある場合、それらのディクショナリは同じデータコンストラクタを共有します(ただしパラメータは異なる可能性があります)。
  次の手法を使用して、トップレベル型コンストラクタの等価性を静的に認識できます。

  1つの型パラメータを持ち操作を持たない特別な `ルート` クラス `TC` を紹介します。
  すべての型は、以下のインスタンス宣言(すべての型 `κτ` に対して暗黙的に生成されると考えることができる)によって、 `TC` のインスタンスです。

    inst κ τ:: TC (κ ())

  実際には、 `TC` は型のトップレベル型コンストラクタを `isolate` するために使用されます。
  つまり、2つの型が `TC` 制約によって関連付けられている場合、それらは同じトップレベル型コンストラクタを持つことがわかります。
  この2つの型は、同様に呼ばれます。

  **定義** 文脈 `C` を与えられたとき、 `C`、 `(~C)` の類似性は、 `C ⊦⊦ τ1:: TC τ2` が `τ1 ~C τ2` となります。

   `TC` は型の再構築中に他のすべての型クラスと同様に扱われます。
  これはあいまいチェックで特に扱われ、あいまいさの基準を強化することができます:

  **定義** 型スキーム `σ` におけるジェネリック型変数αは、 `α` が `σ` において弱く曖昧である場合は強くあいまいであり、全ての型 `τ, α ~ Cσ` は `τ` を意味する `σ` では強くあいまいな型変数です。

  `TC` 技術は、我々が正確に型をマップすることを可能にします[2](#2)

    map : ∀a.∀b.∀t.

        ∀sa :: {Sequence a,TC t}.
        ∀sb :: {Sequence b,TC t}.(a -> b) -> sa -> sb

  ----

  <a name="2"> </a> 2これまでに、順序単一化。

  ----

  <!-- page 10 -->

  これは、 `sa` と `sb` は要素型 `a` と `b` を持つ Sequence のインスタンス型で、 `sa` と `sb` は同じ型のコンストラクタを共有していると言います。

  `sa` と `sb` が同じ型のコンストラクタを持っているという知識は、最初はコンパイラ生成のインスタンス宣言の形から導かれたメタレベル上にあります。
  これを型システムで次のように形式化することができます。

  **定義** 型スキーム `σ = ∀αi :: Γi.τ'` は、 `Γi` のどれも `TC (κ τ)`を含まない場合、任意のコンストラクタ `κ` のための縮小された形式です。 `τ` と入力します。
  型スキームには `σR` を使用します。

  **定義** すべての縮小型スキーム `σR` について、2つの型スキーム `σ1` 、 `σ2` は、 文脈 `C` かつ `σ1 ≃C σ2`の下で同一です。

    σR ≼C σ1    ⇔    σR ≼C σ2.

  等式を含むようにジェネリックインスタンスの定義を拡張します。型スキーム `σ1` は、型スキーム `σ' s.t` が存在する場合、コンテキスト `C` の下で型スキーム `σ2` の一般的なインスタンスです。
  第3章の `≼C` の定義に従って、 `σ1 ≃C σ'` と `σ' ≼C σ2` を定義します。
  一般的なインスタンスのこの強力な概念は、ユーザー定義の型シグネチャをチェックするために重要です。

  **例:** `sa` に `List a` を代入すると、 `map` の型シグネチャは次のようになります:

    ∀sb :: {Sequence b,TC (List())} : (a -> b) -> List a -> sb

  一方、リストのマップの通常の定義には、次のような型があります:

    (a -> b) -> List a -> List b

  第1の型が第2の型のインスタンスであることを検証するためには、等価が必要です。

  文脈を短くするために、次のセクションでは、類似性の関係を `TC` の定義ではなく `(~)` に直接使用します。

## 7 Monads からリストへ

  このセクションでは、パラメトリック型クラスを使用して、以前はリストに限定されていた操作と概念の多くを一般化する方法を示します。
  はじめにスケッチされているように、最初のステップは、シーケンスのすべての実装に共通の操作をオーバーロードします。
  いくつかの重要な操作は、より一般的な Moand コンテキスト[Wad90]でも適用できます。したがって、 "Monad" と "Monad with zero" を "Sequence" のスーパークラスとして持つことは理にかなっています。
  次の列挙は、階層内のどのレベルでよく知られたリスト操作が定義されているかを示します。

  **モナド:** unit、join、map、monad comprehensions。

  **Monad0:* nil、filter、filter付きのcomprehensions。

  **Sequence:** cons, hd, tl, reverse, foldl, foldr, (++).

  関数プログラミングにおけるモナドの使用は[Wad90、Wad91]で調査されました。概念の動機付けのために、読者にそこに与えられた例を紹介します。
  ここで調査したいのは、具体的な実装から抽象化できるように、プログラミング言語の型システムでモナド(とその特殊化)を表現する方法です。
  パラメトリック型クラスを使用して、モナド演算がどのようにオーバーロードされるかを示します。
  これは、任意のモナド上の関数を定義し、異なるモナド上の演算に同じ名前を再利用し、現在の構文を変更することなくリスト内包を一般化することができるので便利です。

  Monadクラスを次のように定式化します:

    class ma :: Monad a where
        unit :: a -> ma
        bind :: (mb :: Monad b, ma ~ mb)
                => ma -> (a -> mb) -> mb
        map  :: (mb :: Monad b, ma ~ mb)
                => (a -> b) -> ma -> mb
        join :: (mma :: Monad ma, mma ~ ma)
                => mma -> ma
    -- Default definitions:
        map f xs  = xs `bind` (unit . f)
        join xss  = xss `bind` id
        bind xs f = join (map f xs)

  これは、モナドの2つの等価な公式を導入します。一つは `unit` と `bind` であり、もう一つは `unit`、`map`、`join` の観点からです。
  クラスのデフォルト定義では、一方の定式化を他方の定式化で表します。インスタンスは代わりに `bind` または `map` と `join` を定義することができます。
  モナドの資格を得るためには、インスタンスは3つの法則を満たさなければならず、これは型システムによって強制されません。
  `bind` は左と右の単位として `unit` を伴って結合的でなければなりません:

    (m `bind` f) `bind` g = m `bind` \x -> f x `bind` g
    \x -> unit x `bind` f = f
    m `bind` unit         = m

  リストは、次のインスタンス宣言とモナド法が保有するチェックによって目撃されるように、モナドを形成します。

    inst List a :: Monad a where
        unit x          = [x]
        map f [] xs     = []
        map f (x:xs)    = f x : map f xs
        join []         = []
        join (xs::xss)  = xs ++ join xss

  モナドのもう一つの例は、次のような "reply"-型です:

    data Maybe a = Some a | None

    inst Maybe a :: Monad a where
        unit x          = Some x
        bind (Some x) f = f x
        bind None f     = None

  その結果、リストや応答型や他のモナドインスタンスで動作するコードを書くことができるようになりました。
  特に、 `unit`、` map`、 `join`に標準翻訳を適用することで、それぞれの場合にリスト理解表記を使用できます。

  <!-- page 11 -->

    [t]           ≙ unit t
    [t | g1,g2]   ≙ join [[t | g2] | g1]
    [t | x <- e]  ≙ map (x : t) e

  ここで、 `t` と `e` は項、 `x` は変数、 `g1` と `g2` はジェネレータ `x <- e` です。

  Monad0 は Monad のサブクラスです。
  これはゼロモナド、`nil`、および `filter` 関数を追加します。

    class (ma :: Monad a) => ma :: Monad0 a where
        nil     :: ma
        filter  :: (a -> Bool) -> ma -> ma

  ゼロのつくモナドは、フィルタ付きのリスト内包を定義できる最も一般的な型クラスです。
  標準翻訳関数は( `p` はフィルタ、すなわちブール項です)。

    []      ≙ nil
    [t | p] ≙ filter p (unit t)

  リストと返信の両方の型は、次のようにゼロになります。

    instance List a :: Monad0 a where
        nil               = []
        filter p []       = []
        filter p (x:xs)   = if p x then
                                x : filter p xs
                            else filter p xs

    instance Maybe a : Monad0 a where
        nil               = None
        filter p None     = None
        filter p (Some x) = if p x then Some x
                            else None

  Monadsを使ったプログラミングの例として、抽象パーサについて議論し、[Wad90]の例を適用して拡張します。
  パーサーは、入力シンボルのシーケンスを出力にマップする関数です。正当な解析が存在しない場合は、失敗した値にマップします。
  解析が存在する場合は、入力ストリームの未使用部分と解析ツリーなどのアプリケーション依存の結果値で構成されます。
  パーサーがバックトラックを使用する場合、そのような解析がいくつか存在する可能性がありますが、determinsticの場合はゼロまたは1が存在します。
  以下では、決定性パーサのためのライブラリを構築します。
  そのようなパーサーはすべて型シグネチャを持ちます:

    data Parser a = P (String -> Maybe (a, String))

  インスタンスはデータ型でしか構成できないという制約があるため、コンストラクタタグ `P` が必要です。
  パーサーは、以下のインスタンス宣言によって目撃されるように、ゼロを持つモナドを形成します。

    inst Parser a :: Monad a where
        unit x      = P (\i -> [(x, i)])
        map f (P p) = P (\i ->
                            [(f x, i') | (x, i') <- p i])
        join (P pp) = P (\i ->
                            [(x, i'') | (P p, i') <- pp i,
                                        (x, i'') <- p i'])

    inst Parser a :: Monad0 a where
        nil             = P (\i -> [])
        filter b (P p)  = P (\i ->
                                [(x, i') | (x, i') <- p i,
                                        b x])

  我々は理解の表記に過負荷をかけていることに注意してください。
  前の2つのインスタンス宣言のモナドの補完は、リストではなくオプションの型で機能します。

  2つのプリミティブパーサーともう1つのパーサーコンビネータが必要です。

    sym         :: Parser Char
    sym         = P p
                    where p Nil         = []
                        p (Cons c cs) = [(c, cs)]

    lookahead   :: Parser Char
    lookahead   = P p
                    where p Nil = []
                        p cs  = [(hd cs, cs)]

    (|||)       :: Parser a -> Parser a -> Parser a
    P p ||| P q = P (\i -> case p i of
                                None   => q i
                            | Some x => Some x)

  ラムダ項の決定論的パーサーは、次のように書くことができます。

    data Term = Lambda Term Term
                | Apply Term Term
                | Id Char
                | Error

    term     :: Parser Term
    term     =  [Lambda x y | '\' <- sym,
                                x <- ident, y <- term]
            ||| fly | x <- aterm, y <- aterms x]

    aterm    :: Parser Term
    aterm    = [x | '(' <- sym, x <- aterm']
            ||| ident

    aterm'   :: Parser Term
    aterm'   = [x | x <- term, ')' <- sym]
            ||| [Error]

    aterms   :: Term -> Parser Term
    aterms x =  [z | c <- lookahead,
                    'a' <= c && c <= 'z' || c = '(',
                    y <- aterm,
                    z <- aterms (Apply x y)]
            ||| [x]

    ident    :: Parser Term
    ident    =  [Id c | c <- sym, 'a' <= c && c <= 'z']
            ||| [Error]

  <!-- page 12 -->

  定義されたパーサーは決定的です。それは決して逆戻りしません。
  したがって、解析の失敗は、プロダクションの開始時に発生するのか、途中で発生するのかによって異なるように扱われなければなりません。
  生産開始時に障害が発生した場合は、別の代替案を試してください。
  プロダクションの途中でエラーが発生すると、エラー・ノードを戻すことによって報告される構文エラーが通知されます。

  生産の大部分はモナド理解の観点から表現されていることに注意してください。
  今回は、オプションの種類やリストの代わりにパーサを参照しています。
  [Wad90]とは違って、モナドの包摂は参照するモナドにラベルを付ける必要はありません。我々は代わりに曖昧さを除去するために型システムに依存します(あいまいさがなければプログラマが定義した型付けを含みます)。
  モナドスタイルは、解析と抽象的なツリー生成との間の柔軟なインターフェースを提供します。
  生成されるパーサーは、合成された属性と継承された属性の両方を持つ属性文法に似ています(atermの定義を参照)。

## 8 結論

  オーバーロードされたデータコンストラクタとセレクタを持つコンテナクラスをサポートするために、Haskellの型クラスの一般化を提案しました。
  基礎となる型のシステムは、パラメトリック型クラスを持つ Hindley/Milner システムの拡張です。
  この拡張は、元のシステムの2つの重要な特性、すなわち決定可能な型定義性とプリンシパル型を保持します。
  その型スキームは、限定された定量化を使用し、その導入および除去は、別の状況制約付きインスタンス理論に依存します。
  型推論システムからインスタンス理論を切り離すことで、我々のシステムは以前の作業よりもモジュール化されています。
  得られたモジュール性は、実装者にとって大きな助けになると考えています。

  これまで説明していない点は、実行時にパラメトリック型クラスを実装する方法です。
  本質的に、[WB89]の行に沿った Haskell への翻訳スキームを採用することができます。
  型クラスの追加パラメータは、ランタイム辞書のパラメータに変換されます。
  そのような変換は、パラメトリック型クラスの(変換的)セマンティクスを提供することができます。
  良いランタイムモデルを提供できるかどうかは議論の余地があります。
  この翻訳スキームに基づいた既存の実装は、実行時のパフォーマンスが批判されています。
  原則として、型クラスを持つプログラムの実行時のパフォーマンスは、オブジェクト指向言語で記述されたプログラムのパフォーマンスよりも悪くあってはならないと主張します。
  さらに、同様の最適化手法を用いることができます[CU90]。

## 参考文献

  [CCH+89] P. Canning, W. Cook, W. Hill, W. Olthff, and J. Mitchell. F-bounded polymorphism for objectoriented programming. In Proc. ACM Conf. Functional Programming Languages and Computer Architecture, pages 273-280, 1989.

  [COH92] Kung Chen, Martin Odersky, and Paul Hudak. Type inference for parametric type classes. Technical Report YALEU/DCS/RR-900, Dept. of Computer Science, Yale University, New Haven, Conn., May 1992.

  [CU90] Craig Chambers and David Ungar. Iterative type analysis and extended message splitting: Optimizing dynamically-typedobject-orientedprograms. In Proc. SIGPLAN '90 Conf. on Programming Language Design and Implementation , White Plains, New York, June 1990.

  [DM82] L. Damas and R. Milner. Principal type schemes for functional programs. In Proc. 9th ACM Symp. on Principles of Programming Languages , pages 207212, Jan. 1982.

  [HJW91] Paul Hudak, Simon Peyton Jones, and Philip L. Wadler. Report on the programming language Haskell: a non-strict, purely functional language, version 1.1. Technical Report YALEU/DCS/RR-777, Dept. of Computer Science, Yale University, New Haven, Conn., August 1991.

  [Jon91] Mark P. Jones. Type inference for qualified types. Technical Report PRG-TR-10-91, Oxford University Computing Laboratory, Oxford, UK, 1991.

  [Jon92a] Mark P. Jones. Coherence for qualified types. Private communication, March 1992.

  [Jon92b] Mark P. Jones. A theory of qualified types. In B. Krieg-Brfluckner, editor, Proc. European Sysposium on Programming, pages 287-306. Springer Verlag, Feburary 1992. LNCS 582.

  [JT81] R.D. Jenks and B.M. Trager. A language for computational algebra. In Proc. ACM Symposium on Symbolic and Algebraic Manipulation , pages 22-29, 1981.

  [Kae88] S. Kaes. Parametric overloading in polymorphic programming languages. In H. Ganzinger, editor, Proc. 2nd European Symosium on Programming, Lecture Notes in Computer Science, Vol. 300 , pages 131-144, Nancy, France, March 1988. Springer-Verlag.

  [Lil91] Mark D. Lilibridge. A generalization of type classes. distributed to Haskell mailing list, June 1991.

  [MGS89] J. Meseguer, J. Goguen, and G. Smolka. Ordersorted unification. J. Symbolic Computation , 8:383-413, 1989.

  [NS91] T. Nipkow and G. Snelting. Type classes and overloading resolution via order-sorted unification. In J. Hughes, editor, Proc. Conf. on Functional Programming and Computer Architecture , pages 15-28. Springer-Verlag, 1991. LNCS 523.

  [Rob65] J. Robinson. A machine-oriented logic based on the resolution principle. J. Assoc. Comput. Mach., 12(1):23-41, 1965.

  [Rou90] Francois Rouaix. Safe run-time overloading. In Seventeenth Annual ACM Symp. on Principles of Programming Languages, pages 355-366, San Franscico, CA, January 1990.

  [VS91] Dennis M. Volpano and Geffery S. Smith. On the complexity of ML typability and overloading. In J. Hughes, editor, Proceedings of Functional Programming and Computer Architecture, pages 15-28. Springer-Verlag, 1991. LNCS 523.

  [Wad90] P. Wadler. Comprehending monads. In Proc. ACM Conf. on LISP and Functional Programming , pages 61-78, June 1990.

  [Wad91] P. Wadler. Continuing monads, August 1991. Tutorial Notes at FPCA'91.

  [WB89] Phil Wadler and Stephen Blott. How to make adhoc polymorphism less ad hoc. In Sixteenth Annual ACM Symp. on Principles of Programming Languages, pages 60-76. ACM, 1989.
